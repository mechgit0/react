{"ast":null,"code":"/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst {\n  hashObject,\n  isObject,\n  getLabels,\n  removeLabels,\n  nowTimestamp\n} = require('./util');\nconst {\n  validateLabel\n} = require('./validation');\nconst {\n  Metric\n} = require('./metric');\nconst Exemplar = require('./exemplar');\nclass Counter extends Metric {\n  constructor(config) {\n    super(config);\n    this.type = 'counter';\n    this.defaultLabels = {};\n    this.defaultValue = 1;\n    this.defaultExemplarLabelSet = {};\n    if (config.enableExemplars) {\n      this.enableExemplars = true;\n      this.inc = this.incWithExemplar;\n    } else {\n      this.inc = this.incWithoutExemplar;\n    }\n  }\n\n  /**\n   * Increment counter\n   * @param {object} labels - What label you want to be incremented\n   * @param {Number} value - Value to increment, if omitted increment with 1\n   * @returns {object} results - object with information about the inc operation\n   * @returns {string} results.labelHash - hash representation of the labels\n   */\n  incWithoutExemplar(labels, value) {\n    let hash = '';\n    if (isObject(labels)) {\n      hash = hashObject(labels, this.sortedLabelNames);\n      validateLabel(this.labelNames, labels);\n    } else {\n      value = labels;\n      labels = {};\n    }\n    if (value && !Number.isFinite(value)) {\n      throw new TypeError(`Value is not a valid number: ${util.format(value)}`);\n    }\n    if (value < 0) {\n      throw new Error('It is not possible to decrease a counter');\n    }\n    if (value === null || value === undefined) value = 1;\n    setValue(this.hashMap, value, labels, hash);\n    return {\n      labelHash: hash\n    };\n  }\n\n  /**\n   * Increment counter with exemplar, same as inc but accepts labels for an\n   * exemplar.\n   * If no label is provided the current exemplar labels are kept unchanged\n   * (defaults to empty set).\n   *\n   * @param {object} incOpts - Object with options about what metric to increase\n   * @param {object} incOpts.labels - What label you want to be incremented,\n   *                                  defaults to null (metric with no labels)\n   * @param {Number} incOpts.value - Value to increment, defaults to 1\n   * @param {object} incOpts.exemplarLabels - Key-value  labels for the\n   *                                          exemplar, defaults to empty set {}\n   * @returns {void}\n   */\n  incWithExemplar() {\n    let {\n      labels = this.defaultLabels,\n      value = this.defaultValue,\n      exemplarLabels = this.defaultExemplarLabelSet\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const res = this.incWithoutExemplar(labels, value);\n    this.updateExemplar(exemplarLabels, value, res.labelHash);\n  }\n  updateExemplar(exemplarLabels, value, hash) {\n    if (exemplarLabels === this.defaultExemplarLabelSet) return;\n    if (!isObject(this.hashMap[hash].exemplar)) {\n      this.hashMap[hash].exemplar = new Exemplar();\n    }\n    this.hashMap[hash].exemplar.validateExemplarLabelSet(exemplarLabels);\n    this.hashMap[hash].exemplar.labelSet = exemplarLabels;\n    this.hashMap[hash].exemplar.value = value ? value : 1;\n    this.hashMap[hash].exemplar.timestamp = nowTimestamp();\n  }\n\n  /**\n   * Reset counter\n   * @returns {void}\n   */\n  reset() {\n    this.hashMap = {};\n    if (this.labelNames.length === 0) {\n      setValue(this.hashMap, 0);\n    }\n  }\n  async get() {\n    if (this.collect) {\n      const v = this.collect();\n      if (v instanceof Promise) await v;\n    }\n    return {\n      help: this.help,\n      name: this.name,\n      type: this.type,\n      values: Object.values(this.hashMap),\n      aggregator: this.aggregator\n    };\n  }\n  labels() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const labels = getLabels(this.labelNames, args) || {};\n    return {\n      inc: this.inc.bind(this, labels)\n    };\n  }\n  remove() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const labels = getLabels(this.labelNames, args) || {};\n    validateLabel(this.labelNames, labels);\n    return removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n  }\n}\nfunction setValue(hashMap, value) {\n  let labels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let hash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  if (hashMap[hash]) {\n    hashMap[hash].value += value;\n  } else {\n    hashMap[hash] = {\n      value,\n      labels\n    };\n  }\n  return hashMap;\n}\nmodule.exports = Counter;","map":{"version":3,"names":["util","require","hashObject","isObject","getLabels","removeLabels","nowTimestamp","validateLabel","Metric","Exemplar","Counter","constructor","config","type","defaultLabels","defaultValue","defaultExemplarLabelSet","enableExemplars","inc","incWithExemplar","incWithoutExemplar","labels","value","hash","sortedLabelNames","labelNames","Number","isFinite","TypeError","format","Error","undefined","setValue","hashMap","labelHash","exemplarLabels","arguments","length","res","updateExemplar","exemplar","validateExemplarLabelSet","labelSet","timestamp","reset","get","collect","v","Promise","help","name","values","Object","aggregator","_len","args","Array","_key","bind","remove","_len2","_key2","call","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/counter.js"],"sourcesContent":["/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst {\n\thashObject,\n\tisObject,\n\tgetLabels,\n\tremoveLabels,\n\tnowTimestamp,\n} = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst Exemplar = require('./exemplar');\n\nclass Counter extends Metric {\n\tconstructor(config) {\n\t\tsuper(config);\n\t\tthis.type = 'counter';\n\t\tthis.defaultLabels = {};\n\t\tthis.defaultValue = 1;\n\t\tthis.defaultExemplarLabelSet = {};\n\t\tif (config.enableExemplars) {\n\t\t\tthis.enableExemplars = true;\n\t\t\tthis.inc = this.incWithExemplar;\n\t\t} else {\n\t\t\tthis.inc = this.incWithoutExemplar;\n\t\t}\n\t}\n\n\t/**\n\t * Increment counter\n\t * @param {object} labels - What label you want to be incremented\n\t * @param {Number} value - Value to increment, if omitted increment with 1\n\t * @returns {object} results - object with information about the inc operation\n\t * @returns {string} results.labelHash - hash representation of the labels\n\t */\n\tincWithoutExemplar(labels, value) {\n\t\tlet hash = '';\n\t\tif (isObject(labels)) {\n\t\t\thash = hashObject(labels, this.sortedLabelNames);\n\t\t\tvalidateLabel(this.labelNames, labels);\n\t\t} else {\n\t\t\tvalue = labels;\n\t\t\tlabels = {};\n\t\t}\n\n\t\tif (value && !Number.isFinite(value)) {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (value < 0) {\n\t\t\tthrow new Error('It is not possible to decrease a counter');\n\t\t}\n\n\t\tif (value === null || value === undefined) value = 1;\n\n\t\tsetValue(this.hashMap, value, labels, hash);\n\n\t\treturn { labelHash: hash };\n\t}\n\n\t/**\n\t * Increment counter with exemplar, same as inc but accepts labels for an\n\t * exemplar.\n\t * If no label is provided the current exemplar labels are kept unchanged\n\t * (defaults to empty set).\n\t *\n\t * @param {object} incOpts - Object with options about what metric to increase\n\t * @param {object} incOpts.labels - What label you want to be incremented,\n\t *                                  defaults to null (metric with no labels)\n\t * @param {Number} incOpts.value - Value to increment, defaults to 1\n\t * @param {object} incOpts.exemplarLabels - Key-value  labels for the\n\t *                                          exemplar, defaults to empty set {}\n\t * @returns {void}\n\t */\n\tincWithExemplar({\n\t\tlabels = this.defaultLabels,\n\t\tvalue = this.defaultValue,\n\t\texemplarLabels = this.defaultExemplarLabelSet,\n\t} = {}) {\n\t\tconst res = this.incWithoutExemplar(labels, value);\n\t\tthis.updateExemplar(exemplarLabels, value, res.labelHash);\n\t}\n\n\tupdateExemplar(exemplarLabels, value, hash) {\n\t\tif (exemplarLabels === this.defaultExemplarLabelSet) return;\n\t\tif (!isObject(this.hashMap[hash].exemplar)) {\n\t\t\tthis.hashMap[hash].exemplar = new Exemplar();\n\t\t}\n\t\tthis.hashMap[hash].exemplar.validateExemplarLabelSet(exemplarLabels);\n\t\tthis.hashMap[hash].exemplar.labelSet = exemplarLabels;\n\t\tthis.hashMap[hash].exemplar.value = value ? value : 1;\n\t\tthis.hashMap[hash].exemplar.timestamp = nowTimestamp();\n\t}\n\n\t/**\n\t * Reset counter\n\t * @returns {void}\n\t */\n\treset() {\n\t\tthis.hashMap = {};\n\t\tif (this.labelNames.length === 0) {\n\t\t\tsetValue(this.hashMap, 0);\n\t\t}\n\t}\n\n\tasync get() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype: this.type,\n\t\t\tvalues: Object.values(this.hashMap),\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args) || {};\n\t\treturn {\n\t\t\tinc: this.inc.bind(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args) || {};\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction setValue(hashMap, value, labels = {}, hash = '') {\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t} else {\n\t\thashMap[hash] = { value, labels };\n\t}\n\treturn hashMap;\n}\n\nmodule.exports = Counter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}