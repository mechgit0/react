{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return NextNodeServer;\n  }\n});\n0 && __export(require(\"./base-server\"));\nrequire(\"./node-environment\");\nrequire(\"./require-hook\");\nrequire(\"./node-polyfill-crypto\");\nconst _utils = require(\"../shared/lib/utils\");\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _path = require(\"path\");\nconst _routematcher = require(\"../shared/lib/router/utils/route-matcher\");\nconst _requestmeta = require(\"./request-meta\");\nconst _constants = require(\"../shared/lib/constants\");\nconst _findpagesdir = require(\"../lib/find-pages-dir\");\nconst _node = require(\"./base-http/node\");\nconst _sendpayload = require(\"./send-payload\");\nconst _parseurl = require(\"../shared/lib/router/utils/parse-url\");\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../build/output/log\"));\nconst _baseserver = /*#__PURE__*/_interop_require_wildcard(_export_star(require(\"./base-server\"), exports));\nconst _require = require(\"./require\");\nconst _denormalizepagepath = require(\"../shared/lib/page-path/denormalize-page-path\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _loadcomponents = require(\"./load-components\");\nconst _iserror = /*#__PURE__*/_interop_require_wildcard(require(\"../lib/is-error\"));\nconst _utils1 = require(\"./web/utils\");\nconst _middlewareroutematcher = require(\"../shared/lib/router/utils/middleware-route-matcher\");\nconst _env = require(\"@next/env\");\nconst _querystring = require(\"../shared/lib/router/utils/querystring\");\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _getnextpathnameinfo = require(\"../shared/lib/router/utils/get-next-pathname-info\");\nconst _bodystreams = require(\"./body-streams\");\nconst _apiutils = require(\"./api-utils\");\nconst _responsecache = /*#__PURE__*/_interop_require_wildcard(require(\"./response-cache\"));\nconst _incrementalcache = require(\"./lib/incremental-cache\");\nconst _apppaths = require(\"../shared/lib/router/utils/app-paths\");\nconst _setuphttpagentenv = require(\"./setup-http-agent-env\");\nconst _pagesapiroutematch = require(\"./route-matches/pages-api-route-match\");\nconst _constants1 = require(\"../lib/constants\");\nconst _tracer = require(\"./lib/trace/tracer\");\nconst _constants2 = require(\"./lib/trace/constants\");\nconst _nodefsmethods = require(\"./lib/node-fs-methods\");\nconst _routeregex = require(\"../shared/lib/router/utils/route-regex\");\nconst _pipereadable = require(\"./pipe-readable\");\nconst _mockrequest = require(\"./lib/mock-request\");\nconst _approuterheaders = require(\"../client/components/app-router-headers\");\nconst _nextrequest = require(\"./web/spec-extension/adapters/next-request\");\nconst _routemoduleloader = require(\"./lib/module-loader/route-module-loader\");\nconst _loadmanifest = require(\"./load-manifest\");\nconst _modulerender = require(\"./route-modules/app-page/module.render\");\nconst _modulerender1 = require(\"./route-modules/pages/module.render\");\nconst _interopdefault = require(\"../lib/interop-default\");\nconst _formatdynamicimportpath = require(\"../lib/format-dynamic-import-path\");\nconst _generateinterceptionroutesrewrites = require(\"../lib/generate-interception-routes-rewrites\");\nconst _routekind = require(\"./route-kind\");\nconst _invarianterror = require(\"../shared/lib/invariant-error\");\nconst _awaiter = require(\"./after/awaiter\");\nconst _asynccallbackset = require(\"./lib/async-callback-set\");\nconst _handlers = require(\"./use-cache/handlers\");\nfunction _export_star(from, to) {\n  Object.keys(from).forEach(function (k) {\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(to, k)) {\n      Object.defineProperty(to, k, {\n        enumerable: true,\n        get: function () {\n          return from[k];\n        }\n      });\n    }\n  });\n  return from;\n}\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n// For module that can be both CJS or ESM\nconst dynamicImportEsmDefault = process.env.NEXT_MINIMAL ? id => import(/* webpackIgnore: true */id).then(mod => mod.default || mod) : id => import(id).then(mod => mod.default || mod);\n// For module that will be compiled to CJS, e.g. instrument\nconst dynamicRequire = process.env.NEXT_MINIMAL ? __non_webpack_require__ : require;\nconst MiddlewareMatcherCache = new WeakMap();\nfunction getMiddlewareMatcher(info) {\n  const stored = MiddlewareMatcherCache.get(info);\n  if (stored) {\n    return stored;\n  }\n  if (!Array.isArray(info.matchers)) {\n    throw Object.defineProperty(new Error(`Invariant: invalid matchers for middleware ${JSON.stringify(info)}`), \"__NEXT_ERROR_CODE\", {\n      value: \"E257\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  const matcher = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(info.matchers);\n  MiddlewareMatcherCache.set(info, matcher);\n  return matcher;\n}\nclass NextNodeServer extends _baseserver.default {\n  constructor(options) {\n    var _options_conf_experimental_sri, _options_conf_experimental;\n    // Initialize super class\n    super(options), this.registeredInstrumentation = false, this.cleanupListeners = new _asynccallbackset.AsyncCallbackSet(), this.handleNextImageRequest = async (req, res, parsedUrl) => {\n      if (!parsedUrl.pathname || !parsedUrl.pathname.startsWith('/_next/image')) {\n        return false;\n      }\n      // Ignore if its a middleware request\n      if ((0, _requestmeta.getRequestMeta)(req, 'middlewareInvoke')) {\n        return false;\n      }\n      if (this.minimalMode || this.nextConfig.output === 'export' || process.env.NEXT_MINIMAL) {\n        res.statusCode = 400;\n        res.body('Bad Request').send();\n        return true;\n        // the `else` branch is needed for tree-shaking\n      } else {\n        const {\n          ImageOptimizerCache\n        } = require('./image-optimizer');\n        const imageOptimizerCache = new ImageOptimizerCache({\n          distDir: this.distDir,\n          nextConfig: this.nextConfig\n        });\n        const {\n          sendResponse,\n          ImageError\n        } = require('./image-optimizer');\n        if (!this.imageResponseCache) {\n          throw Object.defineProperty(new Error('invariant image optimizer cache was not initialized'), \"__NEXT_ERROR_CODE\", {\n            value: \"E160\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n        const imagesConfig = this.nextConfig.images;\n        if (imagesConfig.loader !== 'default' || imagesConfig.unoptimized) {\n          await this.render404(req, res);\n          return true;\n        }\n        const paramsResult = ImageOptimizerCache.validateParams(req.originalRequest, parsedUrl.query, this.nextConfig, !!this.renderOpts.dev);\n        if ('errorMessage' in paramsResult) {\n          res.statusCode = 400;\n          res.body(paramsResult.errorMessage).send();\n          return true;\n        }\n        const cacheKey = ImageOptimizerCache.getCacheKey(paramsResult);\n        try {\n          var _cacheEntry_value, _cacheEntry_cacheControl;\n          const {\n            getExtension\n          } = require('./serve-static');\n          const cacheEntry = await this.imageResponseCache.get(cacheKey, async _ref => {\n            let {\n              previousCacheEntry\n            } = _ref;\n            const {\n              buffer,\n              contentType,\n              maxAge,\n              upstreamEtag,\n              etag\n            } = await this.imageOptimizer(req, res, paramsResult, previousCacheEntry);\n            return {\n              value: {\n                kind: _responsecache.CachedRouteKind.IMAGE,\n                buffer,\n                etag,\n                extension: getExtension(contentType),\n                upstreamEtag\n              },\n              isFallback: false,\n              cacheControl: {\n                revalidate: maxAge,\n                expire: undefined\n              }\n            };\n          }, {\n            routeKind: _routekind.RouteKind.IMAGE,\n            incrementalCache: imageOptimizerCache,\n            isFallback: false\n          });\n          if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== _responsecache.CachedRouteKind.IMAGE) {\n            throw Object.defineProperty(new Error('invariant did not get entry from image response cache'), \"__NEXT_ERROR_CODE\", {\n              value: \"E518\",\n              enumerable: false,\n              configurable: true\n            });\n          }\n          sendResponse(req.originalRequest, res.originalResponse, paramsResult.href, cacheEntry.value.extension, cacheEntry.value.buffer, cacheEntry.value.etag, paramsResult.isStatic, cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT', imagesConfig, ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.revalidate) || 0, Boolean(this.renderOpts.dev));\n          return true;\n        } catch (err) {\n          if (err instanceof ImageError) {\n            res.statusCode = err.statusCode;\n            res.body(err.message).send();\n            return true;\n          }\n          throw err;\n        }\n      }\n    }, this.handleCatchallRenderRequest = async (req, res, parsedUrl) => {\n      let {\n        pathname,\n        query\n      } = parsedUrl;\n      if (!pathname) {\n        throw Object.defineProperty(new Error('Invariant: pathname is undefined'), \"__NEXT_ERROR_CODE\", {\n          value: \"E409\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      // This is a catch-all route, there should be no fallbacks so mark it as\n      // such.\n      (0, _requestmeta.addRequestMeta)(req, 'bubbleNoFallback', true);\n      try {\n        var _this_i18nProvider;\n        // next.js core assumes page path without trailing slash\n        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const options = {\n          i18n: (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.fromRequest(req, pathname)\n        };\n        const match = await this.matchers.match(pathname, options);\n        // If we don't have a match, try to render it anyways.\n        if (!match) {\n          await this.render(req, res, pathname, query, parsedUrl, true);\n          return true;\n        }\n        // Add the match to the request so we don't have to re-run the matcher\n        // for the same request.\n        (0, _requestmeta.addRequestMeta)(req, 'match', match);\n        // TODO-APP: move this to a route handler\n        const edgeFunctionsPages = this.getEdgeFunctionsPages();\n        for (const edgeFunctionsPage of edgeFunctionsPages) {\n          // If the page doesn't match the edge function page, skip it.\n          if (edgeFunctionsPage !== match.definition.page) continue;\n          if (this.nextConfig.output === 'export') {\n            await this.render404(req, res, parsedUrl);\n            return true;\n          }\n          delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];\n          // If we handled the request, we can return early.\n          // For api routes edge runtime\n          try {\n            const handled = await this.runEdgeFunction({\n              req,\n              res,\n              query,\n              params: match.params,\n              page: match.definition.page,\n              match,\n              appPaths: null\n            });\n            if (handled) return true;\n          } catch (apiError) {\n            await this.instrumentationOnRequestError(apiError, req, {\n              routePath: match.definition.page,\n              routerKind: 'Pages Router',\n              routeType: 'route',\n              // Edge runtime does not support ISR\n              revalidateReason: undefined\n            });\n            throw apiError;\n          }\n        }\n        // If the route was detected as being a Pages API route, then handle\n        // it.\n        // TODO: move this behavior into a route handler.\n        if ((0, _pagesapiroutematch.isPagesAPIRouteMatch)(match)) {\n          if (this.nextConfig.output === 'export') {\n            await this.render404(req, res, parsedUrl);\n            return true;\n          }\n          const handled = await this.handleApiRequest(req, res, query, match);\n          if (handled) return true;\n        }\n        await this.render(req, res, pathname, query, parsedUrl, true);\n        return true;\n      } catch (err) {\n        if (err instanceof _baseserver.NoFallbackError) {\n          throw err;\n        }\n        try {\n          if (this.renderOpts.dev) {\n            const {\n              formatServerError\n            } = require('../lib/format-server-error');\n            formatServerError(err);\n            this.logErrorWithOriginalStack(err);\n          } else {\n            this.logError(err);\n          }\n          res.statusCode = 500;\n          await this.renderError(err, req, res, pathname, query);\n          return true;\n        } catch {}\n        throw err;\n      }\n    }, this.handleCatchallMiddlewareRequest = async (req, res, parsed) => {\n      const isMiddlewareInvoke = (0, _requestmeta.getRequestMeta)(req, 'middlewareInvoke');\n      if (!isMiddlewareInvoke) {\n        return false;\n      }\n      const handleFinished = () => {\n        (0, _requestmeta.addRequestMeta)(req, 'middlewareInvoke', true);\n        res.body('').send();\n        return true;\n      };\n      const middleware = await this.getMiddleware();\n      if (!middleware) {\n        return handleFinished();\n      }\n      const initUrl = (0, _requestmeta.getRequestMeta)(req, 'initURL');\n      const parsedUrl = (0, _parseurl.parseUrl)(initUrl);\n      const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedUrl.pathname, {\n        nextConfig: this.nextConfig,\n        i18nProvider: this.i18nProvider\n      });\n      parsedUrl.pathname = pathnameInfo.pathname;\n      const normalizedPathname = (0, _removetrailingslash.removeTrailingSlash)(parsed.pathname || '');\n      if (!middleware.match(normalizedPathname, req, parsedUrl.query)) {\n        return handleFinished();\n      }\n      let result;\n      let bubblingResult = false;\n      try {\n        await this.ensureMiddleware(req.url);\n        result = await this.runMiddleware({\n          request: req,\n          response: res,\n          parsedUrl: parsedUrl,\n          parsed: parsed\n        });\n        if ('response' in result) {\n          if (isMiddlewareInvoke) {\n            bubblingResult = true;\n            throw Object.defineProperty(new _tracer.BubbledError(true, result), \"__NEXT_ERROR_CODE\", {\n              value: \"E394\",\n              enumerable: false,\n              configurable: true\n            });\n          }\n          for (const [key, value] of Object.entries((0, _utils1.toNodeOutgoingHttpHeaders)(result.response.headers))) {\n            if (key !== 'content-encoding' && value !== undefined) {\n              res.setHeader(key, value);\n            }\n          }\n          res.statusCode = result.response.status;\n          const {\n            originalResponse\n          } = res;\n          if (result.response.body) {\n            await (0, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);\n          } else {\n            originalResponse.end();\n          }\n          return true;\n        }\n      } catch (err) {\n        if (bubblingResult) {\n          throw err;\n        }\n        if ((0, _iserror.default)(err) && err.code === 'ENOENT') {\n          await this.render404(req, res, parsed);\n          return true;\n        }\n        if (err instanceof _utils.DecodeError) {\n          res.statusCode = 400;\n          await this.renderError(err, req, res, parsed.pathname || '');\n          return true;\n        }\n        const error = (0, _iserror.getProperError)(err);\n        console.error(error);\n        res.statusCode = 500;\n        await this.renderError(error, req, res, parsed.pathname || '');\n        return true;\n      }\n      return result.finished;\n    };\n    this.isDev = options.dev ?? false;\n    this.sriEnabled = Boolean((_options_conf_experimental = options.conf.experimental) == null ? void 0 : (_options_conf_experimental_sri = _options_conf_experimental.sri) == null ? void 0 : _options_conf_experimental_sri.algorithm);\n    /**\n    * This sets environment variable to be used at the time of SSR by head.tsx.\n    * Using this from process.env allows targeting SSR by calling\n    * `process.env.__NEXT_OPTIMIZE_CSS`.\n    */\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);\n    }\n    if (this.renderOpts.nextScriptWorkers) {\n      process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(true);\n    }\n    process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || '';\n    if (!this.minimalMode) {\n      this.imageResponseCache = new _responsecache.default(this.minimalMode);\n    }\n    const {\n      appDocumentPreloading\n    } = this.nextConfig.experimental;\n    const isDefaultEnabled = typeof appDocumentPreloading === 'undefined';\n    if (!options.dev && (appDocumentPreloading === true || !(this.minimalMode && isDefaultEnabled))) {\n      // pre-warm _document and _app as these will be\n      // needed for most requests\n      (0, _loadcomponents.loadComponents)({\n        distDir: this.distDir,\n        page: '/_document',\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled\n      }).catch(() => {});\n      (0, _loadcomponents.loadComponents)({\n        distDir: this.distDir,\n        page: '/_app',\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled\n      }).catch(() => {});\n    }\n    if (!options.dev && !this.minimalMode && this.nextConfig.experimental.preloadEntriesOnStart) {\n      this.unstable_preloadEntries();\n    }\n    if (!options.dev) {\n      const {\n        dynamicRoutes = []\n      } = this.getRoutesManifest() ?? {};\n      this.dynamicRoutes = dynamicRoutes.map(r => {\n        // TODO: can we just re-use the regex from the manifest?\n        const regex = (0, _routeregex.getRouteRegex)(r.page);\n        const match = (0, _routematcher.getRouteMatcher)(regex);\n        return {\n          match,\n          page: r.page,\n          re: regex.re\n        };\n      });\n    }\n    // ensure options are set when loadConfig isn't called\n    (0, _setuphttpagentenv.setHttpClientAndAgentOptions)(this.nextConfig);\n    // Intercept fetch and other testmode apis.\n    if (this.serverOptions.experimentalTestProxy) {\n      process.env.NEXT_PRIVATE_TEST_PROXY = 'true';\n      const {\n        interceptTestApis\n      } = require('next/dist/experimental/testmode/server');\n      interceptTestApis();\n    }\n    this.middlewareManifestPath = (0, _path.join)(this.serverDistDir, _constants.MIDDLEWARE_MANIFEST);\n    // This is just optimization to fire prepare as soon as possible. It will be\n    // properly awaited later. We add the catch here to ensure that it does not\n    // cause a unhandled promise rejection. The promise rejection will be\n    // handled later on via the `await` when the request handler is called.\n    if (!options.dev) {\n      this.prepare().catch(err => {\n        console.error('Failed to prepare server', err);\n      });\n    }\n  }\n  async unstable_preloadEntries() {\n    const appPathsManifest = this.getAppPathsManifest();\n    const pagesManifest = this.getPagesManifest();\n    await this.loadCustomCacheHandlers();\n    for (const page of Object.keys(pagesManifest || {})) {\n      await (0, _loadcomponents.loadComponents)({\n        distDir: this.distDir,\n        page,\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled\n      }).catch(() => {});\n    }\n    for (const page of Object.keys(appPathsManifest || {})) {\n      await (0, _loadcomponents.loadComponents)({\n        distDir: this.distDir,\n        page,\n        isAppPath: true,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled\n      }).then(async _ref2 => {\n        let {\n          ComponentMod\n        } = _ref2;\n        // we need to ensure fetch is patched before we require the page,\n        // otherwise if the fetch is patched by user code, we will be patching it\n        // too late and there won't be any caching behaviors\n        ComponentMod.patchFetch();\n        const webpackRequire = ComponentMod.__next_app__.require;\n        if (webpackRequire == null ? void 0 : webpackRequire.m) {\n          for (const id of Object.keys(webpackRequire.m)) {\n            await webpackRequire(id);\n          }\n        }\n      }).catch(() => {});\n    }\n  }\n  async handleUpgrade() {\n    // The web server does not support web sockets, it's only used for HMR in\n    // development.\n  }\n  async loadInstrumentationModule() {\n    if (!this.serverOptions.dev) {\n      try {\n        this.instrumentation = await dynamicRequire((0, _path.resolve)(this.serverOptions.dir || '.', this.serverOptions.conf.distDir, 'server', _constants1.INSTRUMENTATION_HOOK_FILENAME));\n      } catch (err) {\n        if (err.code !== 'MODULE_NOT_FOUND') {\n          throw Object.defineProperty(new Error('An error occurred while loading the instrumentation hook', {\n            cause: err\n          }), \"__NEXT_ERROR_CODE\", {\n            value: \"E92\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n    }\n    return this.instrumentation;\n  }\n  async prepareImpl() {\n    await super.prepareImpl();\n    await this.runInstrumentationHookIfAvailable();\n  }\n  async runInstrumentationHookIfAvailable() {\n    var _this_instrumentation_register, _this_instrumentation;\n    if (this.registeredInstrumentation) return;\n    this.registeredInstrumentation = true;\n    await ((_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation));\n  }\n  loadEnvConfig(_ref3) {\n    let {\n      dev,\n      forceReload,\n      silent\n    } = _ref3;\n    (0, _env.loadEnvConfig)(this.dir, dev, silent ? {\n      info: () => {},\n      error: () => {}\n    } : _log, forceReload);\n  }\n  async loadCustomCacheHandlers() {\n    const {\n      cacheHandlers\n    } = this.nextConfig.experimental;\n    if (!cacheHandlers) return;\n    // If we've already initialized the cache handlers interface, don't do it\n    // again.\n    if (!(0, _handlers.initializeCacheHandlers)()) return;\n    for (const [kind, handler] of Object.entries(cacheHandlers)) {\n      if (!handler) continue;\n      (0, _handlers.setCacheHandler)(kind, (0, _interopdefault.interopDefault)(await dynamicImportEsmDefault((0, _formatdynamicimportpath.formatDynamicImportPath)(this.distDir, handler))));\n    }\n  }\n  async getIncrementalCache(_ref4) {\n    let {\n      requestHeaders,\n      requestProtocol\n    } = _ref4;\n    const dev = !!this.renderOpts.dev;\n    let CacheHandler;\n    const {\n      cacheHandler\n    } = this.nextConfig;\n    if (cacheHandler) {\n      CacheHandler = (0, _interopdefault.interopDefault)(await dynamicImportEsmDefault((0, _formatdynamicimportpath.formatDynamicImportPath)(this.distDir, cacheHandler)));\n    }\n    await this.loadCustomCacheHandlers();\n    // incremental-cache is request specific\n    // although can have shared caches in module scope\n    // per-cache handler\n    return new _incrementalcache.IncrementalCache({\n      fs: this.getCacheFilesystem(),\n      dev,\n      requestHeaders,\n      requestProtocol,\n      allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      minimalMode: this.minimalMode,\n      serverDistDir: this.serverDistDir,\n      fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n      maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n      flushToDisk: !this.minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n      getPrerenderManifest: () => this.getPrerenderManifest(),\n      CurCacheHandler: CacheHandler\n    });\n  }\n  getResponseCache() {\n    return new _responsecache.default(this.minimalMode);\n  }\n  getPublicDir() {\n    return (0, _path.join)(this.dir, _constants.CLIENT_PUBLIC_FILES_PATH);\n  }\n  getHasStaticDir() {\n    return _fs.default.existsSync((0, _path.join)(this.dir, 'static'));\n  }\n  getPagesManifest() {\n    return (0, _loadmanifest.loadManifest)((0, _path.join)(this.serverDistDir, _constants.PAGES_MANIFEST));\n  }\n  getAppPathsManifest() {\n    if (!this.enabledDirectories.app) return undefined;\n    return (0, _loadmanifest.loadManifest)((0, _path.join)(this.serverDistDir, _constants.APP_PATHS_MANIFEST));\n  }\n  getinterceptionRoutePatterns() {\n    if (!this.enabledDirectories.app) return [];\n    const routesManifest = this.getRoutesManifest();\n    return (routesManifest == null ? void 0 : routesManifest.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite).map(rewrite => new RegExp(rewrite.regex))) ?? [];\n  }\n  async hasPage(pathname) {\n    var _this_nextConfig_i18n;\n    return !!(0, _require.getMaybePagePath)(pathname, this.distDir, (_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.locales, this.enabledDirectories.app);\n  }\n  getBuildId() {\n    const buildIdFile = (0, _path.join)(this.distDir, _constants.BUILD_ID_FILE);\n    try {\n      return _fs.default.readFileSync(buildIdFile, 'utf8').trim();\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        throw Object.defineProperty(new Error(`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`), \"__NEXT_ERROR_CODE\", {\n          value: \"E427\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n      throw err;\n    }\n  }\n  getEnabledDirectories(dev) {\n    const dir = dev ? this.dir : this.serverDistDir;\n    return {\n      app: (0, _findpagesdir.findDir)(dir, 'app') ? true : false,\n      pages: (0, _findpagesdir.findDir)(dir, 'pages') ? true : false\n    };\n  }\n  sendRenderResult(req, res, options) {\n    return (0, _sendpayload.sendRenderResult)({\n      req: req.originalRequest,\n      res: res.originalResponse,\n      result: options.result,\n      type: options.type,\n      generateEtags: options.generateEtags,\n      poweredByHeader: options.poweredByHeader,\n      cacheControl: options.cacheControl\n    });\n  }\n  async runApi(req, res, query, match) {\n    const edgeFunctionsPages = this.getEdgeFunctionsPages();\n    for (const edgeFunctionsPage of edgeFunctionsPages) {\n      if (edgeFunctionsPage === match.definition.pathname) {\n        const handledAsEdgeFunction = await this.runEdgeFunction({\n          req,\n          res,\n          query,\n          params: match.params,\n          page: match.definition.pathname,\n          appPaths: null\n        });\n        if (handledAsEdgeFunction) {\n          return true;\n        }\n      }\n    }\n    // The module supports minimal mode, load the minimal module.\n    const module = await _routemoduleloader.RouteModuleLoader.load(match.definition.filename);\n    query = {\n      ...query,\n      ...match.params\n    };\n    await module.render(req.originalRequest, res.originalResponse, {\n      previewProps: this.renderOpts.previewProps,\n      revalidate: this.revalidate.bind(this),\n      trustHostHeader: this.nextConfig.experimental.trustHostHeader,\n      allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      hostname: this.fetchHostname,\n      minimalMode: this.minimalMode,\n      dev: this.renderOpts.dev === true,\n      query,\n      params: match.params,\n      page: match.definition.pathname,\n      onError: this.instrumentationOnRequestError.bind(this),\n      multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode\n    });\n    return true;\n  }\n  async renderHTML(req, res, pathname, query, renderOpts) {\n    return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.renderHTML, async () => this.renderHTMLImpl(req, res, pathname, query, renderOpts));\n  }\n  async renderHTMLImpl(req, res, pathname, query, renderOpts) {\n    if (process.env.NEXT_MINIMAL) {\n      throw Object.defineProperty(new Error('Invariant: renderHTML should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n        value: \"E472\",\n        enumerable: false,\n        configurable: true\n      });\n      // the `else` branch is needed for tree-shaking\n    } else {\n      // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n      // object here but only updating its `nextFontManifest` field.\n      // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n      renderOpts.nextFontManifest = this.nextFontManifest;\n      if (this.enabledDirectories.app && renderOpts.isAppPath) {\n        return (0, _modulerender.lazyRenderAppPage)(req, res, pathname, query,\n        // This code path does not service revalidations for unknown param\n        // shells. As a result, we don't need to pass in the unknown params.\n        null, renderOpts, this.getServerComponentsHmrCache(), false, {\n          buildId: this.buildId\n        });\n      }\n      // TODO: re-enable this once we've refactored to use implicit matches\n      // throw new Error('Invariant: render should have used routeModule')\n      return (0, _modulerender1.lazyRenderPagesPage)(req.originalRequest, res.originalResponse, pathname, query, renderOpts, {\n        buildId: this.buildId,\n        deploymentId: this.nextConfig.deploymentId,\n        customServer: this.serverOptions.customServer || undefined\n      }, {\n        isFallback: false,\n        isDraftMode: renderOpts.isDraftMode,\n        developmentNotFoundSourcePage: (0, _requestmeta.getRequestMeta)(req, 'developmentNotFoundSourcePage')\n      });\n    }\n  }\n  async imageOptimizer(req, res, paramsResult, previousCacheEntry) {\n    if (process.env.NEXT_MINIMAL) {\n      throw Object.defineProperty(new Error('invariant: imageOptimizer should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n        value: \"E506\",\n        enumerable: false,\n        configurable: true\n      });\n    } else {\n      const {\n        imageOptimizer,\n        fetchExternalImage,\n        fetchInternalImage\n      } = require('./image-optimizer');\n      const handleInternalReq = async (newReq, newRes) => {\n        if (newReq.url === req.url) {\n          throw Object.defineProperty(new Error(`Invariant attempted to optimize _next/image itself`), \"__NEXT_ERROR_CODE\", {\n            value: \"E496\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n        if (!this.routerServerHandler) {\n          throw Object.defineProperty(new Error(`Invariant missing routerServerHandler`), \"__NEXT_ERROR_CODE\", {\n            value: \"E317\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n        await this.routerServerHandler(newReq, newRes);\n        return;\n      };\n      const {\n        isAbsolute,\n        href\n      } = paramsResult;\n      const imageUpstream = isAbsolute ? await fetchExternalImage(href) : await fetchInternalImage(href, req.originalRequest, res.originalResponse, handleInternalReq);\n      return imageOptimizer(imageUpstream, paramsResult, this.nextConfig, {\n        isDev: this.renderOpts.dev,\n        previousCacheEntry\n      });\n    }\n  }\n  getPagePath(pathname, locales) {\n    return (0, _require.getPagePath)(pathname, this.distDir, locales, this.enabledDirectories.app);\n  }\n  async renderPageComponent(ctx, bubbleNoFallback) {\n    const edgeFunctionsPages = this.getEdgeFunctionsPages() || [];\n    if (edgeFunctionsPages.length) {\n      const appPaths = this.getOriginalAppPaths(ctx.pathname);\n      const isAppPath = Array.isArray(appPaths);\n      let page = ctx.pathname;\n      if (isAppPath) {\n        // When it's an array, we need to pass all parallel routes to the loader.\n        page = appPaths[0];\n      }\n      for (const edgeFunctionsPage of edgeFunctionsPages) {\n        if (edgeFunctionsPage === page) {\n          await this.runEdgeFunction({\n            req: ctx.req,\n            res: ctx.res,\n            query: ctx.query,\n            params: ctx.renderOpts.params,\n            page,\n            appPaths\n          });\n          return null;\n        }\n      }\n    }\n    return super.renderPageComponent(ctx, bubbleNoFallback);\n  }\n  async findPageComponents(_ref5) {\n    let {\n      locale,\n      page,\n      query,\n      params,\n      isAppPath,\n      url\n    } = _ref5;\n    return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.findPageComponents, {\n      spanName: 'resolve page components',\n      attributes: {\n        'next.route': isAppPath ? (0, _apppaths.normalizeAppPath)(page) : page\n      }\n    }, () => this.findPageComponentsImpl({\n      locale,\n      page,\n      query,\n      params,\n      isAppPath,\n      url\n    }));\n  }\n  async findPageComponentsImpl(_ref6) {\n    let {\n      locale,\n      page,\n      query,\n      params,\n      isAppPath,\n      url: _url\n    } = _ref6;\n    const pagePaths = [page];\n    if (query.amp) {\n      // try serving a static AMP version first\n      pagePaths.unshift((isAppPath ? (0, _apppaths.normalizeAppPath)(page) : (0, _normalizepagepath.normalizePagePath)(page)) + '.amp');\n    }\n    if (locale) {\n      pagePaths.unshift(...pagePaths.map(path => `/${locale}${path === '/' ? '' : path}`));\n    }\n    for (const pagePath of pagePaths) {\n      try {\n        const components = await (0, _loadcomponents.loadComponents)({\n          distDir: this.distDir,\n          page: pagePath,\n          isAppPath,\n          isDev: this.isDev,\n          sriEnabled: this.sriEnabled\n        });\n        if (locale && typeof components.Component === 'string' && !pagePath.startsWith(`/${locale}/`) && pagePath !== `/${locale}`) {\n          continue;\n        }\n        return {\n          components,\n          query: {\n            ...(!this.renderOpts.isExperimentalCompile && components.getStaticProps ? {\n              amp: query.amp\n            } : query),\n            // For appDir params is excluded.\n            ...((isAppPath ? {} : params) || {})\n          }\n        };\n      } catch (err) {\n        // we should only not throw if we failed to find the page\n        // in the pages-manifest\n        if (!(err instanceof _utils.PageNotFoundError)) {\n          throw err;\n        }\n      }\n    }\n    return null;\n  }\n  getNextFontManifest() {\n    return (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, 'server', _constants.NEXT_FONT_MANIFEST + '.json'));\n  }\n  // Used in development only, overloaded in next-dev-server\n  logErrorWithOriginalStack(_err, _type) {\n    throw Object.defineProperty(new Error('Invariant: logErrorWithOriginalStack can only be called on the development server'), \"__NEXT_ERROR_CODE\", {\n      value: \"E6\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  // Used in development only, overloaded in next-dev-server\n  async ensurePage(_opts) {\n    throw Object.defineProperty(new Error('Invariant: ensurePage can only be called on the development server'), \"__NEXT_ERROR_CODE\", {\n      value: \"E291\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n  * Resolves `API` request, in development builds on demand\n  * @param req http request\n  * @param res http response\n  * @param pathname path of request\n  */\n  async handleApiRequest(req, res, query, match) {\n    return this.runApi(req, res, query, match);\n  }\n  getCacheFilesystem() {\n    return _nodefsmethods.nodeFs;\n  }\n  normalizeReq(req) {\n    return !(req instanceof _node.NodeNextRequest) ? new _node.NodeNextRequest(req) : req;\n  }\n  normalizeRes(res) {\n    return !(res instanceof _node.NodeNextResponse) ? new _node.NodeNextResponse(res) : res;\n  }\n  getRequestHandler() {\n    const handler = this.makeRequestHandler();\n    if (this.serverOptions.experimentalTestProxy) {\n      const {\n        wrapRequestHandlerNode\n      } = require('next/dist/experimental/testmode/server');\n      return wrapRequestHandlerNode(handler);\n    }\n    return handler;\n  }\n  makeRequestHandler() {\n    // This is just optimization to fire prepare as soon as possible. It will be\n    // properly awaited later. We add the catch here to ensure that it does not\n    // cause an unhandled promise rejection. The promise rejection will be\n    // handled later on via the `await` when the request handler is called.\n    this.prepare().catch(err => {\n      console.error('Failed to prepare server', err);\n    });\n    const handler = super.getRequestHandler();\n    return (req, res, parsedUrl) => handler(this.normalizeReq(req), this.normalizeRes(res), parsedUrl);\n  }\n  async revalidate(_ref7) {\n    let {\n      urlPath,\n      revalidateHeaders,\n      opts\n    } = _ref7;\n    const mocked = (0, _mockrequest.createRequestResponseMocks)({\n      url: urlPath,\n      headers: revalidateHeaders\n    });\n    const handler = this.getRequestHandler();\n    await handler(new _node.NodeNextRequest(mocked.req), new _node.NodeNextResponse(mocked.res));\n    await mocked.res.hasStreamed;\n    if (mocked.res.getHeader('x-nextjs-cache') !== 'REVALIDATED' && mocked.res.statusCode !== 200 && !(mocked.res.statusCode === 404 && opts.unstable_onlyGenerated)) {\n      throw Object.defineProperty(new Error(`Invalid response ${mocked.res.statusCode}`), \"__NEXT_ERROR_CODE\", {\n        value: \"E175\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n  }\n  async render(req, res, pathname, query, parsedUrl) {\n    let internal = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return super.render(this.normalizeReq(req), this.normalizeRes(res), pathname, query, parsedUrl, internal);\n  }\n  async renderToHTML(req, res, pathname, query) {\n    return super.renderToHTML(this.normalizeReq(req), this.normalizeRes(res), pathname, query);\n  }\n  async renderErrorToResponseImpl(ctx, err) {\n    const {\n      req,\n      res,\n      query\n    } = ctx;\n    const is404 = res.statusCode === 404;\n    if (is404 && this.enabledDirectories.app) {\n      if (this.renderOpts.dev) {\n        await this.ensurePage({\n          page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n          clientOnly: false,\n          url: req.url\n        }).catch(() => {});\n      }\n      if (this.getEdgeFunctionsPages().includes(_constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)) {\n        await this.runEdgeFunction({\n          req,\n          res,\n          query: query || {},\n          params: {},\n          page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n          appPaths: null\n        });\n        return null;\n      }\n    }\n    return super.renderErrorToResponseImpl(ctx, err);\n  }\n  async renderError(err, req, res, pathname, query, setHeaders) {\n    return super.renderError(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query, setHeaders);\n  }\n  async renderErrorToHTML(err, req, res, pathname, query) {\n    return super.renderErrorToHTML(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query);\n  }\n  async render404(req, res, parsedUrl, setHeaders) {\n    return super.render404(this.normalizeReq(req), this.normalizeRes(res), parsedUrl, setHeaders);\n  }\n  getMiddlewareManifest() {\n    if (this.minimalMode) {\n      return null;\n    } else {\n      const manifest = require(this.middlewareManifestPath);\n      return manifest;\n    }\n  }\n  /** Returns the middleware routing item if there is one. */\n  async getMiddleware() {\n    var _manifest_middleware;\n    const manifest = this.getMiddlewareManifest();\n    const middleware = manifest == null ? void 0 : (_manifest_middleware = manifest.middleware) == null ? void 0 : _manifest_middleware['/'];\n    if (!middleware) {\n      const middlewareModule = await this.loadNodeMiddleware();\n      if (middlewareModule) {\n        var _middlewareModule_config;\n        return {\n          match: (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(((_middlewareModule_config = middlewareModule.config) == null ? void 0 : _middlewareModule_config.matchers) || [{\n            regexp: '.*',\n            originalSource: '/:path*'\n          }]),\n          page: '/'\n        };\n      }\n      return;\n    }\n    return {\n      match: getMiddlewareMatcher(middleware),\n      page: '/'\n    };\n  }\n  getEdgeFunctionsPages() {\n    const manifest = this.getMiddlewareManifest();\n    if (!manifest) {\n      return [];\n    }\n    return Object.keys(manifest.functions);\n  }\n  /**\n  * Get information for the edge function located in the provided page\n  * folder. If the edge function info can't be found it will throw\n  * an error.\n  */\n  getEdgeFunctionInfo(params) {\n    const manifest = this.getMiddlewareManifest();\n    if (!manifest) {\n      return null;\n    }\n    let foundPage;\n    try {\n      foundPage = (0, _denormalizepagepath.denormalizePagePath)((0, _normalizepagepath.normalizePagePath)(params.page));\n    } catch (err) {\n      return null;\n    }\n    let pageInfo = params.middleware ? manifest.middleware[foundPage] : manifest.functions[foundPage];\n    if (!pageInfo) {\n      if (!params.middleware) {\n        throw new _utils.PageNotFoundError(foundPage);\n      }\n      return null;\n    }\n    return {\n      name: pageInfo.name,\n      paths: pageInfo.files.map(file => (0, _path.join)(this.distDir, file)),\n      wasm: (pageInfo.wasm ?? []).map(binding => ({\n        ...binding,\n        filePath: (0, _path.join)(this.distDir, binding.filePath)\n      })),\n      assets: pageInfo.assets && pageInfo.assets.map(binding => {\n        return {\n          ...binding,\n          filePath: (0, _path.join)(this.distDir, binding.filePath)\n        };\n      }),\n      env: pageInfo.env\n    };\n  }\n  async loadNodeMiddleware() {\n    if (!this.nextConfig.experimental.nodeMiddleware) {\n      return;\n    }\n    try {\n      var _functionsConfig_functions;\n      const functionsConfig = this.renderOpts.dev ? {} : require((0, _path.join)(this.distDir, 'server', _constants.FUNCTIONS_CONFIG_MANIFEST));\n      if (this.renderOpts.dev || (functionsConfig == null ? void 0 : (_functionsConfig_functions = functionsConfig.functions) == null ? void 0 : _functionsConfig_functions['/_middleware'])) {\n        // if used with top level await, this will be a promise\n        return require((0, _path.join)(this.distDir, 'server', 'middleware.js'));\n      }\n    } catch (err) {\n      if ((0, _iserror.default)(err) && err.code !== 'ENOENT' && err.code !== 'MODULE_NOT_FOUND') {\n        throw err;\n      }\n    }\n  }\n  /**\n  * Checks if a middleware exists. This method is useful for the development\n  * server where we need to check the filesystem. Here we just check the\n  * middleware manifest.\n  */\n  async hasMiddleware(pathname) {\n    const info = this.getEdgeFunctionInfo({\n      page: pathname,\n      middleware: true\n    });\n    const nodeMiddleware = await this.loadNodeMiddleware();\n    if (!info && nodeMiddleware) {\n      return true;\n    }\n    return Boolean(info && info.paths.length > 0);\n  }\n  /**\n  * A placeholder for a function to be defined in the development server.\n  * It will make sure that the root middleware or an edge function has been compiled\n  * so that we can run it.\n  */\n  async ensureMiddleware(_url) {}\n  async ensureEdgeFunction(_params) {}\n  /**\n  * This method gets all middleware matchers and execute them when the request\n  * matches. It will make sure that each middleware exists and is compiled and\n  * ready to be invoked. The development server will decorate it to add warns\n  * and errors with rich traces.\n  */\n  async runMiddleware(params) {\n    if (process.env.NEXT_MINIMAL) {\n      throw Object.defineProperty(new Error('invariant: runMiddleware should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n        value: \"E276\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    // Middleware is skipped for on-demand revalidate requests\n    if ((0, _apiutils.checkIsOnDemandRevalidate)(params.request, this.renderOpts.previewProps).isOnDemandRevalidate) {\n      return {\n        response: new Response(null, {\n          headers: {\n            'x-middleware-next': '1'\n          }\n        })\n      };\n    }\n    let url;\n    if (this.nextConfig.skipMiddlewareUrlNormalize) {\n      url = (0, _requestmeta.getRequestMeta)(params.request, 'initURL');\n    } else {\n      // For middleware to \"fetch\" we must always provide an absolute URL\n      const query = (0, _querystring.urlQueryToSearchParams)(params.parsed.query).toString();\n      const locale = (0, _requestmeta.getRequestMeta)(params.request, 'locale');\n      url = `${(0, _requestmeta.getRequestMeta)(params.request, 'initProtocol')}://${this.fetchHostname || 'localhost'}:${this.port}${locale ? `/${locale}` : ''}${params.parsed.pathname}${query ? `?${query}` : ''}`;\n    }\n    if (!url.startsWith('http')) {\n      throw Object.defineProperty(new Error('To use middleware you must provide a `hostname` and `port` to the Next.js Server'), \"__NEXT_ERROR_CODE\", {\n        value: \"E35\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    const page = {};\n    const middleware = await this.getMiddleware();\n    if (!middleware) {\n      return {\n        finished: false\n      };\n    }\n    if (!(await this.hasMiddleware(middleware.page))) {\n      return {\n        finished: false\n      };\n    }\n    await this.ensureMiddleware(params.request.url);\n    const middlewareInfo = this.getEdgeFunctionInfo({\n      page: middleware.page,\n      middleware: true\n    });\n    const method = (params.request.method || 'GET').toUpperCase();\n    const requestData = {\n      headers: params.request.headers,\n      method,\n      nextConfig: {\n        basePath: this.nextConfig.basePath,\n        i18n: this.nextConfig.i18n,\n        trailingSlash: this.nextConfig.trailingSlash,\n        experimental: this.nextConfig.experimental\n      },\n      url: url,\n      page,\n      body: method !== 'GET' && method !== 'HEAD' ? (0, _requestmeta.getRequestMeta)(params.request, 'clonableBody') : undefined,\n      signal: (0, _nextrequest.signalFromNodeResponse)(params.response.originalResponse),\n      waitUntil: this.getWaitUntil()\n    };\n    let result;\n    // if no middleware info check for Node.js middleware\n    // this is not in the middleware-manifest as that historically\n    // has only included edge-functions, we need to do a breaking\n    // version bump for that manifest to write this info there if\n    // we decide we want to\n    if (!middlewareInfo) {\n      let middlewareModule;\n      middlewareModule = await this.loadNodeMiddleware();\n      if (!middlewareModule) {\n        throw new _utils.MiddlewareNotFoundError();\n      }\n      const adapterFn = middlewareModule.default || middlewareModule;\n      result = await adapterFn({\n        handler: middlewareModule.middleware || middlewareModule,\n        request: requestData,\n        page: 'middleware'\n      });\n    } else {\n      const {\n        run\n      } = require('./web/sandbox');\n      result = await run({\n        distDir: this.distDir,\n        name: middlewareInfo.name,\n        paths: middlewareInfo.paths,\n        edgeFunctionEntry: middlewareInfo,\n        request: requestData,\n        useCache: true,\n        onWarning: params.onWarning\n      });\n    }\n    if (!this.renderOpts.dev) {\n      result.waitUntil.catch(error => {\n        console.error(`Uncaught: middleware waitUntil errored`, error);\n      });\n    }\n    if (!result) {\n      this.render404(params.request, params.response, params.parsed);\n      return {\n        finished: true\n      };\n    }\n    // Split compound (comma-separated) set-cookie headers\n    if (result.response.headers.has('set-cookie')) {\n      const cookies = result.response.headers.getSetCookie().flatMap(maybeCompoundCookie => (0, _utils1.splitCookiesString)(maybeCompoundCookie));\n      // Clear existing header(s)\n      result.response.headers.delete('set-cookie');\n      // Append each cookie individually.\n      for (const cookie of cookies) {\n        result.response.headers.append('set-cookie', cookie);\n      }\n      // Add cookies to request meta.\n      (0, _requestmeta.addRequestMeta)(params.request, 'middlewareCookie', cookies);\n    }\n    return result;\n  }\n  getPrerenderManifest() {\n    var _this_renderOpts, _this_serverOptions;\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest;\n    }\n    if (((_this_renderOpts = this.renderOpts) == null ? void 0 : _this_renderOpts.dev) || ((_this_serverOptions = this.serverOptions) == null ? void 0 : _this_serverOptions.dev) || process.env.NODE_ENV === 'development' || process.env.NEXT_PHASE === _constants.PHASE_PRODUCTION_BUILD) {\n      this._cachedPreviewManifest = {\n        version: 4,\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: {\n          previewModeId: require('crypto').randomBytes(16).toString('hex'),\n          previewModeSigningKey: require('crypto').randomBytes(32).toString('hex'),\n          previewModeEncryptionKey: require('crypto').randomBytes(32).toString('hex')\n        }\n      };\n      return this._cachedPreviewManifest;\n    }\n    this._cachedPreviewManifest = (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, _constants.PRERENDER_MANIFEST));\n    return this._cachedPreviewManifest;\n  }\n  getRoutesManifest() {\n    return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.getRoutesManifest, () => {\n      const manifest = (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, _constants.ROUTES_MANIFEST));\n      let rewrites = manifest.rewrites ?? {\n        beforeFiles: [],\n        afterFiles: [],\n        fallback: []\n      };\n      if (Array.isArray(rewrites)) {\n        rewrites = {\n          beforeFiles: [],\n          afterFiles: rewrites,\n          fallback: []\n        };\n      }\n      return {\n        ...manifest,\n        rewrites\n      };\n    });\n  }\n  attachRequestMeta(req, parsedUrl, isUpgradeReq) {\n    var _req_headers_xforwardedproto;\n    // Injected in base-server.ts\n    const protocol = ((_req_headers_xforwardedproto = req.headers['x-forwarded-proto']) == null ? void 0 : _req_headers_xforwardedproto.includes('https')) ? 'https' : 'http';\n    // When there are hostname and port we build an absolute URL\n    const initUrl = this.fetchHostname && this.port ? `${protocol}://${this.fetchHostname}:${this.port}${req.url}` : this.nextConfig.experimental.trustHostHeader ? `https://${req.headers.host || 'localhost'}${req.url}` : req.url;\n    (0, _requestmeta.addRequestMeta)(req, 'initURL', initUrl);\n    (0, _requestmeta.addRequestMeta)(req, 'initQuery', {\n      ...parsedUrl.query\n    });\n    (0, _requestmeta.addRequestMeta)(req, 'initProtocol', protocol);\n    if (!isUpgradeReq) {\n      (0, _requestmeta.addRequestMeta)(req, 'clonableBody', (0, _bodystreams.getCloneableBody)(req.originalRequest));\n    }\n  }\n  async runEdgeFunction(params) {\n    if (process.env.NEXT_MINIMAL) {\n      throw Object.defineProperty(new Error('Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E58\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    let edgeInfo;\n    const {\n      query,\n      page,\n      match\n    } = params;\n    if (!match) await this.ensureEdgeFunction({\n      page,\n      appPaths: params.appPaths,\n      url: params.req.url\n    });\n    edgeInfo = this.getEdgeFunctionInfo({\n      page,\n      middleware: false\n    });\n    if (!edgeInfo) {\n      return null;\n    }\n    // For edge to \"fetch\" we must always provide an absolute URL\n    const isNextDataRequest = (0, _requestmeta.getRequestMeta)(params.req, 'isNextDataReq');\n    const initialUrl = new URL((0, _requestmeta.getRequestMeta)(params.req, 'initURL') || '/', 'http://n');\n    const queryString = (0, _querystring.urlQueryToSearchParams)({\n      ...Object.fromEntries(initialUrl.searchParams),\n      ...query,\n      ...params.params\n    }).toString();\n    if (isNextDataRequest) {\n      params.req.headers['x-nextjs-data'] = '1';\n    }\n    initialUrl.search = queryString;\n    const url = initialUrl.toString();\n    if (!url.startsWith('http')) {\n      throw Object.defineProperty(new Error('To use middleware you must provide a `hostname` and `port` to the Next.js Server'), \"__NEXT_ERROR_CODE\", {\n        value: \"E35\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    const {\n      run\n    } = require('./web/sandbox');\n    const result = await run({\n      distDir: this.distDir,\n      name: edgeInfo.name,\n      paths: edgeInfo.paths,\n      edgeFunctionEntry: edgeInfo,\n      request: {\n        headers: params.req.headers,\n        method: params.req.method,\n        nextConfig: {\n          basePath: this.nextConfig.basePath,\n          i18n: this.nextConfig.i18n,\n          trailingSlash: this.nextConfig.trailingSlash\n        },\n        url,\n        page: {\n          name: params.page,\n          ...(params.params && {\n            params: params.params\n          })\n        },\n        body: (0, _requestmeta.getRequestMeta)(params.req, 'clonableBody'),\n        signal: (0, _nextrequest.signalFromNodeResponse)(params.res.originalResponse),\n        waitUntil: this.getWaitUntil()\n      },\n      useCache: true,\n      onError: params.onError,\n      onWarning: params.onWarning,\n      incrementalCache: globalThis.__incrementalCache || (0, _requestmeta.getRequestMeta)(params.req, 'incrementalCache'),\n      serverComponentsHmrCache: (0, _requestmeta.getRequestMeta)(params.req, 'serverComponentsHmrCache')\n    });\n    if (result.fetchMetrics) {\n      params.req.fetchMetrics = result.fetchMetrics;\n    }\n    if (!params.res.statusCode || params.res.statusCode < 400) {\n      params.res.statusCode = result.response.status;\n      params.res.statusMessage = result.response.statusText;\n    }\n    // TODO: (wyattjoh) investigate improving this\n    result.response.headers.forEach((value, key) => {\n      // The append handling is special cased for `set-cookie`.\n      if (key.toLowerCase() === 'set-cookie') {\n        // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n        for (const cookie of (0, _utils1.splitCookiesString)(value)) {\n          params.res.appendHeader(key, cookie);\n        }\n      } else {\n        params.res.appendHeader(key, value);\n      }\n    });\n    const {\n      originalResponse\n    } = params.res;\n    if (result.response.body) {\n      await (0, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);\n    } else {\n      originalResponse.end();\n    }\n    return result;\n  }\n  get serverDistDir() {\n    if (this._serverDistDir) {\n      return this._serverDistDir;\n    }\n    const serverDistDir = (0, _path.join)(this.distDir, _constants.SERVER_DIRECTORY);\n    this._serverDistDir = serverDistDir;\n    return serverDistDir;\n  }\n  async getFallbackErrorComponents(_url) {\n    // Not implemented for production use cases, this is implemented on the\n    // development server.\n    return null;\n  }\n  async instrumentationOnRequestError() {\n    await super.instrumentationOnRequestError(...arguments);\n    // For Node.js runtime production logs, in dev it will be overridden by next-dev-server\n    if (!this.renderOpts.dev) {\n      this.logError(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  }\n  onServerClose(listener) {\n    this.cleanupListeners.add(listener);\n  }\n  async close() {\n    await this.cleanupListeners.runAll();\n  }\n  getInternalWaitUntil() {\n    this.internalWaitUntil ??= this.createInternalWaitUntil();\n    return this.internalWaitUntil;\n  }\n  createInternalWaitUntil() {\n    if (this.minimalMode) {\n      throw Object.defineProperty(new _invarianterror.InvariantError('createInternalWaitUntil should never be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n        value: \"E540\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    const awaiter = new _awaiter.AwaiterOnce({\n      onError: console.error\n    });\n    // TODO(after): warn if the process exits before these are awaited\n    this.onServerClose(() => awaiter.awaiting());\n    return awaiter.waitUntil;\n  }\n}","map":{"version":3,"names":["NextNodeServer","exports","dynamicImportEsmDefault","process","env","NEXT_MINIMAL","id","then","mod","default","dynamicRequire","__non_webpack_require__","require","MiddlewareMatcherCache","WeakMap","getMiddlewareMatcher","info","stored","get","Array","isArray","matchers","Object","defineProperty","Error","JSON","stringify","matcher","_middlewareroutematcher","getMiddlewareRouteMatcher","set","_baseserver","constructor","options","_options_conf_experimental_sri","_options_conf_experimental","registeredInstrumentation","cleanupListeners","_asynccallbackset","AsyncCallbackSet","handleNextImageRequest","req","res","parsedUrl","pathname","startsWith","_requestmeta","getRequestMeta","minimalMode","nextConfig","output","statusCode","body","send","ImageOptimizerCache","imageOptimizerCache","distDir","sendResponse","ImageError","imageResponseCache","imagesConfig","images","loader","unoptimized","render404","paramsResult","validateParams","originalRequest","query","renderOpts","dev","errorMessage","cacheKey","getCacheKey","_cacheEntry_value","_cacheEntry_cacheControl","getExtension","cacheEntry","_ref","previousCacheEntry","buffer","contentType","maxAge","upstreamEtag","etag","imageOptimizer","value","kind","_responsecache","CachedRouteKind","IMAGE","extension","isFallback","cacheControl","revalidate","expire","undefined","routeKind","_routekind","RouteKind","incrementalCache","originalResponse","href","isStatic","isMiss","isStale","Boolean","err","message","handleCatchallRenderRequest","addRequestMeta","_this_i18nProvider","_removetrailingslash","removeTrailingSlash","i18n","i18nProvider","fromRequest","match","render","edgeFunctionsPages","getEdgeFunctionsPages","edgeFunctionsPage","definition","page","_approuterheaders","NEXT_RSC_UNION_QUERY","handled","runEdgeFunction","params","appPaths","apiError","instrumentationOnRequestError","routePath","routerKind","routeType","revalidateReason","_pagesapiroutematch","isPagesAPIRouteMatch","handleApiRequest","NoFallbackError","formatServerError","logErrorWithOriginalStack","logError","renderError","handleCatchallMiddlewareRequest","parsed","isMiddlewareInvoke","handleFinished","middleware","getMiddleware","initUrl","_parseurl","parseUrl","pathnameInfo","_getnextpathnameinfo","getNextPathnameInfo","normalizedPathname","result","bubblingResult","ensureMiddleware","url","runMiddleware","request","response","_tracer","BubbledError","key","entries","_utils1","toNodeOutgoingHttpHeaders","headers","setHeader","status","_pipereadable","pipeToNodeResponse","end","_iserror","code","_utils","DecodeError","error","getProperError","console","finished","isDev","sriEnabled","conf","experimental","sri","algorithm","optimizeCss","__NEXT_OPTIMIZE_CSS","nextScriptWorkers","__NEXT_SCRIPT_WORKERS","NEXT_DEPLOYMENT_ID","deploymentId","appDocumentPreloading","isDefaultEnabled","_loadcomponents","loadComponents","isAppPath","catch","preloadEntriesOnStart","unstable_preloadEntries","dynamicRoutes","getRoutesManifest","map","r","regex","_routeregex","getRouteRegex","_routematcher","getRouteMatcher","re","_setuphttpagentenv","setHttpClientAndAgentOptions","serverOptions","experimentalTestProxy","NEXT_PRIVATE_TEST_PROXY","interceptTestApis","middlewareManifestPath","_path","join","serverDistDir","_constants","MIDDLEWARE_MANIFEST","prepare","appPathsManifest","getAppPathsManifest","pagesManifest","getPagesManifest","loadCustomCacheHandlers","keys","_ref2","ComponentMod","patchFetch","webpackRequire","__next_app__","m","handleUpgrade","loadInstrumentationModule","instrumentation","resolve","dir","_constants1","INSTRUMENTATION_HOOK_FILENAME","cause","prepareImpl","runInstrumentationHookIfAvailable","_this_instrumentation_register","_this_instrumentation","register","call","loadEnvConfig","_ref3","forceReload","silent","_env","_log","cacheHandlers","_handlers","initializeCacheHandlers","handler","setCacheHandler","_interopdefault","interopDefault","_formatdynamicimportpath","formatDynamicImportPath","getIncrementalCache","_ref4","requestHeaders","requestProtocol","CacheHandler","cacheHandler","_incrementalcache","IncrementalCache","fs","getCacheFilesystem","allowedRevalidateHeaderKeys","fetchCacheKeyPrefix","maxMemoryCacheSize","cacheMaxMemorySize","flushToDisk","isrFlushToDisk","getPrerenderManifest","CurCacheHandler","getResponseCache","getPublicDir","CLIENT_PUBLIC_FILES_PATH","getHasStaticDir","_fs","existsSync","_loadmanifest","loadManifest","PAGES_MANIFEST","enabledDirectories","app","APP_PATHS_MANIFEST","getinterceptionRoutePatterns","routesManifest","rewrites","beforeFiles","filter","_generateinterceptionroutesrewrites","isInterceptionRouteRewrite","rewrite","RegExp","hasPage","_this_nextConfig_i18n","_require","getMaybePagePath","locales","getBuildId","buildIdFile","BUILD_ID_FILE","readFileSync","trim","getEnabledDirectories","_findpagesdir","findDir","pages","sendRenderResult","_sendpayload","type","generateEtags","poweredByHeader","runApi","handledAsEdgeFunction","module","_routemoduleloader","RouteModuleLoader","load","filename","previewProps","bind","trustHostHeader","hostname","fetchHostname","onError","multiZoneDraftMode","renderHTML","getTracer","trace","_constants2","NextNodeServerSpan","renderHTMLImpl","nextFontManifest","_modulerender","lazyRenderAppPage","getServerComponentsHmrCache","buildId","_modulerender1","lazyRenderPagesPage","customServer","isDraftMode","developmentNotFoundSourcePage","fetchExternalImage","fetchInternalImage","handleInternalReq","newReq","newRes","routerServerHandler","isAbsolute","imageUpstream","getPagePath","renderPageComponent","ctx","bubbleNoFallback","length","getOriginalAppPaths","findPageComponents","_ref5","locale","spanName","attributes","_apppaths","normalizeAppPath","findPageComponentsImpl","_ref6","_url","pagePaths","amp","unshift","_normalizepagepath","normalizePagePath","path","pagePath","components","Component","isExperimentalCompile","getStaticProps","PageNotFoundError","getNextFontManifest","NEXT_FONT_MANIFEST","_err","_type","ensurePage","_opts","_nodefsmethods","nodeFs","normalizeReq","_node","NodeNextRequest","normalizeRes","NodeNextResponse","getRequestHandler","makeRequestHandler","wrapRequestHandlerNode","_ref7","urlPath","revalidateHeaders","opts","mocked","_mockrequest","createRequestResponseMocks","hasStreamed","getHeader","unstable_onlyGenerated","internal","arguments","renderToHTML","renderErrorToResponseImpl","is404","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","clientOnly","includes","setHeaders","renderErrorToHTML","getMiddlewareManifest","manifest","_manifest_middleware","middlewareModule","loadNodeMiddleware","_middlewareModule_config","config","regexp","originalSource","functions","getEdgeFunctionInfo","foundPage","_denormalizepagepath","denormalizePagePath","pageInfo","name","paths","files","file","wasm","binding","filePath","assets","nodeMiddleware","_functionsConfig_functions","functionsConfig","FUNCTIONS_CONFIG_MANIFEST","hasMiddleware","ensureEdgeFunction","_params","_apiutils","checkIsOnDemandRevalidate","isOnDemandRevalidate","Response","skipMiddlewareUrlNormalize","_querystring","urlQueryToSearchParams","toString","port","middlewareInfo","method","toUpperCase","requestData","basePath","trailingSlash","signal","_nextrequest","signalFromNodeResponse","waitUntil","getWaitUntil","MiddlewareNotFoundError","adapterFn","run","edgeFunctionEntry","useCache","onWarning","has","cookies","getSetCookie","flatMap","maybeCompoundCookie","splitCookiesString","delete","cookie","append","_this_renderOpts","_this_serverOptions","_cachedPreviewManifest","NODE_ENV","NEXT_PHASE","PHASE_PRODUCTION_BUILD","version","routes","notFoundRoutes","preview","previewModeId","randomBytes","previewModeSigningKey","previewModeEncryptionKey","PRERENDER_MANIFEST","ROUTES_MANIFEST","afterFiles","fallback","attachRequestMeta","isUpgradeReq","_req_headers_xforwardedproto","protocol","host","_bodystreams","getCloneableBody","edgeInfo","isNextDataRequest","initialUrl","URL","queryString","fromEntries","searchParams","search","globalThis","__incrementalCache","serverComponentsHmrCache","fetchMetrics","statusMessage","statusText","forEach","toLowerCase","appendHeader","_serverDistDir","SERVER_DIRECTORY","getFallbackErrorComponents","onServerClose","listener","add","close","runAll","getInternalWaitUntil","internalWaitUntil","createInternalWaitUntil","_invarianterror","InvariantError","awaiter","_awaiter","AwaiterOnce","awaiting"],"sources":["/home/ashish/my-react-app/node_modules/next/src/server/next-server.ts"],"sourcesContent":["import './node-environment'\nimport './require-hook'\nimport './node-polyfill-crypto'\n\nimport type { CacheFs } from '../shared/lib/utils'\nimport {\n  DecodeError,\n  PageNotFoundError,\n  MiddlewareNotFoundError,\n} from '../shared/lib/utils'\nimport type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin'\nimport type RenderResult from './render-result'\nimport type { FetchEventResult } from './web/types'\nimport type { PrerenderManifest } from '../build'\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\nimport type { Params } from './request/params'\nimport type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { PagesAPIRouteModule } from './route-modules/pages-api/module'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { ParsedUrl } from '../shared/lib/router/utils/parse-url'\nimport type { CacheControl } from './lib/cache-control'\nimport type { WaitUntil } from './after/builtin-request-context'\n\nimport fs from 'fs'\nimport { join, resolve } from 'path'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport { addRequestMeta, getRequestMeta } from './request-meta'\nimport {\n  PAGES_MANIFEST,\n  BUILD_ID_FILE,\n  MIDDLEWARE_MANIFEST,\n  PRERENDER_MANIFEST,\n  ROUTES_MANIFEST,\n  CLIENT_PUBLIC_FILES_PATH,\n  APP_PATHS_MANIFEST,\n  SERVER_DIRECTORY,\n  NEXT_FONT_MANIFEST,\n  PHASE_PRODUCTION_BUILD,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n  FUNCTIONS_CONFIG_MANIFEST,\n} from '../shared/lib/constants'\nimport { findDir } from '../lib/find-pages-dir'\nimport { NodeNextRequest, NodeNextResponse } from './base-http/node'\nimport { sendRenderResult } from './send-payload'\nimport { parseUrl } from '../shared/lib/router/utils/parse-url'\nimport * as Log from '../build/output/log'\n\nimport type {\n  Options,\n  FindComponentsResult,\n  MiddlewareRoutingItem,\n  RequestContext,\n  NormalizedRouteManifest,\n  LoadedRenderOpts,\n  RouteHandler,\n  NextEnabledDirectories,\n  BaseRequestHandler,\n} from './base-server'\nimport BaseServer, { NoFallbackError } from './base-server'\nimport { getMaybePagePath, getPagePath } from './require'\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'\nimport { loadComponents } from './load-components'\nimport type { LoadComponentsReturnType } from './load-components'\nimport isError, { getProperError } from '../lib/is-error'\nimport { splitCookiesString, toNodeOutgoingHttpHeaders } from './web/utils'\nimport { getMiddlewareRouteMatcher } from '../shared/lib/router/utils/middleware-route-matcher'\nimport { loadEnvConfig } from '@next/env'\nimport { urlQueryToSearchParams } from '../shared/lib/router/utils/querystring'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'\nimport { getCloneableBody } from './body-streams'\nimport { checkIsOnDemandRevalidate } from './api-utils'\nimport ResponseCache, {\n  CachedRouteKind,\n  type IncrementalResponseCacheEntry,\n} from './response-cache'\nimport { IncrementalCache } from './lib/incremental-cache'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\n\nimport { setHttpClientAndAgentOptions } from './setup-http-agent-env'\n\nimport { isPagesAPIRouteMatch } from './route-matches/pages-api-route-match'\nimport type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'\nimport type { MatchOptions } from './route-matcher-managers/route-matcher-manager'\nimport { INSTRUMENTATION_HOOK_FILENAME } from '../lib/constants'\nimport { BubbledError, getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { nodeFs } from './lib/node-fs-methods'\nimport { getRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { pipeToNodeResponse } from './pipe-readable'\nimport { createRequestResponseMocks } from './lib/mock-request'\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport { signalFromNodeResponse } from './web/spec-extension/adapters/next-request'\nimport { RouteModuleLoader } from './lib/module-loader/route-module-loader'\nimport { loadManifest } from './load-manifest'\nimport { lazyRenderAppPage } from './route-modules/app-page/module.render'\nimport { lazyRenderPagesPage } from './route-modules/pages/module.render'\nimport { interopDefault } from '../lib/interop-default'\nimport { formatDynamicImportPath } from '../lib/format-dynamic-import-path'\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'\nimport { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'\nimport type { ServerOnInstrumentationRequestError } from './app-render/types'\nimport { RouteKind } from './route-kind'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport { AwaiterOnce } from './after/awaiter'\nimport { AsyncCallbackSet } from './lib/async-callback-set'\nimport { initializeCacheHandlers, setCacheHandler } from './use-cache/handlers'\nimport type { UnwrapPromise } from '../lib/coalesced-function'\n\nexport * from './base-server'\n\ndeclare const __non_webpack_require__: NodeRequire\n\n// For module that can be both CJS or ESM\nconst dynamicImportEsmDefault = process.env.NEXT_MINIMAL\n  ? (id: string) =>\n      import(/* webpackIgnore: true */ id).then((mod) => mod.default || mod)\n  : (id: string) => import(id).then((mod) => mod.default || mod)\n\n// For module that will be compiled to CJS, e.g. instrument\nconst dynamicRequire = process.env.NEXT_MINIMAL\n  ? __non_webpack_require__\n  : require\n\nexport type NodeRequestHandler = BaseRequestHandler<\n  IncomingMessage | NodeNextRequest,\n  ServerResponse | NodeNextResponse\n>\n\ntype NodeRouteHandler = RouteHandler<NodeNextRequest, NodeNextResponse>\n\nconst MiddlewareMatcherCache = new WeakMap<\n  MiddlewareManifest['middleware'][string],\n  MiddlewareRouteMatch\n>()\n\nfunction getMiddlewareMatcher(\n  info: MiddlewareManifest['middleware'][string]\n): MiddlewareRouteMatch {\n  const stored = MiddlewareMatcherCache.get(info)\n  if (stored) {\n    return stored\n  }\n\n  if (!Array.isArray(info.matchers)) {\n    throw new Error(\n      `Invariant: invalid matchers for middleware ${JSON.stringify(info)}`\n    )\n  }\n\n  const matcher = getMiddlewareRouteMatcher(info.matchers)\n  MiddlewareMatcherCache.set(info, matcher)\n  return matcher\n}\n\nexport default class NextNodeServer extends BaseServer<\n  Options,\n  NodeNextRequest,\n  NodeNextResponse\n> {\n  protected middlewareManifestPath: string\n  private _serverDistDir: string | undefined\n  private imageResponseCache?: ResponseCache\n  private registeredInstrumentation: boolean = false\n  protected renderWorkersPromises?: Promise<void>\n  protected dynamicRoutes?: {\n    match: import('../shared/lib/router/utils/route-matcher').RouteMatchFn\n    page: string\n    re: RegExp\n  }[]\n  private routerServerHandler?: (\n    req: IncomingMessage,\n    res: ServerResponse\n  ) => void\n\n  protected cleanupListeners = new AsyncCallbackSet()\n  protected internalWaitUntil: WaitUntil | undefined\n  private isDev: boolean\n  private sriEnabled: boolean\n\n  constructor(options: Options) {\n    // Initialize super class\n    super(options)\n\n    this.isDev = options.dev ?? false\n    this.sriEnabled = Boolean(options.conf.experimental?.sri?.algorithm)\n\n    /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_CSS`.\n     */\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)\n    }\n    if (this.renderOpts.nextScriptWorkers) {\n      process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(true)\n    }\n    process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''\n\n    if (!this.minimalMode) {\n      this.imageResponseCache = new ResponseCache(this.minimalMode)\n    }\n\n    const { appDocumentPreloading } = this.nextConfig.experimental\n    const isDefaultEnabled = typeof appDocumentPreloading === 'undefined'\n\n    if (\n      !options.dev &&\n      (appDocumentPreloading === true ||\n        !(this.minimalMode && isDefaultEnabled))\n    ) {\n      // pre-warm _document and _app as these will be\n      // needed for most requests\n      loadComponents({\n        distDir: this.distDir,\n        page: '/_document',\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled,\n      }).catch(() => {})\n      loadComponents({\n        distDir: this.distDir,\n        page: '/_app',\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled,\n      }).catch(() => {})\n    }\n\n    if (\n      !options.dev &&\n      !this.minimalMode &&\n      this.nextConfig.experimental.preloadEntriesOnStart\n    ) {\n      this.unstable_preloadEntries()\n    }\n\n    if (!options.dev) {\n      const { dynamicRoutes = [] } = this.getRoutesManifest() ?? {}\n      this.dynamicRoutes = dynamicRoutes.map((r) => {\n        // TODO: can we just re-use the regex from the manifest?\n        const regex = getRouteRegex(r.page)\n        const match = getRouteMatcher(regex)\n\n        return {\n          match,\n          page: r.page,\n          re: regex.re,\n        }\n      })\n    }\n\n    // ensure options are set when loadConfig isn't called\n    setHttpClientAndAgentOptions(this.nextConfig)\n\n    // Intercept fetch and other testmode apis.\n    if (this.serverOptions.experimentalTestProxy) {\n      process.env.NEXT_PRIVATE_TEST_PROXY = 'true'\n      const {\n        interceptTestApis,\n      } = require('next/dist/experimental/testmode/server')\n      interceptTestApis()\n    }\n\n    this.middlewareManifestPath = join(this.serverDistDir, MIDDLEWARE_MANIFEST)\n\n    // This is just optimization to fire prepare as soon as possible. It will be\n    // properly awaited later. We add the catch here to ensure that it does not\n    // cause a unhandled promise rejection. The promise rejection will be\n    // handled later on via the `await` when the request handler is called.\n    if (!options.dev) {\n      this.prepare().catch((err) => {\n        console.error('Failed to prepare server', err)\n      })\n    }\n  }\n\n  public async unstable_preloadEntries(): Promise<void> {\n    const appPathsManifest = this.getAppPathsManifest()\n    const pagesManifest = this.getPagesManifest()\n\n    await this.loadCustomCacheHandlers()\n\n    for (const page of Object.keys(pagesManifest || {})) {\n      await loadComponents({\n        distDir: this.distDir,\n        page,\n        isAppPath: false,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled,\n      }).catch(() => {})\n    }\n\n    for (const page of Object.keys(appPathsManifest || {})) {\n      await loadComponents({\n        distDir: this.distDir,\n        page,\n        isAppPath: true,\n        isDev: this.isDev,\n        sriEnabled: this.sriEnabled,\n      })\n        .then(async ({ ComponentMod }) => {\n          // we need to ensure fetch is patched before we require the page,\n          // otherwise if the fetch is patched by user code, we will be patching it\n          // too late and there won't be any caching behaviors\n          ComponentMod.patchFetch()\n\n          const webpackRequire = ComponentMod.__next_app__.require\n          if (webpackRequire?.m) {\n            for (const id of Object.keys(webpackRequire.m)) {\n              await webpackRequire(id)\n            }\n          }\n        })\n        .catch(() => {})\n    }\n  }\n\n  protected async handleUpgrade(): Promise<void> {\n    // The web server does not support web sockets, it's only used for HMR in\n    // development.\n  }\n\n  protected async loadInstrumentationModule() {\n    if (!this.serverOptions.dev) {\n      try {\n        this.instrumentation = await dynamicRequire(\n          resolve(\n            this.serverOptions.dir || '.',\n            this.serverOptions.conf.distDir!,\n            'server',\n            INSTRUMENTATION_HOOK_FILENAME\n          )\n        )\n      } catch (err: any) {\n        if (err.code !== 'MODULE_NOT_FOUND') {\n          throw new Error(\n            'An error occurred while loading the instrumentation hook',\n            { cause: err }\n          )\n        }\n      }\n    }\n    return this.instrumentation\n  }\n\n  protected async prepareImpl() {\n    await super.prepareImpl()\n    await this.runInstrumentationHookIfAvailable()\n  }\n\n  protected async runInstrumentationHookIfAvailable() {\n    if (this.registeredInstrumentation) return\n    this.registeredInstrumentation = true\n    await this.instrumentation?.register?.()\n  }\n\n  protected loadEnvConfig({\n    dev,\n    forceReload,\n    silent,\n  }: {\n    dev: boolean\n    forceReload?: boolean\n    silent?: boolean\n  }) {\n    loadEnvConfig(\n      this.dir,\n      dev,\n      silent ? { info: () => {}, error: () => {} } : Log,\n      forceReload\n    )\n  }\n\n  private async loadCustomCacheHandlers() {\n    const { cacheHandlers } = this.nextConfig.experimental\n    if (!cacheHandlers) return\n\n    // If we've already initialized the cache handlers interface, don't do it\n    // again.\n    if (!initializeCacheHandlers()) return\n\n    for (const [kind, handler] of Object.entries(cacheHandlers)) {\n      if (!handler) continue\n\n      setCacheHandler(\n        kind,\n        interopDefault(\n          await dynamicImportEsmDefault(\n            formatDynamicImportPath(this.distDir, handler)\n          )\n        )\n      )\n    }\n  }\n\n  protected async getIncrementalCache({\n    requestHeaders,\n    requestProtocol,\n  }: {\n    requestHeaders: IncrementalCache['requestHeaders']\n    requestProtocol: 'http' | 'https'\n  }) {\n    const dev = !!this.renderOpts.dev\n    let CacheHandler: any\n    const { cacheHandler } = this.nextConfig\n\n    if (cacheHandler) {\n      CacheHandler = interopDefault(\n        await dynamicImportEsmDefault(\n          formatDynamicImportPath(this.distDir, cacheHandler)\n        )\n      )\n    }\n\n    await this.loadCustomCacheHandlers()\n\n    // incremental-cache is request specific\n    // although can have shared caches in module scope\n    // per-cache handler\n    return new IncrementalCache({\n      fs: this.getCacheFilesystem(),\n      dev,\n      requestHeaders,\n      requestProtocol,\n      allowedRevalidateHeaderKeys:\n        this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      minimalMode: this.minimalMode,\n      serverDistDir: this.serverDistDir,\n      fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n      maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n      flushToDisk:\n        !this.minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n      getPrerenderManifest: () => this.getPrerenderManifest(),\n      CurCacheHandler: CacheHandler,\n    })\n  }\n\n  protected getResponseCache() {\n    return new ResponseCache(this.minimalMode)\n  }\n\n  protected getPublicDir(): string {\n    return join(this.dir, CLIENT_PUBLIC_FILES_PATH)\n  }\n\n  protected getHasStaticDir(): boolean {\n    return fs.existsSync(join(this.dir, 'static'))\n  }\n\n  protected getPagesManifest(): PagesManifest | undefined {\n    return loadManifest(\n      join(this.serverDistDir, PAGES_MANIFEST)\n    ) as PagesManifest\n  }\n\n  protected getAppPathsManifest(): PagesManifest | undefined {\n    if (!this.enabledDirectories.app) return undefined\n\n    return loadManifest(\n      join(this.serverDistDir, APP_PATHS_MANIFEST)\n    ) as PagesManifest\n  }\n\n  protected getinterceptionRoutePatterns(): RegExp[] {\n    if (!this.enabledDirectories.app) return []\n\n    const routesManifest = this.getRoutesManifest()\n    return (\n      routesManifest?.rewrites.beforeFiles\n        .filter(isInterceptionRouteRewrite)\n        .map((rewrite) => new RegExp(rewrite.regex)) ?? []\n    )\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    return !!getMaybePagePath(\n      pathname,\n      this.distDir,\n      this.nextConfig.i18n?.locales,\n      this.enabledDirectories.app\n    )\n  }\n\n  protected getBuildId(): string {\n    const buildIdFile = join(this.distDir, BUILD_ID_FILE)\n    try {\n      return fs.readFileSync(buildIdFile, 'utf8').trim()\n    } catch (err: any) {\n      if (err.code === 'ENOENT') {\n        throw new Error(\n          `Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`\n        )\n      }\n\n      throw err\n    }\n  }\n\n  protected getEnabledDirectories(dev: boolean): NextEnabledDirectories {\n    const dir = dev ? this.dir : this.serverDistDir\n\n    return {\n      app: findDir(dir, 'app') ? true : false,\n      pages: findDir(dir, 'pages') ? true : false,\n    }\n  }\n\n  protected sendRenderResult(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    options: {\n      result: RenderResult\n      type: 'html' | 'json' | 'rsc'\n      generateEtags: boolean\n      poweredByHeader: boolean\n      cacheControl: CacheControl | undefined\n    }\n  ): Promise<void> {\n    return sendRenderResult({\n      req: req.originalRequest,\n      res: res.originalResponse,\n      result: options.result,\n      type: options.type,\n      generateEtags: options.generateEtags,\n      poweredByHeader: options.poweredByHeader,\n      cacheControl: options.cacheControl,\n    })\n  }\n\n  protected async runApi(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    query: ParsedUrlQuery,\n    match: PagesAPIRouteMatch\n  ): Promise<boolean> {\n    const edgeFunctionsPages = this.getEdgeFunctionsPages()\n\n    for (const edgeFunctionsPage of edgeFunctionsPages) {\n      if (edgeFunctionsPage === match.definition.pathname) {\n        const handledAsEdgeFunction = await this.runEdgeFunction({\n          req,\n          res,\n          query,\n          params: match.params,\n          page: match.definition.pathname,\n          appPaths: null,\n        })\n\n        if (handledAsEdgeFunction) {\n          return true\n        }\n      }\n    }\n\n    // The module supports minimal mode, load the minimal module.\n    const module = await RouteModuleLoader.load<PagesAPIRouteModule>(\n      match.definition.filename\n    )\n\n    query = { ...query, ...match.params }\n\n    await module.render(req.originalRequest, res.originalResponse, {\n      previewProps: this.renderOpts.previewProps,\n      revalidate: this.revalidate.bind(this),\n      trustHostHeader: this.nextConfig.experimental.trustHostHeader,\n      allowedRevalidateHeaderKeys:\n        this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      hostname: this.fetchHostname,\n      minimalMode: this.minimalMode,\n      dev: this.renderOpts.dev === true,\n      query,\n      params: match.params,\n      page: match.definition.pathname,\n      onError: this.instrumentationOnRequestError.bind(this),\n      multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode,\n    })\n\n    return true\n  }\n\n  protected async renderHTML(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult> {\n    return getTracer().trace(NextNodeServerSpan.renderHTML, async () =>\n      this.renderHTMLImpl(req, res, pathname, query, renderOpts)\n    )\n  }\n\n  private async renderHTMLImpl(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult> {\n    if (process.env.NEXT_MINIMAL) {\n      throw new Error(\n        'Invariant: renderHTML should not be called in minimal mode'\n      )\n      // the `else` branch is needed for tree-shaking\n    } else {\n      // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n      // object here but only updating its `nextFontManifest` field.\n      // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n      renderOpts.nextFontManifest = this.nextFontManifest\n\n      if (this.enabledDirectories.app && renderOpts.isAppPath) {\n        return lazyRenderAppPage(\n          req,\n          res,\n          pathname,\n          query,\n          // This code path does not service revalidations for unknown param\n          // shells. As a result, we don't need to pass in the unknown params.\n          null,\n          renderOpts,\n          this.getServerComponentsHmrCache(),\n          false,\n          {\n            buildId: this.buildId,\n          }\n        )\n      }\n\n      // TODO: re-enable this once we've refactored to use implicit matches\n      // throw new Error('Invariant: render should have used routeModule')\n\n      return lazyRenderPagesPage(\n        req.originalRequest,\n        res.originalResponse,\n        pathname,\n        query,\n        renderOpts,\n        {\n          buildId: this.buildId,\n          deploymentId: this.nextConfig.deploymentId,\n          customServer: this.serverOptions.customServer || undefined,\n        },\n        {\n          isFallback: false,\n          isDraftMode: renderOpts.isDraftMode,\n          developmentNotFoundSourcePage: getRequestMeta(\n            req,\n            'developmentNotFoundSourcePage'\n          ),\n        }\n      )\n    }\n  }\n\n  protected async imageOptimizer(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    paramsResult: import('./image-optimizer').ImageParamsResult,\n    previousCacheEntry?: IncrementalResponseCacheEntry | null\n  ): Promise<{\n    buffer: Buffer\n    contentType: string\n    maxAge: number\n    upstreamEtag: string\n    etag: string\n  }> {\n    if (process.env.NEXT_MINIMAL) {\n      throw new Error(\n        'invariant: imageOptimizer should not be called in minimal mode'\n      )\n    } else {\n      const { imageOptimizer, fetchExternalImage, fetchInternalImage } =\n        require('./image-optimizer') as typeof import('./image-optimizer')\n\n      const handleInternalReq = async (\n        newReq: IncomingMessage,\n        newRes: ServerResponse\n      ) => {\n        if (newReq.url === req.url) {\n          throw new Error(`Invariant attempted to optimize _next/image itself`)\n        }\n\n        if (!this.routerServerHandler) {\n          throw new Error(`Invariant missing routerServerHandler`)\n        }\n\n        await this.routerServerHandler(newReq, newRes)\n        return\n      }\n\n      const { isAbsolute, href } = paramsResult\n\n      const imageUpstream = isAbsolute\n        ? await fetchExternalImage(href)\n        : await fetchInternalImage(\n            href,\n            req.originalRequest,\n            res.originalResponse,\n            handleInternalReq\n          )\n\n      return imageOptimizer(imageUpstream, paramsResult, this.nextConfig, {\n        isDev: this.renderOpts.dev,\n        previousCacheEntry,\n      })\n    }\n  }\n\n  protected getPagePath(pathname: string, locales?: string[]): string {\n    return getPagePath(\n      pathname,\n      this.distDir,\n      locales,\n      this.enabledDirectories.app\n    )\n  }\n\n  protected async renderPageComponent(\n    ctx: RequestContext<NodeNextRequest, NodeNextResponse>,\n    bubbleNoFallback: boolean\n  ) {\n    const edgeFunctionsPages = this.getEdgeFunctionsPages() || []\n    if (edgeFunctionsPages.length) {\n      const appPaths = this.getOriginalAppPaths(ctx.pathname)\n      const isAppPath = Array.isArray(appPaths)\n\n      let page = ctx.pathname\n      if (isAppPath) {\n        // When it's an array, we need to pass all parallel routes to the loader.\n        page = appPaths[0]\n      }\n\n      for (const edgeFunctionsPage of edgeFunctionsPages) {\n        if (edgeFunctionsPage === page) {\n          await this.runEdgeFunction({\n            req: ctx.req,\n            res: ctx.res,\n            query: ctx.query,\n            params: ctx.renderOpts.params,\n            page,\n            appPaths,\n          })\n          return null\n        }\n      }\n    }\n\n    return super.renderPageComponent(ctx, bubbleNoFallback)\n  }\n\n  protected async findPageComponents({\n    locale,\n    page,\n    query,\n    params,\n    isAppPath,\n    url,\n  }: {\n    locale: string | undefined\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    // The following parameters are used in the development server's\n    // implementation.\n    sriEnabled?: boolean\n    appPaths?: ReadonlyArray<string> | null\n    shouldEnsure: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null> {\n    return getTracer().trace(\n      NextNodeServerSpan.findPageComponents,\n      {\n        spanName: 'resolve page components',\n        attributes: {\n          'next.route': isAppPath ? normalizeAppPath(page) : page,\n        },\n      },\n      () =>\n        this.findPageComponentsImpl({\n          locale,\n          page,\n          query,\n          params,\n          isAppPath,\n          url,\n        })\n    )\n  }\n\n  private async findPageComponentsImpl({\n    locale,\n    page,\n    query,\n    params,\n    isAppPath,\n    url: _url,\n  }: {\n    locale: string | undefined\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null> {\n    const pagePaths: string[] = [page]\n    if (query.amp) {\n      // try serving a static AMP version first\n      pagePaths.unshift(\n        (isAppPath ? normalizeAppPath(page) : normalizePagePath(page)) + '.amp'\n      )\n    }\n\n    if (locale) {\n      pagePaths.unshift(\n        ...pagePaths.map((path) => `/${locale}${path === '/' ? '' : path}`)\n      )\n    }\n\n    for (const pagePath of pagePaths) {\n      try {\n        const components = await loadComponents({\n          distDir: this.distDir,\n          page: pagePath,\n          isAppPath,\n          isDev: this.isDev,\n          sriEnabled: this.sriEnabled,\n        })\n\n        if (\n          locale &&\n          typeof components.Component === 'string' &&\n          !pagePath.startsWith(`/${locale}/`) &&\n          pagePath !== `/${locale}`\n        ) {\n          // if loading an static HTML file the locale is required\n          // to be present since all HTML files are output under their locale\n          continue\n        }\n\n        return {\n          components,\n          query: {\n            ...(!this.renderOpts.isExperimentalCompile &&\n            components.getStaticProps\n              ? ({\n                  amp: query.amp,\n                } as NextParsedUrlQuery)\n              : query),\n            // For appDir params is excluded.\n            ...((isAppPath ? {} : params) || {}),\n          },\n        }\n      } catch (err) {\n        // we should only not throw if we failed to find the page\n        // in the pages-manifest\n        if (!(err instanceof PageNotFoundError)) {\n          throw err\n        }\n      }\n    }\n    return null\n  }\n\n  protected getNextFontManifest(): NextFontManifest | undefined {\n    return loadManifest(\n      join(this.distDir, 'server', NEXT_FONT_MANIFEST + '.json')\n    ) as NextFontManifest\n  }\n\n  protected handleNextImageRequest: NodeRouteHandler = async (\n    req,\n    res,\n    parsedUrl\n  ) => {\n    if (!parsedUrl.pathname || !parsedUrl.pathname.startsWith('/_next/image')) {\n      return false\n    }\n    // Ignore if its a middleware request\n    if (getRequestMeta(req, 'middlewareInvoke')) {\n      return false\n    }\n\n    if (\n      this.minimalMode ||\n      this.nextConfig.output === 'export' ||\n      process.env.NEXT_MINIMAL\n    ) {\n      res.statusCode = 400\n      res.body('Bad Request').send()\n      return true\n      // the `else` branch is needed for tree-shaking\n    } else {\n      const { ImageOptimizerCache } =\n        require('./image-optimizer') as typeof import('./image-optimizer')\n\n      const imageOptimizerCache = new ImageOptimizerCache({\n        distDir: this.distDir,\n        nextConfig: this.nextConfig,\n      })\n\n      const { sendResponse, ImageError } =\n        require('./image-optimizer') as typeof import('./image-optimizer')\n\n      if (!this.imageResponseCache) {\n        throw new Error('invariant image optimizer cache was not initialized')\n      }\n      const imagesConfig = this.nextConfig.images\n\n      if (imagesConfig.loader !== 'default' || imagesConfig.unoptimized) {\n        await this.render404(req, res)\n        return true\n      }\n\n      const paramsResult = ImageOptimizerCache.validateParams(\n        req.originalRequest,\n        parsedUrl.query,\n        this.nextConfig,\n        !!this.renderOpts.dev\n      )\n\n      if ('errorMessage' in paramsResult) {\n        res.statusCode = 400\n        res.body(paramsResult.errorMessage).send()\n        return true\n      }\n\n      const cacheKey = ImageOptimizerCache.getCacheKey(paramsResult)\n\n      try {\n        const { getExtension } =\n          require('./serve-static') as typeof import('./serve-static')\n        const cacheEntry = await this.imageResponseCache.get(\n          cacheKey,\n          async ({ previousCacheEntry }) => {\n            const { buffer, contentType, maxAge, upstreamEtag, etag } =\n              await this.imageOptimizer(\n                req,\n                res,\n                paramsResult,\n                previousCacheEntry\n              )\n\n            return {\n              value: {\n                kind: CachedRouteKind.IMAGE,\n                buffer,\n                etag,\n                extension: getExtension(contentType) as string,\n                upstreamEtag,\n              },\n              isFallback: false,\n              cacheControl: { revalidate: maxAge, expire: undefined },\n            }\n          },\n          {\n            routeKind: RouteKind.IMAGE,\n            incrementalCache: imageOptimizerCache,\n            isFallback: false,\n          }\n        )\n\n        if (cacheEntry?.value?.kind !== CachedRouteKind.IMAGE) {\n          throw new Error(\n            'invariant did not get entry from image response cache'\n          )\n        }\n\n        sendResponse(\n          req.originalRequest,\n          res.originalResponse,\n          paramsResult.href,\n          cacheEntry.value.extension,\n          cacheEntry.value.buffer,\n          cacheEntry.value.etag,\n          paramsResult.isStatic,\n          cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT',\n          imagesConfig,\n          cacheEntry.cacheControl?.revalidate || 0,\n          Boolean(this.renderOpts.dev)\n        )\n        return true\n      } catch (err) {\n        if (err instanceof ImageError) {\n          res.statusCode = err.statusCode\n          res.body(err.message).send()\n          return true\n        }\n        throw err\n      }\n    }\n  }\n\n  protected handleCatchallRenderRequest: NodeRouteHandler = async (\n    req,\n    res,\n    parsedUrl\n  ) => {\n    let { pathname, query } = parsedUrl\n    if (!pathname) {\n      throw new Error('Invariant: pathname is undefined')\n    }\n\n    // This is a catch-all route, there should be no fallbacks so mark it as\n    // such.\n    addRequestMeta(req, 'bubbleNoFallback', true)\n\n    try {\n      // next.js core assumes page path without trailing slash\n      pathname = removeTrailingSlash(pathname)\n\n      const options: MatchOptions = {\n        i18n: this.i18nProvider?.fromRequest(req, pathname),\n      }\n      const match = await this.matchers.match(pathname, options)\n\n      // If we don't have a match, try to render it anyways.\n      if (!match) {\n        await this.render(req, res, pathname, query, parsedUrl, true)\n\n        return true\n      }\n\n      // Add the match to the request so we don't have to re-run the matcher\n      // for the same request.\n      addRequestMeta(req, 'match', match)\n\n      // TODO-APP: move this to a route handler\n      const edgeFunctionsPages = this.getEdgeFunctionsPages()\n      for (const edgeFunctionsPage of edgeFunctionsPages) {\n        // If the page doesn't match the edge function page, skip it.\n        if (edgeFunctionsPage !== match.definition.page) continue\n\n        if (this.nextConfig.output === 'export') {\n          await this.render404(req, res, parsedUrl)\n          return true\n        }\n        delete query[NEXT_RSC_UNION_QUERY]\n\n        // If we handled the request, we can return early.\n        // For api routes edge runtime\n        try {\n          const handled = await this.runEdgeFunction({\n            req,\n            res,\n            query,\n            params: match.params,\n            page: match.definition.page,\n            match,\n            appPaths: null,\n          })\n          if (handled) return true\n        } catch (apiError) {\n          await this.instrumentationOnRequestError(apiError, req, {\n            routePath: match.definition.page,\n            routerKind: 'Pages Router',\n            routeType: 'route',\n            // Edge runtime does not support ISR\n            revalidateReason: undefined,\n          })\n          throw apiError\n        }\n      }\n\n      // If the route was detected as being a Pages API route, then handle\n      // it.\n      // TODO: move this behavior into a route handler.\n      if (isPagesAPIRouteMatch(match)) {\n        if (this.nextConfig.output === 'export') {\n          await this.render404(req, res, parsedUrl)\n          return true\n        }\n\n        const handled = await this.handleApiRequest(req, res, query, match)\n        if (handled) return true\n      }\n\n      await this.render(req, res, pathname, query, parsedUrl, true)\n\n      return true\n    } catch (err: any) {\n      if (err instanceof NoFallbackError) {\n        throw err\n      }\n\n      try {\n        if (this.renderOpts.dev) {\n          const { formatServerError } =\n            require('../lib/format-server-error') as typeof import('../lib/format-server-error')\n          formatServerError(err)\n          this.logErrorWithOriginalStack(err)\n        } else {\n          this.logError(err)\n        }\n        res.statusCode = 500\n        await this.renderError(err, req, res, pathname, query)\n        return true\n      } catch {}\n\n      throw err\n    }\n  }\n\n  // Used in development only, overloaded in next-dev-server\n  protected logErrorWithOriginalStack(\n    _err?: unknown,\n    _type?: 'unhandledRejection' | 'uncaughtException' | 'warning' | 'app-dir'\n  ): void {\n    throw new Error(\n      'Invariant: logErrorWithOriginalStack can only be called on the development server'\n    )\n  }\n\n  // Used in development only, overloaded in next-dev-server\n  protected async ensurePage(_opts: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    match?: RouteMatch\n    url?: string\n  }): Promise<void> {\n    throw new Error(\n      'Invariant: ensurePage can only be called on the development server'\n    )\n  }\n\n  /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */\n  protected async handleApiRequest(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    query: ParsedUrlQuery,\n    match: PagesAPIRouteMatch\n  ): Promise<boolean> {\n    return this.runApi(req, res, query, match)\n  }\n\n  protected getCacheFilesystem(): CacheFs {\n    return nodeFs\n  }\n\n  protected normalizeReq(\n    req: NodeNextRequest | IncomingMessage\n  ): NodeNextRequest {\n    return !(req instanceof NodeNextRequest) ? new NodeNextRequest(req) : req\n  }\n\n  protected normalizeRes(\n    res: NodeNextResponse | ServerResponse\n  ): NodeNextResponse {\n    return !(res instanceof NodeNextResponse) ? new NodeNextResponse(res) : res\n  }\n\n  public getRequestHandler(): NodeRequestHandler {\n    const handler = this.makeRequestHandler()\n    if (this.serverOptions.experimentalTestProxy) {\n      const {\n        wrapRequestHandlerNode,\n      } = require('next/dist/experimental/testmode/server')\n      return wrapRequestHandlerNode(handler)\n    }\n    return handler\n  }\n\n  private makeRequestHandler(): NodeRequestHandler {\n    // This is just optimization to fire prepare as soon as possible. It will be\n    // properly awaited later. We add the catch here to ensure that it does not\n    // cause an unhandled promise rejection. The promise rejection will be\n    // handled later on via the `await` when the request handler is called.\n    this.prepare().catch((err) => {\n      console.error('Failed to prepare server', err)\n    })\n\n    const handler = super.getRequestHandler()\n\n    return (req, res, parsedUrl) =>\n      handler(this.normalizeReq(req), this.normalizeRes(res), parsedUrl)\n  }\n\n  public async revalidate({\n    urlPath,\n    revalidateHeaders,\n    opts,\n  }: {\n    urlPath: string\n    revalidateHeaders: { [key: string]: string | string[] }\n    opts: { unstable_onlyGenerated?: boolean }\n  }) {\n    const mocked = createRequestResponseMocks({\n      url: urlPath,\n      headers: revalidateHeaders,\n    })\n\n    const handler = this.getRequestHandler()\n    await handler(\n      new NodeNextRequest(mocked.req),\n      new NodeNextResponse(mocked.res)\n    )\n    await mocked.res.hasStreamed\n\n    if (\n      mocked.res.getHeader('x-nextjs-cache') !== 'REVALIDATED' &&\n      mocked.res.statusCode !== 200 &&\n      !(mocked.res.statusCode === 404 && opts.unstable_onlyGenerated)\n    ) {\n      throw new Error(`Invalid response ${mocked.res.statusCode}`)\n    }\n  }\n\n  public async render(\n    req: NodeNextRequest | IncomingMessage,\n    res: NodeNextResponse | ServerResponse,\n    pathname: string,\n    query?: NextParsedUrlQuery,\n    parsedUrl?: NextUrlWithParsedQuery,\n    internal = false\n  ): Promise<void> {\n    return super.render(\n      this.normalizeReq(req),\n      this.normalizeRes(res),\n      pathname,\n      query,\n      parsedUrl,\n      internal\n    )\n  }\n\n  public async renderToHTML(\n    req: NodeNextRequest | IncomingMessage,\n    res: NodeNextResponse | ServerResponse,\n    pathname: string,\n    query?: ParsedUrlQuery\n  ): Promise<string | null> {\n    return super.renderToHTML(\n      this.normalizeReq(req),\n      this.normalizeRes(res),\n      pathname,\n      query\n    )\n  }\n\n  protected async renderErrorToResponseImpl(\n    ctx: RequestContext<NodeNextRequest, NodeNextResponse>,\n    err: Error | null\n  ) {\n    const { req, res, query } = ctx\n    const is404 = res.statusCode === 404\n\n    if (is404 && this.enabledDirectories.app) {\n      if (this.renderOpts.dev) {\n        await this.ensurePage({\n          page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n          clientOnly: false,\n          url: req.url,\n        }).catch(() => {})\n      }\n\n      if (\n        this.getEdgeFunctionsPages().includes(UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)\n      ) {\n        await this.runEdgeFunction({\n          req,\n          res,\n          query: query || {},\n          params: {},\n          page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n          appPaths: null,\n        })\n        return null\n      }\n    }\n    return super.renderErrorToResponseImpl(ctx, err)\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: NodeNextRequest | IncomingMessage,\n    res: NodeNextResponse | ServerResponse,\n    pathname: string,\n    query?: NextParsedUrlQuery,\n    setHeaders?: boolean\n  ): Promise<void> {\n    return super.renderError(\n      err,\n      this.normalizeReq(req),\n      this.normalizeRes(res),\n      pathname,\n      query,\n      setHeaders\n    )\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: NodeNextRequest | IncomingMessage,\n    res: NodeNextResponse | ServerResponse,\n    pathname: string,\n    query?: ParsedUrlQuery\n  ): Promise<string | null> {\n    return super.renderErrorToHTML(\n      err,\n      this.normalizeReq(req),\n      this.normalizeRes(res),\n      pathname,\n      query\n    )\n  }\n\n  public async render404(\n    req: NodeNextRequest | IncomingMessage,\n    res: NodeNextResponse | ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery,\n    setHeaders?: boolean\n  ): Promise<void> {\n    return super.render404(\n      this.normalizeReq(req),\n      this.normalizeRes(res),\n      parsedUrl,\n      setHeaders\n    )\n  }\n\n  protected getMiddlewareManifest(): MiddlewareManifest | null {\n    if (this.minimalMode) {\n      return null\n    } else {\n      const manifest: MiddlewareManifest = require(this.middlewareManifestPath)\n      return manifest\n    }\n  }\n\n  /** Returns the middleware routing item if there is one. */\n  protected async getMiddleware(): Promise<MiddlewareRoutingItem | undefined> {\n    const manifest = this.getMiddlewareManifest()\n    const middleware = manifest?.middleware?.['/']\n    if (!middleware) {\n      const middlewareModule = await this.loadNodeMiddleware()\n\n      if (middlewareModule) {\n        return {\n          match: getMiddlewareRouteMatcher(\n            middlewareModule.config?.matchers || [\n              { regexp: '.*', originalSource: '/:path*' },\n            ]\n          ),\n          page: '/',\n        }\n      }\n\n      return\n    }\n\n    return {\n      match: getMiddlewareMatcher(middleware),\n      page: '/',\n    }\n  }\n\n  protected getEdgeFunctionsPages(): string[] {\n    const manifest = this.getMiddlewareManifest()\n    if (!manifest) {\n      return []\n    }\n\n    return Object.keys(manifest.functions)\n  }\n\n  /**\n   * Get information for the edge function located in the provided page\n   * folder. If the edge function info can't be found it will throw\n   * an error.\n   */\n  protected getEdgeFunctionInfo(params: {\n    page: string\n    /** Whether we should look for a middleware or not */\n    middleware: boolean\n  }): {\n    name: string\n    paths: string[]\n    wasm: { filePath: string; name: string }[]\n    env: { [key: string]: string }\n    assets?: { filePath: string; name: string }[]\n  } | null {\n    const manifest = this.getMiddlewareManifest()\n    if (!manifest) {\n      return null\n    }\n\n    let foundPage: string\n\n    try {\n      foundPage = denormalizePagePath(normalizePagePath(params.page))\n    } catch (err) {\n      return null\n    }\n\n    let pageInfo = params.middleware\n      ? manifest.middleware[foundPage]\n      : manifest.functions[foundPage]\n\n    if (!pageInfo) {\n      if (!params.middleware) {\n        throw new PageNotFoundError(foundPage)\n      }\n      return null\n    }\n\n    return {\n      name: pageInfo.name,\n      paths: pageInfo.files.map((file) => join(this.distDir, file)),\n      wasm: (pageInfo.wasm ?? []).map((binding) => ({\n        ...binding,\n        filePath: join(this.distDir, binding.filePath),\n      })),\n      assets:\n        pageInfo.assets &&\n        pageInfo.assets.map((binding) => {\n          return {\n            ...binding,\n            filePath: join(this.distDir, binding.filePath),\n          }\n        }),\n      env: pageInfo.env,\n    }\n  }\n\n  private async loadNodeMiddleware() {\n    if (!this.nextConfig.experimental.nodeMiddleware) {\n      return\n    }\n\n    try {\n      const functionsConfig = this.renderOpts.dev\n        ? {}\n        : require(join(this.distDir, 'server', FUNCTIONS_CONFIG_MANIFEST))\n\n      if (this.renderOpts.dev || functionsConfig?.functions?.['/_middleware']) {\n        // if used with top level await, this will be a promise\n        return require(join(this.distDir, 'server', 'middleware.js'))\n      }\n    } catch (err) {\n      if (\n        isError(err) &&\n        err.code !== 'ENOENT' &&\n        err.code !== 'MODULE_NOT_FOUND'\n      ) {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Checks if a middleware exists. This method is useful for the development\n   * server where we need to check the filesystem. Here we just check the\n   * middleware manifest.\n   */\n  protected async hasMiddleware(pathname: string): Promise<boolean> {\n    const info = this.getEdgeFunctionInfo({ page: pathname, middleware: true })\n    const nodeMiddleware = await this.loadNodeMiddleware()\n\n    if (!info && nodeMiddleware) {\n      return true\n    }\n    return Boolean(info && info.paths.length > 0)\n  }\n\n  /**\n   * A placeholder for a function to be defined in the development server.\n   * It will make sure that the root middleware or an edge function has been compiled\n   * so that we can run it.\n   */\n  protected async ensureMiddleware(_url?: string) {}\n  protected async ensureEdgeFunction(_params: {\n    page: string\n    appPaths: string[] | null\n    url?: string\n  }) {}\n\n  /**\n   * This method gets all middleware matchers and execute them when the request\n   * matches. It will make sure that each middleware exists and is compiled and\n   * ready to be invoked. The development server will decorate it to add warns\n   * and errors with rich traces.\n   */\n  protected async runMiddleware(params: {\n    request: NodeNextRequest\n    response: NodeNextResponse\n    parsedUrl: ParsedUrl\n    parsed: UrlWithParsedQuery\n    onWarning?: (warning: Error) => void\n  }) {\n    if (process.env.NEXT_MINIMAL) {\n      throw new Error(\n        'invariant: runMiddleware should not be called in minimal mode'\n      )\n    }\n\n    // Middleware is skipped for on-demand revalidate requests\n    if (\n      checkIsOnDemandRevalidate(params.request, this.renderOpts.previewProps)\n        .isOnDemandRevalidate\n    ) {\n      return {\n        response: new Response(null, { headers: { 'x-middleware-next': '1' } }),\n      } as FetchEventResult\n    }\n\n    let url: string\n\n    if (this.nextConfig.skipMiddlewareUrlNormalize) {\n      url = getRequestMeta(params.request, 'initURL')!\n    } else {\n      // For middleware to \"fetch\" we must always provide an absolute URL\n      const query = urlQueryToSearchParams(params.parsed.query).toString()\n      const locale = getRequestMeta(params.request, 'locale')\n\n      url = `${getRequestMeta(params.request, 'initProtocol')}://${\n        this.fetchHostname || 'localhost'\n      }:${this.port}${locale ? `/${locale}` : ''}${params.parsed.pathname}${\n        query ? `?${query}` : ''\n      }`\n    }\n\n    if (!url.startsWith('http')) {\n      throw new Error(\n        'To use middleware you must provide a `hostname` and `port` to the Next.js Server'\n      )\n    }\n\n    const page: {\n      name?: string\n      params?: { [key: string]: string | string[] }\n    } = {}\n\n    const middleware = await this.getMiddleware()\n    if (!middleware) {\n      return { finished: false }\n    }\n    if (!(await this.hasMiddleware(middleware.page))) {\n      return { finished: false }\n    }\n\n    await this.ensureMiddleware(params.request.url)\n    const middlewareInfo = this.getEdgeFunctionInfo({\n      page: middleware.page,\n      middleware: true,\n    })\n\n    const method = (params.request.method || 'GET').toUpperCase()\n    const requestData = {\n      headers: params.request.headers,\n      method,\n      nextConfig: {\n        basePath: this.nextConfig.basePath,\n        i18n: this.nextConfig.i18n,\n        trailingSlash: this.nextConfig.trailingSlash,\n        experimental: this.nextConfig.experimental,\n      },\n      url: url,\n      page,\n      body:\n        method !== 'GET' && method !== 'HEAD'\n          ? (getRequestMeta(params.request, 'clonableBody') as any)\n          : undefined,\n\n      signal: signalFromNodeResponse(params.response.originalResponse),\n      waitUntil: this.getWaitUntil(),\n    }\n    let result:\n      | UnwrapPromise<ReturnType<typeof import('./web/sandbox').run>>\n      | undefined\n\n    // if no middleware info check for Node.js middleware\n    // this is not in the middleware-manifest as that historically\n    // has only included edge-functions, we need to do a breaking\n    // version bump for that manifest to write this info there if\n    // we decide we want to\n    if (!middlewareInfo) {\n      let middlewareModule\n      middlewareModule = await this.loadNodeMiddleware()\n\n      if (!middlewareModule) {\n        throw new MiddlewareNotFoundError()\n      }\n      const adapterFn: typeof import('./web/adapter').adapter =\n        middlewareModule.default || middlewareModule\n\n      result = await adapterFn({\n        handler: middlewareModule.middleware || middlewareModule,\n        request: requestData,\n        page: 'middleware',\n      })\n    } else {\n      const { run } = require('./web/sandbox') as typeof import('./web/sandbox')\n\n      result = await run({\n        distDir: this.distDir,\n        name: middlewareInfo.name,\n        paths: middlewareInfo.paths,\n        edgeFunctionEntry: middlewareInfo,\n        request: requestData,\n        useCache: true,\n        onWarning: params.onWarning,\n      })\n    }\n\n    if (!this.renderOpts.dev) {\n      result.waitUntil.catch((error) => {\n        console.error(`Uncaught: middleware waitUntil errored`, error)\n      })\n    }\n\n    if (!result) {\n      this.render404(params.request, params.response, params.parsed)\n      return { finished: true }\n    }\n\n    // Split compound (comma-separated) set-cookie headers\n    if (result.response.headers.has('set-cookie')) {\n      const cookies = result.response.headers\n        .getSetCookie()\n        .flatMap((maybeCompoundCookie) =>\n          splitCookiesString(maybeCompoundCookie)\n        )\n\n      // Clear existing header(s)\n      result.response.headers.delete('set-cookie')\n\n      // Append each cookie individually.\n      for (const cookie of cookies) {\n        result.response.headers.append('set-cookie', cookie)\n      }\n\n      // Add cookies to request meta.\n      addRequestMeta(params.request, 'middlewareCookie', cookies)\n    }\n\n    return result\n  }\n\n  protected handleCatchallMiddlewareRequest: NodeRouteHandler = async (\n    req,\n    res,\n    parsed\n  ) => {\n    const isMiddlewareInvoke = getRequestMeta(req, 'middlewareInvoke')\n\n    if (!isMiddlewareInvoke) {\n      return false\n    }\n\n    const handleFinished = () => {\n      addRequestMeta(req, 'middlewareInvoke', true)\n      res.body('').send()\n      return true\n    }\n\n    const middleware = await this.getMiddleware()\n    if (!middleware) {\n      return handleFinished()\n    }\n\n    const initUrl = getRequestMeta(req, 'initURL')!\n    const parsedUrl = parseUrl(initUrl)\n    const pathnameInfo = getNextPathnameInfo(parsedUrl.pathname, {\n      nextConfig: this.nextConfig,\n      i18nProvider: this.i18nProvider,\n    })\n\n    parsedUrl.pathname = pathnameInfo.pathname\n    const normalizedPathname = removeTrailingSlash(parsed.pathname || '')\n    if (!middleware.match(normalizedPathname, req, parsedUrl.query)) {\n      return handleFinished()\n    }\n\n    let result: Awaited<\n      ReturnType<typeof NextNodeServer.prototype.runMiddleware>\n    >\n    let bubblingResult = false\n\n    try {\n      await this.ensureMiddleware(req.url)\n\n      result = await this.runMiddleware({\n        request: req,\n        response: res,\n        parsedUrl: parsedUrl,\n        parsed: parsed,\n      })\n\n      if ('response' in result) {\n        if (isMiddlewareInvoke) {\n          bubblingResult = true\n          throw new BubbledError(true, result)\n        }\n\n        for (const [key, value] of Object.entries(\n          toNodeOutgoingHttpHeaders(result.response.headers)\n        )) {\n          if (key !== 'content-encoding' && value !== undefined) {\n            res.setHeader(key, value as string | string[])\n          }\n        }\n        res.statusCode = result.response.status\n\n        const { originalResponse } = res\n        if (result.response.body) {\n          await pipeToNodeResponse(result.response.body, originalResponse)\n        } else {\n          originalResponse.end()\n        }\n        return true\n      }\n    } catch (err: unknown) {\n      if (bubblingResult) {\n        throw err\n      }\n\n      if (isError(err) && err.code === 'ENOENT') {\n        await this.render404(req, res, parsed)\n        return true\n      }\n\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        await this.renderError(err, req, res, parsed.pathname || '')\n        return true\n      }\n\n      const error = getProperError(err)\n      console.error(error)\n      res.statusCode = 500\n      await this.renderError(error, req, res, parsed.pathname || '')\n      return true\n    }\n\n    return result.finished\n  }\n\n  private _cachedPreviewManifest: PrerenderManifest | undefined\n  protected getPrerenderManifest(): PrerenderManifest {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest\n    }\n    if (\n      this.renderOpts?.dev ||\n      this.serverOptions?.dev ||\n      process.env.NODE_ENV === 'development' ||\n      process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD\n    ) {\n      this._cachedPreviewManifest = {\n        version: 4,\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: {\n          previewModeId: require('crypto').randomBytes(16).toString('hex'),\n          previewModeSigningKey: require('crypto')\n            .randomBytes(32)\n            .toString('hex'),\n          previewModeEncryptionKey: require('crypto')\n            .randomBytes(32)\n            .toString('hex'),\n        },\n      }\n      return this._cachedPreviewManifest\n    }\n\n    this._cachedPreviewManifest = loadManifest(\n      join(this.distDir, PRERENDER_MANIFEST)\n    ) as PrerenderManifest\n\n    return this._cachedPreviewManifest\n  }\n\n  protected getRoutesManifest(): NormalizedRouteManifest | undefined {\n    return getTracer().trace(NextNodeServerSpan.getRoutesManifest, () => {\n      const manifest = loadManifest(join(this.distDir, ROUTES_MANIFEST)) as any\n\n      let rewrites = manifest.rewrites ?? {\n        beforeFiles: [],\n        afterFiles: [],\n        fallback: [],\n      }\n\n      if (Array.isArray(rewrites)) {\n        rewrites = {\n          beforeFiles: [],\n          afterFiles: rewrites,\n          fallback: [],\n        }\n      }\n\n      return { ...manifest, rewrites }\n    })\n  }\n\n  protected attachRequestMeta(\n    req: NodeNextRequest,\n    parsedUrl: NextUrlWithParsedQuery,\n    isUpgradeReq?: boolean\n  ) {\n    // Injected in base-server.ts\n    const protocol = req.headers['x-forwarded-proto']?.includes('https')\n      ? 'https'\n      : 'http'\n\n    // When there are hostname and port we build an absolute URL\n    const initUrl =\n      this.fetchHostname && this.port\n        ? `${protocol}://${this.fetchHostname}:${this.port}${req.url}`\n        : this.nextConfig.experimental.trustHostHeader\n          ? `https://${req.headers.host || 'localhost'}${req.url}`\n          : req.url\n\n    addRequestMeta(req, 'initURL', initUrl)\n    addRequestMeta(req, 'initQuery', { ...parsedUrl.query })\n    addRequestMeta(req, 'initProtocol', protocol)\n\n    if (!isUpgradeReq) {\n      addRequestMeta(req, 'clonableBody', getCloneableBody(req.originalRequest))\n    }\n  }\n\n  protected async runEdgeFunction(params: {\n    req: NodeNextRequest\n    res: NodeNextResponse\n    query: ParsedUrlQuery\n    params: Params | undefined\n    page: string\n    appPaths: string[] | null\n    match?: RouteMatch\n    onError?: (err: unknown) => void\n    onWarning?: (warning: Error) => void\n  }): Promise<FetchEventResult | null> {\n    if (process.env.NEXT_MINIMAL) {\n      throw new Error(\n        'Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.'\n      )\n    }\n    let edgeInfo: ReturnType<typeof this.getEdgeFunctionInfo> | undefined\n\n    const { query, page, match } = params\n\n    if (!match)\n      await this.ensureEdgeFunction({\n        page,\n        appPaths: params.appPaths,\n        url: params.req.url,\n      })\n    edgeInfo = this.getEdgeFunctionInfo({\n      page,\n      middleware: false,\n    })\n\n    if (!edgeInfo) {\n      return null\n    }\n\n    // For edge to \"fetch\" we must always provide an absolute URL\n    const isNextDataRequest = getRequestMeta(params.req, 'isNextDataReq')\n    const initialUrl = new URL(\n      getRequestMeta(params.req, 'initURL') || '/',\n      'http://n'\n    )\n    const queryString = urlQueryToSearchParams({\n      ...Object.fromEntries(initialUrl.searchParams),\n      ...query,\n      ...params.params,\n    }).toString()\n\n    if (isNextDataRequest) {\n      params.req.headers['x-nextjs-data'] = '1'\n    }\n    initialUrl.search = queryString\n    const url = initialUrl.toString()\n\n    if (!url.startsWith('http')) {\n      throw new Error(\n        'To use middleware you must provide a `hostname` and `port` to the Next.js Server'\n      )\n    }\n\n    const { run } = require('./web/sandbox') as typeof import('./web/sandbox')\n    const result = await run({\n      distDir: this.distDir,\n      name: edgeInfo.name,\n      paths: edgeInfo.paths,\n      edgeFunctionEntry: edgeInfo,\n      request: {\n        headers: params.req.headers,\n        method: params.req.method,\n        nextConfig: {\n          basePath: this.nextConfig.basePath,\n          i18n: this.nextConfig.i18n,\n          trailingSlash: this.nextConfig.trailingSlash,\n        },\n        url,\n        page: {\n          name: params.page,\n          ...(params.params && { params: params.params }),\n        },\n        body: getRequestMeta(params.req, 'clonableBody'),\n        signal: signalFromNodeResponse(params.res.originalResponse),\n        waitUntil: this.getWaitUntil(),\n      },\n      useCache: true,\n      onError: params.onError,\n      onWarning: params.onWarning,\n      incrementalCache:\n        (globalThis as any).__incrementalCache ||\n        getRequestMeta(params.req, 'incrementalCache'),\n      serverComponentsHmrCache: getRequestMeta(\n        params.req,\n        'serverComponentsHmrCache'\n      ),\n    })\n\n    if (result.fetchMetrics) {\n      params.req.fetchMetrics = result.fetchMetrics\n    }\n\n    if (!params.res.statusCode || params.res.statusCode < 400) {\n      params.res.statusCode = result.response.status\n      params.res.statusMessage = result.response.statusText\n    }\n\n    // TODO: (wyattjoh) investigate improving this\n\n    result.response.headers.forEach((value, key) => {\n      // The append handling is special cased for `set-cookie`.\n      if (key.toLowerCase() === 'set-cookie') {\n        // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n        for (const cookie of splitCookiesString(value)) {\n          params.res.appendHeader(key, cookie)\n        }\n      } else {\n        params.res.appendHeader(key, value)\n      }\n    })\n\n    const { originalResponse } = params.res\n    if (result.response.body) {\n      await pipeToNodeResponse(result.response.body, originalResponse)\n    } else {\n      originalResponse.end()\n    }\n\n    return result\n  }\n\n  protected get serverDistDir(): string {\n    if (this._serverDistDir) {\n      return this._serverDistDir\n    }\n    const serverDistDir = join(this.distDir, SERVER_DIRECTORY)\n    this._serverDistDir = serverDistDir\n    return serverDistDir\n  }\n\n  protected async getFallbackErrorComponents(\n    _url?: string\n  ): Promise<LoadComponentsReturnType | null> {\n    // Not implemented for production use cases, this is implemented on the\n    // development server.\n    return null\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    await super.instrumentationOnRequestError(...args)\n\n    // For Node.js runtime production logs, in dev it will be overridden by next-dev-server\n    if (!this.renderOpts.dev) {\n      this.logError(args[0] as Error)\n    }\n  }\n\n  protected onServerClose(listener: () => Promise<void>) {\n    this.cleanupListeners.add(listener)\n  }\n\n  async close(): Promise<void> {\n    await this.cleanupListeners.runAll()\n  }\n\n  protected getInternalWaitUntil(): WaitUntil {\n    this.internalWaitUntil ??= this.createInternalWaitUntil()\n    return this.internalWaitUntil\n  }\n\n  private createInternalWaitUntil() {\n    if (this.minimalMode) {\n      throw new InvariantError(\n        'createInternalWaitUntil should never be called in minimal mode'\n      )\n    }\n\n    const awaiter = new AwaiterOnce({ onError: console.error })\n\n    // TODO(after): warn if the process exits before these are awaited\n    this.onServerClose(() => awaiter.awaiting())\n\n    return awaiter.waitUntil\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}