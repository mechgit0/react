{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  BubbledError: null,\n  SpanKind: null,\n  SpanStatusCode: null,\n  getTracer: null,\n  isBubbledError: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  BubbledError: function () {\n    return BubbledError;\n  },\n  SpanKind: function () {\n    return SpanKind;\n  },\n  SpanStatusCode: function () {\n    return SpanStatusCode;\n  },\n  getTracer: function () {\n    return getTracer;\n  },\n  isBubbledError: function () {\n    return isBubbledError;\n  }\n});\nconst _constants = require(\"./constants\");\nconst _isthenable = require(\"../../../shared/lib/is-thenable\");\nlet api;\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api');\n} else {\n  try {\n    api = require('@opentelemetry/api');\n  } catch (err) {\n    api = require('next/dist/compiled/@opentelemetry/api');\n  }\n}\nconst {\n  context,\n  propagation,\n  trace,\n  SpanStatusCode,\n  SpanKind,\n  ROOT_CONTEXT\n} = api;\nclass BubbledError extends Error {\n  constructor(bubble, result) {\n    super(), this.bubble = bubble, this.result = result;\n  }\n}\nfunction isBubbledError(error) {\n  if (typeof error !== 'object' || error === null) return false;\n  return error instanceof BubbledError;\n}\nconst closeSpanWithError = (span, error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true);\n  } else {\n    if (error) {\n      span.recordException(error);\n    }\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error == null ? void 0 : error.message\n    });\n  }\n  span.end();\n};\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map();\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId');\nlet lastSpanId = 0;\nconst getSpanId = () => lastSpanId++;\nconst clientTraceDataSetter = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value\n    });\n  }\n};\nclass NextTracerImpl {\n  /**\n  * Returns an instance to the trace with configured name.\n  * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n  * This should be lazily evaluated.\n  */\n  getTracerInstance() {\n    return trace.getTracer('next.js', '0.0.1');\n  }\n  getContext() {\n    return context;\n  }\n  getTracePropagationData() {\n    const activeContext = context.active();\n    const entries = [];\n    propagation.inject(activeContext, entries, clientTraceDataSetter);\n    return entries;\n  }\n  getActiveScopeSpan() {\n    return trace.getSpan(context == null ? void 0 : context.active());\n  }\n  withPropagatedContext(carrier, fn, getter) {\n    const activeContext = context.active();\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn();\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter);\n    return context.with(remoteContext, fn);\n  }\n  trace() {\n    var _trace_getSpanContext;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const [type, fnOrOptions, fnOrEmpty] = args;\n    // coerce options form overload\n    const {\n      fn,\n      options\n    } = typeof fnOrOptions === 'function' ? {\n      fn: fnOrOptions,\n      options: {}\n    } : {\n      fn: fnOrEmpty,\n      options: {\n        ...fnOrOptions\n      }\n    };\n    const spanName = options.spanName ?? type;\n    if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== '1' || options.hideSpan) {\n      return fn();\n    }\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    let isRootSpan = false;\n    if (!spanContext) {\n      spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;\n      isRootSpan = true;\n    } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {\n      isRootSpan = true;\n    }\n    const spanId = getSpanId();\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes\n    };\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () => this.getTracerInstance().startActiveSpan(spanName, options, span => {\n      const startTime = 'performance' in globalThis && 'measure' in performance ? globalThis.performance.now() : undefined;\n      const onCleanup = () => {\n        rootSpanAttributesStore.delete(spanId);\n        if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && _constants.LogSpanAllowList.includes(type || '')) {\n          performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split('.').pop() || '').replace(/[A-Z]/g, match => '-' + match.toLowerCase())}`, {\n            start: startTime,\n            end: performance.now()\n          });\n        }\n      };\n      if (isRootSpan) {\n        rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\n      }\n      try {\n        if (fn.length > 1) {\n          return fn(span, err => closeSpanWithError(span, err));\n        }\n        const result = fn(span);\n        if ((0, _isthenable.isThenable)(result)) {\n          // If there's error make sure it throws\n          return result.then(res => {\n            span.end();\n            // Need to pass down the promise result,\n            // it could be react stream response with error { error, stream }\n            return res;\n          }).catch(err => {\n            closeSpanWithError(span, err);\n            throw err;\n          }).finally(onCleanup);\n        } else {\n          span.end();\n          onCleanup();\n        }\n        return result;\n      } catch (err) {\n        closeSpanWithError(span, err);\n        onCleanup();\n        throw err;\n      }\n    }));\n  }\n  wrap() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const tracer = this;\n    const [name, options, fn] = args.length === 3 ? args : [args[0], {}, args[1]];\n    if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== '1') {\n      return fn;\n    }\n    return function () {\n      let optionsObj = options;\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments);\n      }\n      const lastArgId = arguments.length - 1;\n      const cb = arguments[lastArgId];\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err) {\n            done == null ? void 0 : done(err);\n            return scopeBoundCb.apply(this, arguments);\n          };\n          return fn.apply(this, arguments);\n        });\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));\n      }\n    };\n  }\n  startSpan() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    const [type, options] = args;\n    const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    return this.getTracerInstance().startSpan(type, options, spanContext);\n  }\n  getSpanContext(parentSpan) {\n    const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\n    return spanContext;\n  }\n  getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey);\n    return rootSpanAttributesStore.get(spanId);\n  }\n  setRootSpanAttribute(key, value) {\n    const spanId = context.active().getValue(rootSpanIdKey);\n    const attributes = rootSpanAttributesStore.get(spanId);\n    if (attributes) {\n      attributes.set(key, value);\n    }\n  }\n}\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl();\n  return () => tracer;\n})();","map":{"version":3,"names":["BubbledError","SpanKind","SpanStatusCode","getTracer","isBubbledError","api","process","env","NEXT_RUNTIME","require","err","context","propagation","trace","ROOT_CONTEXT","Error","constructor","bubble","result","error","closeSpanWithError","span","setAttribute","recordException","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","key","value","push","NextTracerImpl","getTracerInstance","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","_trace_getSpanContext","_len","arguments","length","args","Array","_key","type","fnOrOptions","fnOrEmpty","options","spanName","_constants","NextVanillaSpanAllowlist","includes","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","isRootSpan","isRemote","spanId","attributes","setValue","startActiveSpan","startTime","globalThis","performance","now","undefined","onCleanup","delete","NEXT_OTEL_PERFORMANCE_PREFIX","LogSpanAllowList","measure","split","pop","replace","match","toLowerCase","start","Object","_isthenable","isThenable","then","res","catch","finally","wrap","_len2","_key2","tracer","name","optionsObj","apply","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","_len3","_key3","setSpan","getRootSpanAttributes","getValue","get","setRootSpanAttribute"],"sources":["/home/ashish/my-react-app/node_modules/next/src/server/lib/trace/tracer.ts"],"sourcesContent":["import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api')\n  } catch (err) {\n    api = require('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.includes(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    let isRootSpan = false\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n      isRootSpan = true\n    } else if (trace.getSpanContext(spanContext)?.isRemote) {\n      isRootSpan = true\n    }\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          const startTime =\n            'performance' in globalThis && 'measure' in performance\n              ? globalThis.performance.now()\n              : undefined\n\n          const onCleanup = () => {\n            rootSpanAttributesStore.delete(spanId)\n            if (\n              startTime &&\n              process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&\n              LogSpanAllowList.includes(type || ('' as any))\n            ) {\n              performance.measure(\n                `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          try {\n            if (fn.length > 1) {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            }\n\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.includes(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes) {\n      attributes.set(key, value)\n    }\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}