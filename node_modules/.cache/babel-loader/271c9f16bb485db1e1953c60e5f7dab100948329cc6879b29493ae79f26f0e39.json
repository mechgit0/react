{"ast":null,"code":"'use strict';\n\nconst Registry = require('./registry');\nconst {\n  isObject\n} = require('./util');\nconst {\n  validateMetricName,\n  validateLabelName\n} = require('./validation');\n\n/**\n * @abstract\n */\nclass Metric {\n  constructor(config) {\n    let defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isObject(config)) {\n      throw new TypeError('constructor expected a config object');\n    }\n    Object.assign(this, {\n      labelNames: [],\n      registers: [Registry.globalRegistry],\n      aggregator: 'sum',\n      enableExemplars: false\n    }, defaults, config);\n    if (!this.registers) {\n      // in case config.registers is `undefined`\n      this.registers = [Registry.globalRegistry];\n    }\n    if (!this.help) {\n      throw new Error('Missing mandatory help parameter');\n    }\n    if (!this.name) {\n      throw new Error('Missing mandatory name parameter');\n    }\n    if (!validateMetricName(this.name)) {\n      throw new Error('Invalid metric name');\n    }\n    if (!validateLabelName(this.labelNames)) {\n      throw new Error('Invalid label name');\n    }\n    if (this.collect && typeof this.collect !== 'function') {\n      throw new Error('Optional \"collect\" parameter must be a function');\n    }\n    if (this.labelNames) {\n      this.sortedLabelNames = [...this.labelNames].sort();\n    } else {\n      this.sortedLabelNames = [];\n    }\n    this.reset();\n    for (const register of this.registers) {\n      if (this.enableExemplars && register.contentType === Registry.PROMETHEUS_CONTENT_TYPE) {\n        throw new TypeError('Exemplars are supported only on OpenMetrics registries');\n      }\n      register.registerMetric(this);\n    }\n  }\n  reset() {\n    /* abstract */\n  }\n}\nmodule.exports = {\n  Metric\n};","map":{"version":3,"names":["Registry","require","isObject","validateMetricName","validateLabelName","Metric","constructor","config","defaults","arguments","length","undefined","TypeError","Object","assign","labelNames","registers","globalRegistry","aggregator","enableExemplars","help","Error","name","collect","sortedLabelNames","sort","reset","register","contentType","PROMETHEUS_CONTENT_TYPE","registerMetric","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/metric.js"],"sourcesContent":["'use strict';\n\nconst Registry = require('./registry');\nconst { isObject } = require('./util');\nconst { validateMetricName, validateLabelName } = require('./validation');\n\n/**\n * @abstract\n */\nclass Metric {\n\tconstructor(config, defaults = {}) {\n\t\tif (!isObject(config)) {\n\t\t\tthrow new TypeError('constructor expected a config object');\n\t\t}\n\t\tObject.assign(\n\t\t\tthis,\n\t\t\t{\n\t\t\t\tlabelNames: [],\n\t\t\t\tregisters: [Registry.globalRegistry],\n\t\t\t\taggregator: 'sum',\n\t\t\t\tenableExemplars: false,\n\t\t\t},\n\t\t\tdefaults,\n\t\t\tconfig,\n\t\t);\n\t\tif (!this.registers) {\n\t\t\t// in case config.registers is `undefined`\n\t\t\tthis.registers = [Registry.globalRegistry];\n\t\t}\n\t\tif (!this.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!this.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(this.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\t\tif (!validateLabelName(this.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tif (this.collect && typeof this.collect !== 'function') {\n\t\t\tthrow new Error('Optional \"collect\" parameter must be a function');\n\t\t}\n\n\t\tif (this.labelNames) {\n\t\t\tthis.sortedLabelNames = [...this.labelNames].sort();\n\t\t} else {\n\t\t\tthis.sortedLabelNames = [];\n\t\t}\n\n\t\tthis.reset();\n\n\t\tfor (const register of this.registers) {\n\t\t\tif (\n\t\t\t\tthis.enableExemplars &&\n\t\t\t\tregister.contentType === Registry.PROMETHEUS_CONTENT_TYPE\n\t\t\t) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'Exemplars are supported only on OpenMetrics registries',\n\t\t\t\t);\n\t\t\t}\n\t\t\tregister.registerMetric(this);\n\t\t}\n\t}\n\n\treset() {\n\t\t/* abstract */\n\t}\n}\n\nmodule.exports = { Metric };\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,YAAY,CAAC;AACtC,MAAM;EAAEC;AAAS,CAAC,GAAGD,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAM;EAAEE,kBAAkB;EAAEC;AAAkB,CAAC,GAAGH,OAAO,CAAC,cAAc,CAAC;;AAEzE;AACA;AACA;AACA,MAAMI,MAAM,CAAC;EACZC,WAAWA,CAACC,MAAM,EAAiB;IAAA,IAAfC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAChC,IAAI,CAACP,QAAQ,CAACK,MAAM,CAAC,EAAE;MACtB,MAAM,IAAIK,SAAS,CAAC,sCAAsC,CAAC;IAC5D;IACAC,MAAM,CAACC,MAAM,CACZ,IAAI,EACJ;MACCC,UAAU,EAAE,EAAE;MACdC,SAAS,EAAE,CAAChB,QAAQ,CAACiB,cAAc,CAAC;MACpCC,UAAU,EAAE,KAAK;MACjBC,eAAe,EAAE;IAClB,CAAC,EACDX,QAAQ,EACRD,MACD,CAAC;IACD,IAAI,CAAC,IAAI,CAACS,SAAS,EAAE;MACpB;MACA,IAAI,CAACA,SAAS,GAAG,CAAChB,QAAQ,CAACiB,cAAc,CAAC;IAC3C;IACA,IAAI,CAAC,IAAI,CAACG,IAAI,EAAE;MACf,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;IACpD;IACA,IAAI,CAAC,IAAI,CAACC,IAAI,EAAE;MACf,MAAM,IAAID,KAAK,CAAC,kCAAkC,CAAC;IACpD;IACA,IAAI,CAAClB,kBAAkB,CAAC,IAAI,CAACmB,IAAI,CAAC,EAAE;MACnC,MAAM,IAAID,KAAK,CAAC,qBAAqB,CAAC;IACvC;IACA,IAAI,CAACjB,iBAAiB,CAAC,IAAI,CAACW,UAAU,CAAC,EAAE;MACxC,MAAM,IAAIM,KAAK,CAAC,oBAAoB,CAAC;IACtC;IAEA,IAAI,IAAI,CAACE,OAAO,IAAI,OAAO,IAAI,CAACA,OAAO,KAAK,UAAU,EAAE;MACvD,MAAM,IAAIF,KAAK,CAAC,iDAAiD,CAAC;IACnE;IAEA,IAAI,IAAI,CAACN,UAAU,EAAE;MACpB,IAAI,CAACS,gBAAgB,GAAG,CAAC,GAAG,IAAI,CAACT,UAAU,CAAC,CAACU,IAAI,CAAC,CAAC;IACpD,CAAC,MAAM;MACN,IAAI,CAACD,gBAAgB,GAAG,EAAE;IAC3B;IAEA,IAAI,CAACE,KAAK,CAAC,CAAC;IAEZ,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAACX,SAAS,EAAE;MACtC,IACC,IAAI,CAACG,eAAe,IACpBQ,QAAQ,CAACC,WAAW,KAAK5B,QAAQ,CAAC6B,uBAAuB,EACxD;QACD,MAAM,IAAIjB,SAAS,CAClB,wDACD,CAAC;MACF;MACAe,QAAQ,CAACG,cAAc,CAAC,IAAI,CAAC;IAC9B;EACD;EAEAJ,KAAKA,CAAA,EAAG;IACP;EAAA;AAEF;AAEAK,MAAM,CAACC,OAAO,GAAG;EAAE3B;AAAO,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}