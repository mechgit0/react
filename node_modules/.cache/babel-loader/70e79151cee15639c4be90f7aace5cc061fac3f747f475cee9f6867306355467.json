{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getRequestHandlers: null,\n  startServer: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getRequestHandlers: function () {\n    return getRequestHandlers;\n  },\n  startServer: function () {\n    return startServer;\n  }\n});\nconst _getnetworkhost = require(\"../../lib/get-network-host\");\nrequire(\"../next\");\nrequire(\"../require-hook\");\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _v8 = /*#__PURE__*/_interop_require_default(require(\"v8\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _http = /*#__PURE__*/_interop_require_default(require(\"http\"));\nconst _https = /*#__PURE__*/_interop_require_default(require(\"https\"));\nconst _os = /*#__PURE__*/_interop_require_default(require(\"os\"));\nconst _watchpack = /*#__PURE__*/_interop_require_default(require(\"next/dist/compiled/watchpack\"));\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../../build/output/log\"));\nconst _debug = /*#__PURE__*/_interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _utils = require(\"./utils\");\nconst _formathostname = require(\"./format-hostname\");\nconst _routerserver = require(\"./router-server\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _appinfolog = require(\"./app-info-log\");\nconst _turbopackwarning = require(\"../../lib/turbopack-warning\");\nconst _trace = require(\"../../trace\");\nconst _ispostpone = require(\"./router-utils/is-postpone\");\nconst _isipv6 = require(\"./is-ipv6\");\nconst _asynccallbackset = require(\"./async-callback-set\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nif (performance.getEntriesByName('next-start').length === 0) {\n  performance.mark('next-start');\n}\nconst debug = (0, _debug.default)('next:start-server');\nlet startServerSpan;\nasync function getRequestHandlers(_ref) {\n  let {\n    dir,\n    port,\n    isDev,\n    onDevServerCleanup,\n    server,\n    hostname,\n    minimalMode,\n    keepAliveTimeout,\n    experimentalHttpsServer,\n    quiet\n  } = _ref;\n  return (0, _routerserver.initialize)({\n    dir,\n    port,\n    hostname,\n    onDevServerCleanup,\n    dev: isDev,\n    minimalMode,\n    server,\n    keepAliveTimeout,\n    experimentalHttpsServer,\n    startServerSpan,\n    quiet\n  });\n}\nasync function startServer(serverOptions) {\n  const {\n    dir,\n    isDev,\n    hostname,\n    minimalMode,\n    allowRetry,\n    keepAliveTimeout,\n    selfSignedCertificate\n  } = serverOptions;\n  let {\n    port\n  } = serverOptions;\n  process.title = `next-server (v${\"15.2.4\"})`;\n  let handlersReady = () => {};\n  let handlersError = () => {};\n  let handlersPromise = new Promise((resolve, reject) => {\n    handlersReady = resolve;\n    handlersError = reject;\n  });\n  let requestHandler = async (req, res) => {\n    if (handlersPromise) {\n      await handlersPromise;\n      return requestHandler(req, res);\n    }\n    throw Object.defineProperty(new Error('Invariant request handler was not setup'), \"__NEXT_ERROR_CODE\", {\n      value: \"E287\",\n      enumerable: false,\n      configurable: true\n    });\n  };\n  let upgradeHandler = async (req, socket, head) => {\n    if (handlersPromise) {\n      await handlersPromise;\n      return upgradeHandler(req, socket, head);\n    }\n    throw Object.defineProperty(new Error('Invariant upgrade handler was not setup'), \"__NEXT_ERROR_CODE\", {\n      value: \"E290\",\n      enumerable: false,\n      configurable: true\n    });\n  };\n  let nextServer;\n  // setup server listener as fast as possible\n  if (selfSignedCertificate && !isDev) {\n    throw Object.defineProperty(new Error('Using a self signed certificate is only supported with `next dev`.'), \"__NEXT_ERROR_CODE\", {\n      value: \"E128\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  async function requestListener(req, res) {\n    try {\n      if (handlersPromise) {\n        await handlersPromise;\n        handlersPromise = undefined;\n      }\n      await requestHandler(req, res);\n    } catch (err) {\n      res.statusCode = 500;\n      res.end('Internal Server Error');\n      _log.error(`Failed to handle request for ${req.url}`);\n      console.error(err);\n    } finally {\n      if (isDev) {\n        if (_v8.default.getHeapStatistics().used_heap_size > 0.8 * _v8.default.getHeapStatistics().heap_size_limit) {\n          _log.warn(`Server is approaching the used memory threshold, restarting...`);\n          (0, _trace.trace)('server-restart-close-to-memory-threshold', undefined, {\n            'memory.heapSizeLimit': String(_v8.default.getHeapStatistics().heap_size_limit),\n            'memory.heapUsed': String(_v8.default.getHeapStatistics().used_heap_size)\n          }).stop();\n          await (0, _trace.flushAllTraces)();\n          process.exit(_utils.RESTART_EXIT_CODE);\n        }\n      }\n    }\n  }\n  const server = selfSignedCertificate ? _https.default.createServer({\n    key: _fs.default.readFileSync(selfSignedCertificate.key),\n    cert: _fs.default.readFileSync(selfSignedCertificate.cert)\n  }, requestListener) : _http.default.createServer(requestListener);\n  if (keepAliveTimeout) {\n    server.keepAliveTimeout = keepAliveTimeout;\n  }\n  server.on('upgrade', async (req, socket, head) => {\n    try {\n      await upgradeHandler(req, socket, head);\n    } catch (err) {\n      socket.destroy();\n      _log.error(`Failed to handle request for ${req.url}`);\n      console.error(err);\n    }\n  });\n  let portRetryCount = 0;\n  server.on('error', err => {\n    if (allowRetry && port && isDev && err.code === 'EADDRINUSE' && portRetryCount < 10) {\n      _log.warn(`Port ${port} is in use, trying ${port + 1} instead.`);\n      port += 1;\n      portRetryCount += 1;\n      server.listen(port, hostname);\n    } else {\n      _log.error(`Failed to start server`);\n      console.error(err);\n      process.exit(1);\n    }\n  });\n  let cleanupListeners = isDev ? new _asynccallbackset.AsyncCallbackSet() : undefined;\n  await new Promise(resolve => {\n    server.on('listening', async () => {\n      const nodeDebugType = (0, _utils.getNodeDebugType)();\n      const addr = server.address();\n      const actualHostname = (0, _formathostname.formatHostname)(typeof addr === 'object' ? (addr == null ? void 0 : addr.address) || hostname || 'localhost' : addr);\n      const formattedHostname = !hostname || actualHostname === '0.0.0.0' ? 'localhost' : actualHostname === '[::]' ? '[::1]' : (0, _formathostname.formatHostname)(hostname);\n      port = typeof addr === 'object' ? (addr == null ? void 0 : addr.port) || port : port;\n      const networkHostname = hostname ?? (0, _getnetworkhost.getNetworkHost)((0, _isipv6.isIPv6)(actualHostname) ? 'IPv6' : 'IPv4');\n      const protocol = selfSignedCertificate ? 'https' : 'http';\n      const networkUrl = networkHostname ? `${protocol}://${(0, _formathostname.formatHostname)(networkHostname)}:${port}` : null;\n      const appUrl = `${protocol}://${formattedHostname}:${port}`;\n      if (nodeDebugType) {\n        const formattedDebugAddress = (0, _utils.getFormattedDebugAddress)();\n        _log.info(`the --${nodeDebugType} option was detected, the Next.js router server should be inspected at ${formattedDebugAddress}.`);\n      }\n      // Store the selected port to:\n      // - expose it to render workers\n      // - re-use it for automatic dev server restarts with a randomly selected port\n      process.env.PORT = port + '';\n      process.env.__NEXT_PRIVATE_ORIGIN = appUrl;\n      // Only load env and config in dev to for logging purposes\n      let envInfo;\n      let experimentalFeatures;\n      if (isDev) {\n        const startServerInfo = await (0, _appinfolog.getStartServerInfo)(dir, isDev);\n        envInfo = startServerInfo.envInfo;\n        experimentalFeatures = startServerInfo.experimentalFeatures;\n      }\n      (0, _appinfolog.logStartInfo)({\n        networkUrl,\n        appUrl,\n        envInfo,\n        experimentalFeatures,\n        maxExperimentalFeatures: 3\n      });\n      _log.event(`Starting...`);\n      try {\n        let cleanupStarted = false;\n        let closeUpgraded = null;\n        const cleanup = () => {\n          if (cleanupStarted) {\n            // We can get duplicate signals, e.g. when `ctrl+c` is used in an\n            // interactive shell (i.e. bash, zsh), the shell will recursively\n            // send SIGINT to children. The parent `next-dev` process will also\n            // send us SIGINT.\n            return;\n          }\n          cleanupStarted = true;\n          (async () => {\n            debug('start-server process cleanup');\n            // first, stop accepting new connections and finish pending requests,\n            // because they might affect `nextServer.close()` (e.g. by scheduling an `after`)\n            await new Promise(res => {\n              server.close(err => {\n                if (err) console.error(err);\n                res();\n              });\n              if (isDev) {\n                server.closeAllConnections();\n                closeUpgraded == null ? void 0 : closeUpgraded();\n              }\n            });\n            // now that no new requests can come in, clean up the rest\n            await Promise.all([nextServer == null ? void 0 : nextServer.close().catch(console.error), cleanupListeners == null ? void 0 : cleanupListeners.runAll().catch(console.error)]);\n            debug('start-server process cleanup finished');\n            process.exit(0);\n          })();\n        };\n        const exception = err => {\n          if ((0, _ispostpone.isPostpone)(err)) {\n            // React postpones that are unhandled might end up logged here but they're\n            // not really errors. They're just part of rendering.\n            return;\n          }\n          // This is the render worker, we keep the process alive\n          console.error(err);\n        };\n        // Make sure commands gracefully respect termination signals (e.g. from Docker)\n        // Allow the graceful termination to be manually configurable\n        if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n          process.on('SIGINT', cleanup);\n          process.on('SIGTERM', cleanup);\n        }\n        process.on('rejectionHandled', () => {\n          // It is ok to await a Promise late in Next.js as it allows for better\n          // prefetching patterns to avoid waterfalls. We ignore loggining these.\n          // We should've already errored in anyway unhandledRejection.\n        });\n        process.on('uncaughtException', exception);\n        process.on('unhandledRejection', exception);\n        const initResult = await getRequestHandlers({\n          dir,\n          port,\n          isDev,\n          onDevServerCleanup: cleanupListeners ? cleanupListeners.add.bind(cleanupListeners) : undefined,\n          server,\n          hostname,\n          minimalMode,\n          keepAliveTimeout,\n          experimentalHttpsServer: !!selfSignedCertificate\n        });\n        requestHandler = initResult.requestHandler;\n        upgradeHandler = initResult.upgradeHandler;\n        nextServer = initResult.server;\n        closeUpgraded = initResult.closeUpgraded;\n        const startServerProcessDuration = performance.mark('next-start-end') && performance.measure('next-start-duration', 'next-start', 'next-start-end').duration;\n        handlersReady();\n        const formatDurationText = startServerProcessDuration > 2000 ? `${Math.round(startServerProcessDuration / 100) / 10}s` : `${Math.round(startServerProcessDuration)}ms`;\n        _log.event(`Ready in ${formatDurationText}`);\n        if (process.env.TURBOPACK) {\n          await (0, _turbopackwarning.validateTurboNextConfig)({\n            dir: serverOptions.dir,\n            isDev: true\n          });\n        }\n      } catch (err) {\n        // fatal error if we can't setup\n        handlersError();\n        console.error(err);\n        process.exit(1);\n      }\n      resolve();\n    });\n    server.listen(port, hostname);\n  });\n  if (isDev) {\n    function watchConfigFiles(dirToWatch, onChange) {\n      const wp = new _watchpack.default();\n      wp.watch({\n        files: _constants.CONFIG_FILES.map(file => _path.default.join(dirToWatch, file))\n      });\n      wp.on('change', onChange);\n    }\n    watchConfigFiles(dir, async filename => {\n      if (process.env.__NEXT_DISABLE_MEMORY_WATCHER) {\n        _log.info(`Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`);\n        return;\n      }\n      _log.warn(`Found a change in ${_path.default.basename(filename)}. Restarting the server to apply the changes...`);\n      process.exit(_utils.RESTART_EXIT_CODE);\n    });\n  }\n}\nif (process.env.NEXT_PRIVATE_WORKER && process.send) {\n  process.addListener('message', async msg => {\n    if (msg && typeof msg === 'object' && msg.nextWorkerOptions && process.send) {\n      startServerSpan = (0, _trace.trace)('start-dev-server', undefined, {\n        cpus: String(_os.default.cpus().length),\n        platform: _os.default.platform(),\n        'memory.freeMem': String(_os.default.freemem()),\n        'memory.totalMem': String(_os.default.totalmem()),\n        'memory.heapSizeLimit': String(_v8.default.getHeapStatistics().heap_size_limit)\n      });\n      await startServerSpan.traceAsyncFn(() => startServer(msg.nextWorkerOptions));\n      const memoryUsage = process.memoryUsage();\n      startServerSpan.setAttribute('memory.rss', String(memoryUsage.rss));\n      startServerSpan.setAttribute('memory.heapTotal', String(memoryUsage.heapTotal));\n      startServerSpan.setAttribute('memory.heapUsed', String(memoryUsage.heapUsed));\n      process.send({\n        nextServerReady: true,\n        port: process.env.PORT\n      });\n    }\n  });\n  process.send({\n    nextWorkerReady: true\n  });\n}","map":{"version":3,"names":["getRequestHandlers","startServer","performance","getEntriesByName","length","mark","debug","_debug","default","startServerSpan","_ref","dir","port","isDev","onDevServerCleanup","server","hostname","minimalMode","keepAliveTimeout","experimentalHttpsServer","quiet","_routerserver","initialize","dev","serverOptions","allowRetry","selfSignedCertificate","process","title","handlersReady","handlersError","handlersPromise","Promise","resolve","reject","requestHandler","req","res","Object","defineProperty","Error","upgradeHandler","socket","head","nextServer","requestListener","undefined","err","statusCode","end","_log","error","url","console","_v8","getHeapStatistics","used_heap_size","heap_size_limit","warn","_trace","trace","String","stop","flushAllTraces","exit","_utils","RESTART_EXIT_CODE","_https","createServer","key","_fs","readFileSync","cert","_http","on","destroy","portRetryCount","code","listen","cleanupListeners","_asynccallbackset","AsyncCallbackSet","nodeDebugType","getNodeDebugType","addr","address","actualHostname","_formathostname","formatHostname","formattedHostname","networkHostname","_getnetworkhost","getNetworkHost","_isipv6","isIPv6","protocol","networkUrl","appUrl","formattedDebugAddress","getFormattedDebugAddress","info","env","PORT","__NEXT_PRIVATE_ORIGIN","envInfo","experimentalFeatures","startServerInfo","_appinfolog","getStartServerInfo","logStartInfo","maxExperimentalFeatures","event","cleanupStarted","closeUpgraded","cleanup","close","closeAllConnections","all","catch","runAll","exception","_ispostpone","isPostpone","NEXT_MANUAL_SIG_HANDLE","initResult","add","bind","startServerProcessDuration","measure","duration","formatDurationText","Math","round","TURBOPACK","_turbopackwarning","validateTurboNextConfig","watchConfigFiles","dirToWatch","onChange","wp","_watchpack","watch","files","_constants","CONFIG_FILES","map","file","_path","join","filename","__NEXT_DISABLE_MEMORY_WATCHER","basename","NEXT_PRIVATE_WORKER","send","addListener","msg","nextWorkerOptions","cpus","_os","platform","freemem","totalmem","traceAsyncFn","memoryUsage","setAttribute","rss","heapTotal","heapUsed","nextServerReady","nextWorkerReady"],"sources":["/home/ashish/my-react-app/node_modules/next/src/server/lib/start-server.ts"],"sourcesContent":["import { getNetworkHost } from '../../lib/get-network-host'\n\nif (performance.getEntriesByName('next-start').length === 0) {\n  performance.mark('next-start')\n}\nimport '../next'\nimport '../require-hook'\n\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { SelfSignedCertificate } from '../../lib/mkcert'\nimport type { WorkerRequestHandler, WorkerUpgradeHandler } from './types'\n\nimport fs from 'fs'\nimport v8 from 'v8'\nimport path from 'path'\nimport http from 'http'\nimport https from 'https'\nimport os from 'os'\nimport Watchpack from 'next/dist/compiled/watchpack'\nimport * as Log from '../../build/output/log'\nimport setupDebug from 'next/dist/compiled/debug'\nimport {\n  RESTART_EXIT_CODE,\n  getFormattedDebugAddress,\n  getNodeDebugType,\n} from './utils'\nimport { formatHostname } from './format-hostname'\nimport { initialize } from './router-server'\nimport { CONFIG_FILES } from '../../shared/lib/constants'\nimport { getStartServerInfo, logStartInfo } from './app-info-log'\nimport { validateTurboNextConfig } from '../../lib/turbopack-warning'\nimport { type Span, trace, flushAllTraces } from '../../trace'\nimport { isPostpone } from './router-utils/is-postpone'\nimport { isIPv6 } from './is-ipv6'\nimport { AsyncCallbackSet } from './async-callback-set'\nimport type { NextServer } from '../next'\nimport type { ConfiguredExperimentalFeature } from '../config'\n\nconst debug = setupDebug('next:start-server')\nlet startServerSpan: Span | undefined\n\nexport interface StartServerOptions {\n  dir: string\n  port: number\n  isDev: boolean\n  hostname?: string\n  allowRetry?: boolean\n  customServer?: boolean\n  minimalMode?: boolean\n  keepAliveTimeout?: number\n  // this is dev-server only\n  selfSignedCertificate?: SelfSignedCertificate\n}\n\nexport async function getRequestHandlers({\n  dir,\n  port,\n  isDev,\n  onDevServerCleanup,\n  server,\n  hostname,\n  minimalMode,\n  keepAliveTimeout,\n  experimentalHttpsServer,\n  quiet,\n}: {\n  dir: string\n  port: number\n  isDev: boolean\n  onDevServerCleanup: ((listener: () => Promise<void>) => void) | undefined\n  server?: import('http').Server\n  hostname?: string\n  minimalMode?: boolean\n  keepAliveTimeout?: number\n  experimentalHttpsServer?: boolean\n  quiet?: boolean\n}): ReturnType<typeof initialize> {\n  return initialize({\n    dir,\n    port,\n    hostname,\n    onDevServerCleanup,\n    dev: isDev,\n    minimalMode,\n    server,\n    keepAliveTimeout,\n    experimentalHttpsServer,\n    startServerSpan,\n    quiet,\n  })\n}\n\nexport async function startServer(\n  serverOptions: StartServerOptions\n): Promise<void> {\n  const {\n    dir,\n    isDev,\n    hostname,\n    minimalMode,\n    allowRetry,\n    keepAliveTimeout,\n    selfSignedCertificate,\n  } = serverOptions\n  let { port } = serverOptions\n\n  process.title = `next-server (v${process.env.__NEXT_VERSION})`\n  let handlersReady = () => {}\n  let handlersError = () => {}\n\n  let handlersPromise: Promise<void> | undefined = new Promise<void>(\n    (resolve, reject) => {\n      handlersReady = resolve\n      handlersError = reject\n    }\n  )\n  let requestHandler: WorkerRequestHandler = async (\n    req: IncomingMessage,\n    res: ServerResponse\n  ): Promise<void> => {\n    if (handlersPromise) {\n      await handlersPromise\n      return requestHandler(req, res)\n    }\n    throw new Error('Invariant request handler was not setup')\n  }\n  let upgradeHandler: WorkerUpgradeHandler = async (\n    req,\n    socket,\n    head\n  ): Promise<void> => {\n    if (handlersPromise) {\n      await handlersPromise\n      return upgradeHandler(req, socket, head)\n    }\n    throw new Error('Invariant upgrade handler was not setup')\n  }\n\n  let nextServer: NextServer | undefined\n\n  // setup server listener as fast as possible\n  if (selfSignedCertificate && !isDev) {\n    throw new Error(\n      'Using a self signed certificate is only supported with `next dev`.'\n    )\n  }\n\n  async function requestListener(req: IncomingMessage, res: ServerResponse) {\n    try {\n      if (handlersPromise) {\n        await handlersPromise\n        handlersPromise = undefined\n      }\n      await requestHandler(req, res)\n    } catch (err) {\n      res.statusCode = 500\n      res.end('Internal Server Error')\n      Log.error(`Failed to handle request for ${req.url}`)\n      console.error(err)\n    } finally {\n      if (isDev) {\n        if (\n          v8.getHeapStatistics().used_heap_size >\n          0.8 * v8.getHeapStatistics().heap_size_limit\n        ) {\n          Log.warn(\n            `Server is approaching the used memory threshold, restarting...`\n          )\n          trace('server-restart-close-to-memory-threshold', undefined, {\n            'memory.heapSizeLimit': String(\n              v8.getHeapStatistics().heap_size_limit\n            ),\n            'memory.heapUsed': String(v8.getHeapStatistics().used_heap_size),\n          }).stop()\n          await flushAllTraces()\n          process.exit(RESTART_EXIT_CODE)\n        }\n      }\n    }\n  }\n\n  const server = selfSignedCertificate\n    ? https.createServer(\n        {\n          key: fs.readFileSync(selfSignedCertificate.key),\n          cert: fs.readFileSync(selfSignedCertificate.cert),\n        },\n        requestListener\n      )\n    : http.createServer(requestListener)\n\n  if (keepAliveTimeout) {\n    server.keepAliveTimeout = keepAliveTimeout\n  }\n  server.on('upgrade', async (req, socket, head) => {\n    try {\n      await upgradeHandler(req, socket, head)\n    } catch (err) {\n      socket.destroy()\n      Log.error(`Failed to handle request for ${req.url}`)\n      console.error(err)\n    }\n  })\n\n  let portRetryCount = 0\n\n  server.on('error', (err: NodeJS.ErrnoException) => {\n    if (\n      allowRetry &&\n      port &&\n      isDev &&\n      err.code === 'EADDRINUSE' &&\n      portRetryCount < 10\n    ) {\n      Log.warn(`Port ${port} is in use, trying ${port + 1} instead.`)\n      port += 1\n      portRetryCount += 1\n      server.listen(port, hostname)\n    } else {\n      Log.error(`Failed to start server`)\n      console.error(err)\n      process.exit(1)\n    }\n  })\n\n  let cleanupListeners = isDev ? new AsyncCallbackSet() : undefined\n\n  await new Promise<void>((resolve) => {\n    server.on('listening', async () => {\n      const nodeDebugType = getNodeDebugType()\n\n      const addr = server.address()\n      const actualHostname = formatHostname(\n        typeof addr === 'object'\n          ? addr?.address || hostname || 'localhost'\n          : addr\n      )\n      const formattedHostname =\n        !hostname || actualHostname === '0.0.0.0'\n          ? 'localhost'\n          : actualHostname === '[::]'\n            ? '[::1]'\n            : formatHostname(hostname)\n\n      port = typeof addr === 'object' ? addr?.port || port : port\n\n      const networkHostname =\n        hostname ?? getNetworkHost(isIPv6(actualHostname) ? 'IPv6' : 'IPv4')\n\n      const protocol = selfSignedCertificate ? 'https' : 'http'\n\n      const networkUrl = networkHostname\n        ? `${protocol}://${formatHostname(networkHostname)}:${port}`\n        : null\n\n      const appUrl = `${protocol}://${formattedHostname}:${port}`\n\n      if (nodeDebugType) {\n        const formattedDebugAddress = getFormattedDebugAddress()\n        Log.info(\n          `the --${nodeDebugType} option was detected, the Next.js router server should be inspected at ${formattedDebugAddress}.`\n        )\n      }\n\n      // Store the selected port to:\n      // - expose it to render workers\n      // - re-use it for automatic dev server restarts with a randomly selected port\n      process.env.PORT = port + ''\n\n      process.env.__NEXT_PRIVATE_ORIGIN = appUrl\n\n      // Only load env and config in dev to for logging purposes\n      let envInfo: string[] | undefined\n      let experimentalFeatures: ConfiguredExperimentalFeature[] | undefined\n      if (isDev) {\n        const startServerInfo = await getStartServerInfo(dir, isDev)\n        envInfo = startServerInfo.envInfo\n        experimentalFeatures = startServerInfo.experimentalFeatures\n      }\n      logStartInfo({\n        networkUrl,\n        appUrl,\n        envInfo,\n        experimentalFeatures,\n        maxExperimentalFeatures: 3,\n      })\n\n      Log.event(`Starting...`)\n\n      try {\n        let cleanupStarted = false\n        let closeUpgraded: (() => void) | null = null\n        const cleanup = () => {\n          if (cleanupStarted) {\n            // We can get duplicate signals, e.g. when `ctrl+c` is used in an\n            // interactive shell (i.e. bash, zsh), the shell will recursively\n            // send SIGINT to children. The parent `next-dev` process will also\n            // send us SIGINT.\n            return\n          }\n          cleanupStarted = true\n          ;(async () => {\n            debug('start-server process cleanup')\n\n            // first, stop accepting new connections and finish pending requests,\n            // because they might affect `nextServer.close()` (e.g. by scheduling an `after`)\n            await new Promise<void>((res) => {\n              server.close((err) => {\n                if (err) console.error(err)\n                res()\n              })\n              if (isDev) {\n                server.closeAllConnections()\n                closeUpgraded?.()\n              }\n            })\n\n            // now that no new requests can come in, clean up the rest\n            await Promise.all([\n              nextServer?.close().catch(console.error),\n              cleanupListeners?.runAll().catch(console.error),\n            ])\n\n            debug('start-server process cleanup finished')\n            process.exit(0)\n          })()\n        }\n        const exception = (err: Error) => {\n          if (isPostpone(err)) {\n            // React postpones that are unhandled might end up logged here but they're\n            // not really errors. They're just part of rendering.\n            return\n          }\n\n          // This is the render worker, we keep the process alive\n          console.error(err)\n        }\n        // Make sure commands gracefully respect termination signals (e.g. from Docker)\n        // Allow the graceful termination to be manually configurable\n        if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n          process.on('SIGINT', cleanup)\n          process.on('SIGTERM', cleanup)\n        }\n        process.on('rejectionHandled', () => {\n          // It is ok to await a Promise late in Next.js as it allows for better\n          // prefetching patterns to avoid waterfalls. We ignore loggining these.\n          // We should've already errored in anyway unhandledRejection.\n        })\n        process.on('uncaughtException', exception)\n        process.on('unhandledRejection', exception)\n\n        const initResult = await getRequestHandlers({\n          dir,\n          port,\n          isDev,\n          onDevServerCleanup: cleanupListeners\n            ? cleanupListeners.add.bind(cleanupListeners)\n            : undefined,\n          server,\n          hostname,\n          minimalMode,\n          keepAliveTimeout,\n          experimentalHttpsServer: !!selfSignedCertificate,\n        })\n        requestHandler = initResult.requestHandler\n        upgradeHandler = initResult.upgradeHandler\n        nextServer = initResult.server\n        closeUpgraded = initResult.closeUpgraded\n\n        const startServerProcessDuration =\n          performance.mark('next-start-end') &&\n          performance.measure(\n            'next-start-duration',\n            'next-start',\n            'next-start-end'\n          ).duration\n\n        handlersReady()\n        const formatDurationText =\n          startServerProcessDuration > 2000\n            ? `${Math.round(startServerProcessDuration / 100) / 10}s`\n            : `${Math.round(startServerProcessDuration)}ms`\n\n        Log.event(`Ready in ${formatDurationText}`)\n\n        if (process.env.TURBOPACK) {\n          await validateTurboNextConfig({\n            dir: serverOptions.dir,\n            isDev: true,\n          })\n        }\n      } catch (err) {\n        // fatal error if we can't setup\n        handlersError()\n        console.error(err)\n        process.exit(1)\n      }\n\n      resolve()\n    })\n    server.listen(port, hostname)\n  })\n\n  if (isDev) {\n    function watchConfigFiles(\n      dirToWatch: string,\n      onChange: (filename: string) => void\n    ) {\n      const wp = new Watchpack()\n      wp.watch({\n        files: CONFIG_FILES.map((file) => path.join(dirToWatch, file)),\n      })\n      wp.on('change', onChange)\n    }\n    watchConfigFiles(dir, async (filename) => {\n      if (process.env.__NEXT_DISABLE_MEMORY_WATCHER) {\n        Log.info(\n          `Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`\n        )\n        return\n      }\n\n      Log.warn(\n        `Found a change in ${path.basename(\n          filename\n        )}. Restarting the server to apply the changes...`\n      )\n      process.exit(RESTART_EXIT_CODE)\n    })\n  }\n}\n\nif (process.env.NEXT_PRIVATE_WORKER && process.send) {\n  process.addListener('message', async (msg: any) => {\n    if (\n      msg &&\n      typeof msg === 'object' &&\n      msg.nextWorkerOptions &&\n      process.send\n    ) {\n      startServerSpan = trace('start-dev-server', undefined, {\n        cpus: String(os.cpus().length),\n        platform: os.platform(),\n        'memory.freeMem': String(os.freemem()),\n        'memory.totalMem': String(os.totalmem()),\n        'memory.heapSizeLimit': String(v8.getHeapStatistics().heap_size_limit),\n      })\n      await startServerSpan.traceAsyncFn(() =>\n        startServer(msg.nextWorkerOptions)\n      )\n      const memoryUsage = process.memoryUsage()\n      startServerSpan.setAttribute('memory.rss', String(memoryUsage.rss))\n      startServerSpan.setAttribute(\n        'memory.heapTotal',\n        String(memoryUsage.heapTotal)\n      )\n      startServerSpan.setAttribute(\n        'memory.heapUsed',\n        String(memoryUsage.heapUsed)\n      )\n      process.send({ nextServerReady: true, port: process.env.PORT })\n    }\n  })\n  process.send({ nextWorkerReady: true })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}