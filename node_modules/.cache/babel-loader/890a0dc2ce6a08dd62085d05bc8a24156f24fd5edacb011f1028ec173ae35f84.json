{"ast":null,"code":"/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst {\n  getLabels,\n  hashObject,\n  removeLabels\n} = require('./util');\nconst {\n  validateLabel\n} = require('./validation');\nconst {\n  Metric\n} = require('./metric');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\nconst DEFAULT_COMPRESS_COUNT = 1000; // every 1000 measurements\n\nclass Summary extends Metric {\n  constructor(config) {\n    super(config, {\n      percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n      compressCount: DEFAULT_COMPRESS_COUNT,\n      hashMap: {}\n    });\n    this.type = 'summary';\n    for (const label of this.labelNames) {\n      if (label === 'quantile') throw new Error('quantile is a reserved label keyword');\n    }\n    if (this.labelNames.length === 0) {\n      this.hashMap = {\n        [hashObject({})]: {\n          labels: {},\n          td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n          count: 0,\n          sum: 0\n        }\n      };\n    }\n  }\n\n  /**\n   * Observe a value\n   * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n   * @param {Number} value - Value to observe\n   * @returns {void}\n   */\n  observe(labels, value) {\n    observe.call(this, labels === 0 ? 0 : labels || {})(value);\n  }\n  async get() {\n    if (this.collect) {\n      const v = this.collect();\n      if (v instanceof Promise) await v;\n    }\n    const hashKeys = Object.keys(this.hashMap);\n    const values = [];\n    hashKeys.forEach(hashKey => {\n      const s = this.hashMap[hashKey];\n      if (s) {\n        if (this.pruneAgedBuckets && s.td.size() === 0) {\n          delete this.hashMap[hashKey];\n        } else {\n          extractSummariesForExport(s, this.percentiles).forEach(v => {\n            values.push(v);\n          });\n          values.push(getSumForExport(s, this));\n          values.push(getCountForExport(s, this));\n        }\n      }\n    });\n    return {\n      name: this.name,\n      help: this.help,\n      type: this.type,\n      values,\n      aggregator: this.aggregator\n    };\n  }\n  reset() {\n    const data = Object.values(this.hashMap);\n    data.forEach(s => {\n      s.td.reset();\n      s.count = 0;\n      s.sum = 0;\n    });\n  }\n\n  /**\n   * Start a timer that could be used to logging durations\n   * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n   * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n   * @example\n   * var end = summary.startTimer();\n   * makeExpensiveXHRRequest(function(err, res) {\n   *\tend(); //Observe the duration of expensiveXHRRequest\n   * });\n   */\n  startTimer(labels) {\n    return startTimer.call(this, labels)();\n  }\n  labels() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const labels = getLabels(this.labelNames, args);\n    validateLabel(this.labelNames, labels);\n    return {\n      observe: observe.call(this, labels),\n      startTimer: startTimer.call(this, labels)\n    };\n  }\n  remove() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const labels = getLabels(this.labelNames, args);\n    validateLabel(this.labelNames, labels);\n    removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n  }\n}\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n  summaryOfLabels.td.compress();\n  return percentiles.map(percentile => {\n    const percentileValue = summaryOfLabels.td.percentile(percentile);\n    return {\n      labels: Object.assign({\n        quantile: percentile\n      }, summaryOfLabels.labels),\n      value: percentileValue ? percentileValue : 0\n    };\n  });\n}\nfunction getCountForExport(value, summary) {\n  return {\n    metricName: `${summary.name}_count`,\n    labels: value.labels,\n    value: value.count\n  };\n}\nfunction getSumForExport(value, summary) {\n  return {\n    metricName: `${summary.name}_sum`,\n    labels: value.labels,\n    value: value.sum\n  };\n}\nfunction startTimer(startLabels) {\n  return () => {\n    const start = process.hrtime();\n    return endLabels => {\n      const delta = process.hrtime(start);\n      const value = delta[0] + delta[1] / 1e9;\n      this.observe(Object.assign({}, startLabels, endLabels), value);\n      return value;\n    };\n  };\n}\nfunction observe(labels) {\n  return value => {\n    const labelValuePair = convertLabelsAndValues(labels, value);\n    validateLabel(this.labelNames, labels);\n    if (!Number.isFinite(labelValuePair.value)) {\n      throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);\n    }\n    const hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n    let summaryOfLabel = this.hashMap[hash];\n    if (!summaryOfLabel) {\n      summaryOfLabel = {\n        labels: labelValuePair.labels,\n        td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n        count: 0,\n        sum: 0\n      };\n    }\n    summaryOfLabel.td.push(labelValuePair.value);\n    summaryOfLabel.count++;\n    if (summaryOfLabel.count % this.compressCount === 0) {\n      summaryOfLabel.td.compress();\n    }\n    summaryOfLabel.sum += labelValuePair.value;\n    this.hashMap[hash] = summaryOfLabel;\n  };\n}\nfunction convertLabelsAndValues(labels, value) {\n  if (value === undefined) {\n    return {\n      value: labels,\n      labels: {}\n    };\n  }\n  return {\n    labels,\n    value\n  };\n}\nmodule.exports = Summary;","map":{"version":3,"names":["util","require","getLabels","hashObject","removeLabels","validateLabel","Metric","timeWindowQuantiles","DEFAULT_COMPRESS_COUNT","Summary","constructor","config","percentiles","compressCount","hashMap","type","label","labelNames","Error","length","labels","td","maxAgeSeconds","ageBuckets","count","sum","observe","value","call","get","collect","v","Promise","hashKeys","Object","keys","values","forEach","hashKey","s","pruneAgedBuckets","size","extractSummariesForExport","push","getSumForExport","getCountForExport","name","help","aggregator","reset","data","startTimer","_len","arguments","args","Array","_key","remove","_len2","_key2","sortedLabelNames","summaryOfLabels","compress","map","percentile","percentileValue","assign","quantile","summary","metricName","startLabels","start","process","hrtime","endLabels","delta","labelValuePair","convertLabelsAndValues","Number","isFinite","TypeError","format","hash","summaryOfLabel","undefined","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/summary.js"],"sourcesContent":["/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst { getLabels, hashObject, removeLabels } = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\n\nconst DEFAULT_COMPRESS_COUNT = 1000; // every 1000 measurements\n\nclass Summary extends Metric {\n\tconstructor(config) {\n\t\tsuper(config, {\n\t\t\tpercentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n\t\t\tcompressCount: DEFAULT_COMPRESS_COUNT,\n\t\t\thashMap: {},\n\t\t});\n\n\t\tthis.type = 'summary';\n\n\t\tfor (const label of this.labelNames) {\n\t\t\tif (label === 'quantile')\n\t\t\t\tthrow new Error('quantile is a reserved label keyword');\n\t\t}\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: {\n\t\t\t\t\tlabels: {},\n\t\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Observe a value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tasync get() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\t\tconst hashKeys = Object.keys(this.hashMap);\n\t\tconst values = [];\n\n\t\thashKeys.forEach(hashKey => {\n\t\t\tconst s = this.hashMap[hashKey];\n\t\t\tif (s) {\n\t\t\t\tif (this.pruneAgedBuckets && s.td.size() === 0) {\n\t\t\t\t\tdelete this.hashMap[hashKey];\n\t\t\t\t} else {\n\t\t\t\t\textractSummariesForExport(s, this.percentiles).forEach(v => {\n\t\t\t\t\t\tvalues.push(v);\n\t\t\t\t\t});\n\t\t\t\t\tvalues.push(getSumForExport(s, this));\n\t\t\t\t\tvalues.push(getCountForExport(s, this));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype: this.type,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\treset() {\n\t\tconst data = Object.values(this.hashMap);\n\t\tdata.forEach(s => {\n\t\t\ts.td.reset();\n\t\t\ts.count = 0;\n\t\t\ts.sum = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = summary.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tremoveLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n\tsummaryOfLabels.td.compress();\n\n\treturn percentiles.map(percentile => {\n\t\tconst percentileValue = summaryOfLabels.td.percentile(percentile);\n\t\treturn {\n\t\t\tlabels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),\n\t\t\tvalue: percentileValue ? percentileValue : 0,\n\t\t};\n\t});\n}\n\nfunction getCountForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_count`,\n\t\tlabels: value.labels,\n\t\tvalue: value.count,\n\t};\n}\n\nfunction getSumForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_sum`,\n\t\tlabels: value.labels,\n\t\tvalue: value.sum,\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe(Object.assign({}, startLabels, endLabels), value);\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`,\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n\t\tlet summaryOfLabel = this.hashMap[hash];\n\t\tif (!summaryOfLabel) {\n\t\t\tsummaryOfLabel = {\n\t\t\t\tlabels: labelValuePair.labels,\n\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\tcount: 0,\n\t\t\t\tsum: 0,\n\t\t\t};\n\t\t}\n\n\t\tsummaryOfLabel.td.push(labelValuePair.value);\n\t\tsummaryOfLabel.count++;\n\t\tif (summaryOfLabel.count % this.compressCount === 0) {\n\t\t\tsummaryOfLabel.td.compress();\n\t\t}\n\t\tsummaryOfLabel.sum += labelValuePair.value;\n\t\tthis.hashMap[hash] = summaryOfLabel;\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (value === undefined) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {},\n\t\t};\n\t}\n\n\treturn {\n\t\tlabels,\n\t\tvalue,\n\t};\n}\n\nmodule.exports = Summary;\n"],"mappings":"AAAA;AACA;AACA;AACA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAM;EAAEC,SAAS;EAAEC,UAAU;EAAEC;AAAa,CAAC,GAAGH,OAAO,CAAC,QAAQ,CAAC;AACjE,MAAM;EAAEI;AAAc,CAAC,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACjD,MAAM;EAAEK;AAAO,CAAC,GAAGL,OAAO,CAAC,UAAU,CAAC;AACtC,MAAMM,mBAAmB,GAAGN,OAAO,CAAC,uBAAuB,CAAC;AAE5D,MAAMO,sBAAsB,GAAG,IAAI,CAAC,CAAC;;AAErC,MAAMC,OAAO,SAASH,MAAM,CAAC;EAC5BI,WAAWA,CAACC,MAAM,EAAE;IACnB,KAAK,CAACA,MAAM,EAAE;MACbC,WAAW,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;MACtDC,aAAa,EAAEL,sBAAsB;MACrCM,OAAO,EAAE,CAAC;IACX,CAAC,CAAC;IAEF,IAAI,CAACC,IAAI,GAAG,SAAS;IAErB,KAAK,MAAMC,KAAK,IAAI,IAAI,CAACC,UAAU,EAAE;MACpC,IAAID,KAAK,KAAK,UAAU,EACvB,MAAM,IAAIE,KAAK,CAAC,sCAAsC,CAAC;IACzD;IAEA,IAAI,IAAI,CAACD,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MACjC,IAAI,CAACL,OAAO,GAAG;QACd,CAACX,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG;UACjBiB,MAAM,EAAE,CAAC,CAAC;UACVC,EAAE,EAAE,IAAId,mBAAmB,CAAC,IAAI,CAACe,aAAa,EAAE,IAAI,CAACC,UAAU,CAAC;UAChEC,KAAK,EAAE,CAAC;UACRC,GAAG,EAAE;QACN;MACD,CAAC;IACF;EACD;;EAEA;AACD;AACA;AACA;AACA;AACA;EACCC,OAAOA,CAACN,MAAM,EAAEO,KAAK,EAAE;IACtBD,OAAO,CAACE,IAAI,CAAC,IAAI,EAAER,MAAM,KAAK,CAAC,GAAG,CAAC,GAAGA,MAAM,IAAI,CAAC,CAAC,CAAC,CAACO,KAAK,CAAC;EAC3D;EAEA,MAAME,GAAGA,CAAA,EAAG;IACX,IAAI,IAAI,CAACC,OAAO,EAAE;MACjB,MAAMC,CAAC,GAAG,IAAI,CAACD,OAAO,CAAC,CAAC;MACxB,IAAIC,CAAC,YAAYC,OAAO,EAAE,MAAMD,CAAC;IAClC;IACA,MAAME,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACrB,OAAO,CAAC;IAC1C,MAAMsB,MAAM,GAAG,EAAE;IAEjBH,QAAQ,CAACI,OAAO,CAACC,OAAO,IAAI;MAC3B,MAAMC,CAAC,GAAG,IAAI,CAACzB,OAAO,CAACwB,OAAO,CAAC;MAC/B,IAAIC,CAAC,EAAE;QACN,IAAI,IAAI,CAACC,gBAAgB,IAAID,CAAC,CAAClB,EAAE,CAACoB,IAAI,CAAC,CAAC,KAAK,CAAC,EAAE;UAC/C,OAAO,IAAI,CAAC3B,OAAO,CAACwB,OAAO,CAAC;QAC7B,CAAC,MAAM;UACNI,yBAAyB,CAACH,CAAC,EAAE,IAAI,CAAC3B,WAAW,CAAC,CAACyB,OAAO,CAACN,CAAC,IAAI;YAC3DK,MAAM,CAACO,IAAI,CAACZ,CAAC,CAAC;UACf,CAAC,CAAC;UACFK,MAAM,CAACO,IAAI,CAACC,eAAe,CAACL,CAAC,EAAE,IAAI,CAAC,CAAC;UACrCH,MAAM,CAACO,IAAI,CAACE,iBAAiB,CAACN,CAAC,EAAE,IAAI,CAAC,CAAC;QACxC;MACD;IACD,CAAC,CAAC;IAEF,OAAO;MACNO,IAAI,EAAE,IAAI,CAACA,IAAI;MACfC,IAAI,EAAE,IAAI,CAACA,IAAI;MACfhC,IAAI,EAAE,IAAI,CAACA,IAAI;MACfqB,MAAM;MACNY,UAAU,EAAE,IAAI,CAACA;IAClB,CAAC;EACF;EAEAC,KAAKA,CAAA,EAAG;IACP,MAAMC,IAAI,GAAGhB,MAAM,CAACE,MAAM,CAAC,IAAI,CAACtB,OAAO,CAAC;IACxCoC,IAAI,CAACb,OAAO,CAACE,CAAC,IAAI;MACjBA,CAAC,CAAClB,EAAE,CAAC4B,KAAK,CAAC,CAAC;MACZV,CAAC,CAACf,KAAK,GAAG,CAAC;MACXe,CAAC,CAACd,GAAG,GAAG,CAAC;IACV,CAAC,CAAC;EACH;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC0B,UAAUA,CAAC/B,MAAM,EAAE;IAClB,OAAO+B,UAAU,CAACvB,IAAI,CAAC,IAAI,EAAER,MAAM,CAAC,CAAC,CAAC;EACvC;EAEAA,MAAMA,CAAA,EAAU;IAAA,SAAAgC,IAAA,GAAAC,SAAA,CAAAlC,MAAA,EAANmC,IAAI,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;MAAJF,IAAI,CAAAE,IAAA,IAAAH,SAAA,CAAAG,IAAA;IAAA;IACb,MAAMpC,MAAM,GAAGlB,SAAS,CAAC,IAAI,CAACe,UAAU,EAAEqC,IAAI,CAAC;IAC/CjD,aAAa,CAAC,IAAI,CAACY,UAAU,EAAEG,MAAM,CAAC;IACtC,OAAO;MACNM,OAAO,EAAEA,OAAO,CAACE,IAAI,CAAC,IAAI,EAAER,MAAM,CAAC;MACnC+B,UAAU,EAAEA,UAAU,CAACvB,IAAI,CAAC,IAAI,EAAER,MAAM;IACzC,CAAC;EACF;EAEAqC,MAAMA,CAAA,EAAU;IAAA,SAAAC,KAAA,GAAAL,SAAA,CAAAlC,MAAA,EAANmC,IAAI,OAAAC,KAAA,CAAAG,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJL,IAAI,CAAAK,KAAA,IAAAN,SAAA,CAAAM,KAAA;IAAA;IACb,MAAMvC,MAAM,GAAGlB,SAAS,CAAC,IAAI,CAACe,UAAU,EAAEqC,IAAI,CAAC;IAC/CjD,aAAa,CAAC,IAAI,CAACY,UAAU,EAAEG,MAAM,CAAC;IACtChB,YAAY,CAACwB,IAAI,CAAC,IAAI,EAAE,IAAI,CAACd,OAAO,EAAEM,MAAM,EAAE,IAAI,CAACwC,gBAAgB,CAAC;EACrE;AACD;AAEA,SAASlB,yBAAyBA,CAACmB,eAAe,EAAEjD,WAAW,EAAE;EAChEiD,eAAe,CAACxC,EAAE,CAACyC,QAAQ,CAAC,CAAC;EAE7B,OAAOlD,WAAW,CAACmD,GAAG,CAACC,UAAU,IAAI;IACpC,MAAMC,eAAe,GAAGJ,eAAe,CAACxC,EAAE,CAAC2C,UAAU,CAACA,UAAU,CAAC;IACjE,OAAO;MACN5C,MAAM,EAAEc,MAAM,CAACgC,MAAM,CAAC;QAAEC,QAAQ,EAAEH;MAAW,CAAC,EAAEH,eAAe,CAACzC,MAAM,CAAC;MACvEO,KAAK,EAAEsC,eAAe,GAAGA,eAAe,GAAG;IAC5C,CAAC;EACF,CAAC,CAAC;AACH;AAEA,SAASpB,iBAAiBA,CAAClB,KAAK,EAAEyC,OAAO,EAAE;EAC1C,OAAO;IACNC,UAAU,EAAE,GAAGD,OAAO,CAACtB,IAAI,QAAQ;IACnC1B,MAAM,EAAEO,KAAK,CAACP,MAAM;IACpBO,KAAK,EAAEA,KAAK,CAACH;EACd,CAAC;AACF;AAEA,SAASoB,eAAeA,CAACjB,KAAK,EAAEyC,OAAO,EAAE;EACxC,OAAO;IACNC,UAAU,EAAE,GAAGD,OAAO,CAACtB,IAAI,MAAM;IACjC1B,MAAM,EAAEO,KAAK,CAACP,MAAM;IACpBO,KAAK,EAAEA,KAAK,CAACF;EACd,CAAC;AACF;AAEA,SAAS0B,UAAUA,CAACmB,WAAW,EAAE;EAChC,OAAO,MAAM;IACZ,MAAMC,KAAK,GAAGC,OAAO,CAACC,MAAM,CAAC,CAAC;IAC9B,OAAOC,SAAS,IAAI;MACnB,MAAMC,KAAK,GAAGH,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;MACnC,MAAM5C,KAAK,GAAGgD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;MACvC,IAAI,CAACjD,OAAO,CAACQ,MAAM,CAACgC,MAAM,CAAC,CAAC,CAAC,EAAEI,WAAW,EAAEI,SAAS,CAAC,EAAE/C,KAAK,CAAC;MAC9D,OAAOA,KAAK;IACb,CAAC;EACF,CAAC;AACF;AAEA,SAASD,OAAOA,CAACN,MAAM,EAAE;EACxB,OAAOO,KAAK,IAAI;IACf,MAAMiD,cAAc,GAAGC,sBAAsB,CAACzD,MAAM,EAAEO,KAAK,CAAC;IAE5DtB,aAAa,CAAC,IAAI,CAACY,UAAU,EAAEG,MAAM,CAAC;IACtC,IAAI,CAAC0D,MAAM,CAACC,QAAQ,CAACH,cAAc,CAACjD,KAAK,CAAC,EAAE;MAC3C,MAAM,IAAIqD,SAAS,CAClB,gCAAgChF,IAAI,CAACiF,MAAM,CAACL,cAAc,CAACjD,KAAK,CAAC,EAClE,CAAC;IACF;IAEA,MAAMuD,IAAI,GAAG/E,UAAU,CAACyE,cAAc,CAACxD,MAAM,EAAE,IAAI,CAACwC,gBAAgB,CAAC;IACrE,IAAIuB,cAAc,GAAG,IAAI,CAACrE,OAAO,CAACoE,IAAI,CAAC;IACvC,IAAI,CAACC,cAAc,EAAE;MACpBA,cAAc,GAAG;QAChB/D,MAAM,EAAEwD,cAAc,CAACxD,MAAM;QAC7BC,EAAE,EAAE,IAAId,mBAAmB,CAAC,IAAI,CAACe,aAAa,EAAE,IAAI,CAACC,UAAU,CAAC;QAChEC,KAAK,EAAE,CAAC;QACRC,GAAG,EAAE;MACN,CAAC;IACF;IAEA0D,cAAc,CAAC9D,EAAE,CAACsB,IAAI,CAACiC,cAAc,CAACjD,KAAK,CAAC;IAC5CwD,cAAc,CAAC3D,KAAK,EAAE;IACtB,IAAI2D,cAAc,CAAC3D,KAAK,GAAG,IAAI,CAACX,aAAa,KAAK,CAAC,EAAE;MACpDsE,cAAc,CAAC9D,EAAE,CAACyC,QAAQ,CAAC,CAAC;IAC7B;IACAqB,cAAc,CAAC1D,GAAG,IAAImD,cAAc,CAACjD,KAAK;IAC1C,IAAI,CAACb,OAAO,CAACoE,IAAI,CAAC,GAAGC,cAAc;EACpC,CAAC;AACF;AAEA,SAASN,sBAAsBA,CAACzD,MAAM,EAAEO,KAAK,EAAE;EAC9C,IAAIA,KAAK,KAAKyD,SAAS,EAAE;IACxB,OAAO;MACNzD,KAAK,EAAEP,MAAM;MACbA,MAAM,EAAE,CAAC;IACV,CAAC;EACF;EAEA,OAAO;IACNA,MAAM;IACNO;EACD,CAAC;AACF;AAEA0D,MAAM,CAACC,OAAO,GAAG7E,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}