{"ast":null,"code":"'use strict';\n\nconst {\n  getValueAsString\n} = require('./util');\nclass Registry {\n  static get PROMETHEUS_CONTENT_TYPE() {\n    return 'text/plain; version=0.0.4; charset=utf-8';\n  }\n  static get OPENMETRICS_CONTENT_TYPE() {\n    return 'application/openmetrics-text; version=1.0.0; charset=utf-8';\n  }\n  constructor() {\n    let regContentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Registry.PROMETHEUS_CONTENT_TYPE;\n    this._metrics = {};\n    this._collectors = [];\n    this._defaultLabels = {};\n    if (regContentType !== Registry.PROMETHEUS_CONTENT_TYPE && regContentType !== Registry.OPENMETRICS_CONTENT_TYPE) {\n      throw new TypeError(`Content type ${regContentType} is unsupported`);\n    }\n    this._contentType = regContentType;\n  }\n  getMetricsAsArray() {\n    return Object.values(this._metrics);\n  }\n  async getMetricsAsString(metrics) {\n    const metric = typeof metrics.getForPromString === 'function' ? await metrics.getForPromString() : await metrics.get();\n    const name = escapeString(metric.name);\n    const help = `# HELP ${name} ${escapeString(metric.help)}`;\n    const type = `# TYPE ${name} ${metric.type}`;\n    const values = [help, type];\n    const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;\n    const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n    for (const val of metric.values || []) {\n      let {\n        metricName = name,\n        labels = {}\n      } = val;\n      const {\n        sharedLabels = {}\n      } = val;\n      if (isOpenMetrics && metric.type === 'counter') {\n        metricName = `${metricName}_total`;\n      }\n      if (defaultLabels) {\n        labels = {\n          ...labels,\n          ...defaultLabels,\n          ...labels\n        };\n      }\n\n      // We have to flatten these separately to avoid duplicate labels appearing\n      // between the base labels and the shared labels\n      const formattedLabels = formatLabels(labels, sharedLabels);\n      const flattenedShared = flattenSharedLabels(sharedLabels);\n      const labelParts = [...formattedLabels, flattenedShared].filter(Boolean);\n      const labelsString = labelParts.length ? `{${labelParts.join(',')}}` : '';\n      let fullMetricLine = `${metricName}${labelsString} ${getValueAsString(val.value)}`;\n      const {\n        exemplar\n      } = val;\n      if (exemplar && isOpenMetrics) {\n        const formattedExemplars = formatLabels(exemplar.labelSet);\n        fullMetricLine += ` # {${formattedExemplars.join(',')}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;\n      }\n      values.push(fullMetricLine);\n    }\n    return values.join('\\n');\n  }\n  async metrics() {\n    const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n    const promises = this.getMetricsAsArray().map(metric => {\n      if (isOpenMetrics && metric.type === 'counter') {\n        metric.name = standardizeCounterName(metric.name);\n      }\n      return this.getMetricsAsString(metric);\n    });\n    const resolves = await Promise.all(promises);\n    return isOpenMetrics ? `${resolves.join('\\n')}\\n# EOF\\n` : `${resolves.join('\\n\\n')}\\n`;\n  }\n  registerMetric(metric) {\n    if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {\n      throw new Error(`A metric with the name ${metric.name} has already been registered.`);\n    }\n    this._metrics[metric.name] = metric;\n  }\n  clear() {\n    this._metrics = {};\n    this._defaultLabels = {};\n  }\n  async getMetricsAsJSON() {\n    const metrics = [];\n    const defaultLabelNames = Object.keys(this._defaultLabels);\n    const promises = [];\n    for (const metric of this.getMetricsAsArray()) {\n      promises.push(metric.get());\n    }\n    const resolves = await Promise.all(promises);\n    for (const item of resolves) {\n      if (item.values && defaultLabelNames.length > 0) {\n        for (const val of item.values) {\n          // Make a copy before mutating\n          val.labels = Object.assign({}, val.labels);\n          for (const labelName of defaultLabelNames) {\n            val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];\n          }\n        }\n      }\n      metrics.push(item);\n    }\n    return metrics;\n  }\n  removeSingleMetric(name) {\n    delete this._metrics[name];\n  }\n  getSingleMetricAsString(name) {\n    return this.getMetricsAsString(this._metrics[name]);\n  }\n  getSingleMetric(name) {\n    return this._metrics[name];\n  }\n  setDefaultLabels(labels) {\n    this._defaultLabels = labels;\n  }\n  resetMetrics() {\n    for (const metric in this._metrics) {\n      this._metrics[metric].reset();\n    }\n  }\n  get contentType() {\n    return this._contentType;\n  }\n  setContentType(metricsContentType) {\n    if (metricsContentType === Registry.OPENMETRICS_CONTENT_TYPE || metricsContentType === Registry.PROMETHEUS_CONTENT_TYPE) {\n      this._contentType = metricsContentType;\n    } else {\n      throw new Error(`Content type ${metricsContentType} is unsupported`);\n    }\n  }\n  static merge(registers) {\n    const regType = registers[0].contentType;\n    for (const reg of registers) {\n      if (reg.contentType !== regType) {\n        throw new Error('Registers can only be merged if they have the same content type');\n      }\n    }\n    const mergedRegistry = new Registry(regType);\n    const metricsToMerge = registers.reduce((acc, reg) => acc.concat(reg.getMetricsAsArray()), []);\n    metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n    return mergedRegistry;\n  }\n}\nfunction formatLabels(labels, exclude) {\n  const {\n    hasOwnProperty\n  } = Object.prototype;\n  const formatted = [];\n  for (const [name, value] of Object.entries(labels)) {\n    if (!exclude || !hasOwnProperty.call(exclude, name)) {\n      formatted.push(`${name}=\"${escapeLabelValue(value)}\"`);\n    }\n  }\n  return formatted;\n}\nconst sharedLabelCache = new WeakMap();\nfunction flattenSharedLabels(labels) {\n  const cached = sharedLabelCache.get(labels);\n  if (cached) {\n    return cached;\n  }\n  const formattedLabels = formatLabels(labels);\n  const flattened = formattedLabels.join(',');\n  sharedLabelCache.set(labels, flattened);\n  return flattened;\n}\nfunction escapeLabelValue(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return escapeString(str).replace(/\"/g, '\\\\\"');\n}\nfunction escapeString(str) {\n  return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n}\nfunction standardizeCounterName(name) {\n  return name.replace(/_total$/, '');\n}\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();","map":{"version":3,"names":["getValueAsString","require","Registry","PROMETHEUS_CONTENT_TYPE","OPENMETRICS_CONTENT_TYPE","constructor","regContentType","arguments","length","undefined","_metrics","_collectors","_defaultLabels","TypeError","_contentType","getMetricsAsArray","Object","values","getMetricsAsString","metrics","metric","getForPromString","get","name","escapeString","help","type","defaultLabels","keys","isOpenMetrics","contentType","val","metricName","labels","sharedLabels","formattedLabels","formatLabels","flattenedShared","flattenSharedLabels","labelParts","filter","Boolean","labelsString","join","fullMetricLine","value","exemplar","formattedExemplars","labelSet","timestamp","push","promises","map","standardizeCounterName","resolves","Promise","all","registerMetric","Error","clear","getMetricsAsJSON","defaultLabelNames","item","assign","labelName","removeSingleMetric","getSingleMetricAsString","getSingleMetric","setDefaultLabels","resetMetrics","reset","setContentType","metricsContentType","merge","registers","regType","reg","mergedRegistry","metricsToMerge","reduce","acc","concat","forEach","exclude","hasOwnProperty","prototype","formatted","entries","call","escapeLabelValue","sharedLabelCache","WeakMap","cached","flattened","set","str","replace","module","exports","globalRegistry"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/registry.js"],"sourcesContent":["'use strict';\n\nconst { getValueAsString } = require('./util');\n\nclass Registry {\n\tstatic get PROMETHEUS_CONTENT_TYPE() {\n\t\treturn 'text/plain; version=0.0.4; charset=utf-8';\n\t}\n\n\tstatic get OPENMETRICS_CONTENT_TYPE() {\n\t\treturn 'application/openmetrics-text; version=1.0.0; charset=utf-8';\n\t}\n\n\tconstructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {\n\t\tthis._metrics = {};\n\t\tthis._collectors = [];\n\t\tthis._defaultLabels = {};\n\t\tif (\n\t\t\tregContentType !== Registry.PROMETHEUS_CONTENT_TYPE &&\n\t\t\tregContentType !== Registry.OPENMETRICS_CONTENT_TYPE\n\t\t) {\n\t\t\tthrow new TypeError(`Content type ${regContentType} is unsupported`);\n\t\t}\n\t\tthis._contentType = regContentType;\n\t}\n\n\tgetMetricsAsArray() {\n\t\treturn Object.values(this._metrics);\n\t}\n\n\tasync getMetricsAsString(metrics) {\n\t\tconst metric =\n\t\t\ttypeof metrics.getForPromString === 'function'\n\t\t\t\t? await metrics.getForPromString()\n\t\t\t\t: await metrics.get();\n\n\t\tconst name = escapeString(metric.name);\n\t\tconst help = `# HELP ${name} ${escapeString(metric.help)}`;\n\t\tconst type = `# TYPE ${name} ${metric.type}`;\n\t\tconst values = [help, type];\n\n\t\tconst defaultLabels =\n\t\t\tObject.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;\n\n\t\tconst isOpenMetrics =\n\t\t\tthis.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n\n\t\tfor (const val of metric.values || []) {\n\t\t\tlet { metricName = name, labels = {} } = val;\n\t\t\tconst { sharedLabels = {} } = val;\n\t\t\tif (isOpenMetrics && metric.type === 'counter') {\n\t\t\t\tmetricName = `${metricName}_total`;\n\t\t\t}\n\n\t\t\tif (defaultLabels) {\n\t\t\t\tlabels = { ...labels, ...defaultLabels, ...labels };\n\t\t\t}\n\n\t\t\t// We have to flatten these separately to avoid duplicate labels appearing\n\t\t\t// between the base labels and the shared labels\n\t\t\tconst formattedLabels = formatLabels(labels, sharedLabels);\n\n\t\t\tconst flattenedShared = flattenSharedLabels(sharedLabels);\n\t\t\tconst labelParts = [...formattedLabels, flattenedShared].filter(Boolean);\n\t\t\tconst labelsString = labelParts.length ? `{${labelParts.join(',')}}` : '';\n\t\t\tlet fullMetricLine = `${metricName}${labelsString} ${getValueAsString(\n\t\t\t\tval.value,\n\t\t\t)}`;\n\n\t\t\tconst { exemplar } = val;\n\t\t\tif (exemplar && isOpenMetrics) {\n\t\t\t\tconst formattedExemplars = formatLabels(exemplar.labelSet);\n\t\t\t\tfullMetricLine += ` # {${formattedExemplars.join(\n\t\t\t\t\t',',\n\t\t\t\t)}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;\n\t\t\t}\n\t\t\tvalues.push(fullMetricLine);\n\t\t}\n\n\t\treturn values.join('\\n');\n\t}\n\n\tasync metrics() {\n\t\tconst isOpenMetrics =\n\t\t\tthis.contentType === Registry.OPENMETRICS_CONTENT_TYPE;\n\n\t\tconst promises = this.getMetricsAsArray().map(metric => {\n\t\t\tif (isOpenMetrics && metric.type === 'counter') {\n\t\t\t\tmetric.name = standardizeCounterName(metric.name);\n\t\t\t}\n\t\t\treturn this.getMetricsAsString(metric);\n\t\t});\n\n\t\tconst resolves = await Promise.all(promises);\n\n\t\treturn isOpenMetrics\n\t\t\t? `${resolves.join('\\n')}\\n# EOF\\n`\n\t\t\t: `${resolves.join('\\n\\n')}\\n`;\n\t}\n\n\tregisterMetric(metric) {\n\t\tif (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {\n\t\t\tthrow new Error(\n\t\t\t\t`A metric with the name ${metric.name} has already been registered.`,\n\t\t\t);\n\t\t}\n\n\t\tthis._metrics[metric.name] = metric;\n\t}\n\n\tclear() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tasync getMetricsAsJSON() {\n\t\tconst metrics = [];\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tconst promises = [];\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tpromises.push(metric.get());\n\t\t}\n\n\t\tconst resolves = await Promise.all(promises);\n\n\t\tfor (const item of resolves) {\n\t\t\tif (item.values && defaultLabelNames.length > 0) {\n\t\t\t\tfor (const val of item.values) {\n\t\t\t\t\t// Make a copy before mutating\n\t\t\t\t\tval.labels = Object.assign({}, val.labels);\n\n\t\t\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\t\t\tval.labels[labelName] =\n\t\t\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.push(item);\n\t\t}\n\n\t\treturn metrics;\n\t}\n\n\tremoveSingleMetric(name) {\n\t\tdelete this._metrics[name];\n\t}\n\n\tgetSingleMetricAsString(name) {\n\t\treturn this.getMetricsAsString(this._metrics[name]);\n\t}\n\n\tgetSingleMetric(name) {\n\t\treturn this._metrics[name];\n\t}\n\n\tsetDefaultLabels(labels) {\n\t\tthis._defaultLabels = labels;\n\t}\n\n\tresetMetrics() {\n\t\tfor (const metric in this._metrics) {\n\t\t\tthis._metrics[metric].reset();\n\t\t}\n\t}\n\n\tget contentType() {\n\t\treturn this._contentType;\n\t}\n\n\tsetContentType(metricsContentType) {\n\t\tif (\n\t\t\tmetricsContentType === Registry.OPENMETRICS_CONTENT_TYPE ||\n\t\t\tmetricsContentType === Registry.PROMETHEUS_CONTENT_TYPE\n\t\t) {\n\t\t\tthis._contentType = metricsContentType;\n\t\t} else {\n\t\t\tthrow new Error(`Content type ${metricsContentType} is unsupported`);\n\t\t}\n\t}\n\n\tstatic merge(registers) {\n\t\tconst regType = registers[0].contentType;\n\t\tfor (const reg of registers) {\n\t\t\tif (reg.contentType !== regType) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Registers can only be merged if they have the same content type',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst mergedRegistry = new Registry(regType);\n\n\t\tconst metricsToMerge = registers.reduce(\n\t\t\t(acc, reg) => acc.concat(reg.getMetricsAsArray()),\n\t\t\t[],\n\t\t);\n\n\t\tmetricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n\t\treturn mergedRegistry;\n\t}\n}\n\nfunction formatLabels(labels, exclude) {\n\tconst { hasOwnProperty } = Object.prototype;\n\tconst formatted = [];\n\tfor (const [name, value] of Object.entries(labels)) {\n\t\tif (!exclude || !hasOwnProperty.call(exclude, name)) {\n\t\t\tformatted.push(`${name}=\"${escapeLabelValue(value)}\"`);\n\t\t}\n\t}\n\treturn formatted;\n}\n\nconst sharedLabelCache = new WeakMap();\nfunction flattenSharedLabels(labels) {\n\tconst cached = sharedLabelCache.get(labels);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst formattedLabels = formatLabels(labels);\n\tconst flattened = formattedLabels.join(',');\n\tsharedLabelCache.set(labels, flattened);\n\treturn flattened;\n}\nfunction escapeLabelValue(str) {\n\tif (typeof str !== 'string') {\n\t\treturn str;\n\t}\n\treturn escapeString(str).replace(/\"/g, '\\\\\"');\n}\nfunction escapeString(str) {\n\treturn str.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n}\nfunction standardizeCounterName(name) {\n\treturn name.replace(/_total$/, '');\n}\n\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}