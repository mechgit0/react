{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  NextServer: null,\n  default: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  NextServer: function () {\n    return NextServer;\n  },\n  // exports = module.exports\n  // Support `import next from 'next'`\n  default: function () {\n    return _default;\n  }\n});\nrequire(\"./require-hook\");\nrequire(\"./node-polyfill-crypto\");\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../build/output/log\"));\nconst _config = /*#__PURE__*/_interop_require_default(require(\"./config\"));\nconst _path = /*#__PURE__*/_interop_require_wildcard(require(\"path\"));\nconst _constants = require(\"../lib/constants\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _tracer = require(\"./lib/trace/tracer\");\nconst _constants2 = require(\"./lib/trace/constants\");\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\nconst _asynccallbackset = require(\"./lib/async-callback-set\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nlet ServerImpl;\nconst getServerImpl = async () => {\n  if (ServerImpl === undefined) {\n    ServerImpl = (await Promise.resolve(require('./next-server'))).default;\n  }\n  return ServerImpl;\n};\nconst SYMBOL_LOAD_CONFIG = Symbol('next.load_config');\nclass NextServer {\n  constructor(options) {\n    this.options = options;\n  }\n  get hostname() {\n    return this.options.hostname;\n  }\n  get port() {\n    return this.options.port;\n  }\n  getRequestHandler() {\n    return async (req, res, parsedUrl) => {\n      return (0, _tracer.getTracer)().trace(_constants2.NextServerSpan.getRequestHandler, async () => {\n        const requestHandler = await this.getServerRequestHandler();\n        return requestHandler(req, res, parsedUrl);\n      });\n    };\n  }\n  getUpgradeHandler() {\n    return async (req, socket, head) => {\n      const server = await this.getServer();\n      // @ts-expect-error we mark this as protected so it\n      // causes an error here\n      return server.handleUpgrade.apply(server, [req, socket, head]);\n    };\n  }\n  setAssetPrefix(assetPrefix) {\n    if (this.server) {\n      this.server.setAssetPrefix(assetPrefix);\n    } else {\n      this.preparedAssetPrefix = assetPrefix;\n    }\n  }\n  logError() {\n    if (this.server) {\n      this.server.logError(...arguments);\n    }\n  }\n  async render() {\n    const server = await this.getServer();\n    return server.render(...arguments);\n  }\n  async renderToHTML() {\n    const server = await this.getServer();\n    return server.renderToHTML(...arguments);\n  }\n  async renderError() {\n    const server = await this.getServer();\n    return server.renderError(...arguments);\n  }\n  async renderErrorToHTML() {\n    const server = await this.getServer();\n    return server.renderErrorToHTML(...arguments);\n  }\n  async render404() {\n    const server = await this.getServer();\n    return server.render404(...arguments);\n  }\n  async prepare(serverFields) {\n    const server = await this.getServer();\n    if (serverFields) {\n      Object.assign(server, serverFields);\n    }\n    // We shouldn't prepare the server in production,\n    // because this code won't be executed when deployed\n    if (this.options.dev) {\n      await server.prepare();\n    }\n  }\n  async close() {\n    if (this.server) {\n      await this.server.close();\n    }\n  }\n  async createServer(options) {\n    let ServerImplementation;\n    if (options.dev) {\n      ServerImplementation = require('./dev/next-dev-server').default;\n    } else {\n      ServerImplementation = await getServerImpl();\n    }\n    const server = new ServerImplementation(options);\n    return server;\n  }\n  async [SYMBOL_LOAD_CONFIG]() {\n    const dir = (0, _path.resolve)(this.options.dir || '.');\n    const config = await (0, _config.default)(this.options.dev ? _constants1.PHASE_DEVELOPMENT_SERVER : _constants1.PHASE_PRODUCTION_SERVER, dir, {\n      customConfig: this.options.conf,\n      silent: true\n    });\n    // check serialized build config when available\n    if (process.env.NODE_ENV === 'production') {\n      try {\n        const serializedConfig = require(_path.default.join(dir, '.next', _constants1.SERVER_FILES_MANIFEST)).config;\n        // @ts-expect-error internal field\n        config.experimental.isExperimentalCompile = serializedConfig.experimental.isExperimentalCompile;\n      } catch (_) {\n        // if distDir is customized we don't know until we\n        // load the config so fallback to loading the config\n        // from next.config.js\n      }\n    }\n    return config;\n  }\n  async getServer() {\n    if (!this.serverPromise) {\n      this.serverPromise = this[SYMBOL_LOAD_CONFIG]().then(async conf => {\n        if (!this.options.dev) {\n          if (conf.output === 'standalone') {\n            if (!process.env.__NEXT_PRIVATE_STANDALONE_CONFIG) {\n              _log.warn(`\"next start\" does not work with \"output: standalone\" configuration. Use \"node .next/standalone/server.js\" instead.`);\n            }\n          } else if (conf.output === 'export') {\n            throw Object.defineProperty(new Error(`\"next start\" does not work with \"output: export\" configuration. Use \"npx serve@latest out\" instead.`), \"__NEXT_ERROR_CODE\", {\n              value: \"E375\",\n              enumerable: false,\n              configurable: true\n            });\n          }\n        }\n        this.server = await this.createServer({\n          ...this.options,\n          conf\n        });\n        if (this.preparedAssetPrefix) {\n          this.server.setAssetPrefix(this.preparedAssetPrefix);\n        }\n        return this.server;\n      });\n    }\n    return this.serverPromise;\n  }\n  async getServerRequestHandler() {\n    if (this.reqHandler) return this.reqHandler;\n    // Memoize request handler creation\n    if (!this.reqHandlerPromise) {\n      this.reqHandlerPromise = this.getServer().then(server => {\n        this.reqHandler = (0, _tracer.getTracer)().wrap(_constants2.NextServerSpan.getServerRequestHandler, server.getRequestHandler().bind(server));\n        delete this.reqHandlerPromise;\n        return this.reqHandler;\n      });\n    }\n    return this.reqHandlerPromise;\n  }\n}\n/** The wrapper server used for `import next from \"next\" (in a custom server)` */\nclass NextCustomServer {\n  constructor(options) {\n    this.didWebSocketSetup = false;\n    this.options = options;\n  }\n  getInit() {\n    if (!this.init) {\n      throw Object.defineProperty(new Error('prepare() must be called before performing this operation'), \"__NEXT_ERROR_CODE\", {\n        value: \"E355\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    return this.init;\n  }\n  get requestHandler() {\n    return this.getInit().requestHandler;\n  }\n  get upgradeHandler() {\n    return this.getInit().upgradeHandler;\n  }\n  get server() {\n    return this.getInit().server;\n  }\n  get hostname() {\n    return this.options.hostname;\n  }\n  get port() {\n    return this.options.port;\n  }\n  async prepare() {\n    const {\n      getRequestHandlers\n    } = require('./lib/start-server');\n    let onDevServerCleanup;\n    if (this.options.dev) {\n      this.cleanupListeners = new _asynccallbackset.AsyncCallbackSet();\n      onDevServerCleanup = this.cleanupListeners.add.bind(this.cleanupListeners);\n    }\n    const initResult = await getRequestHandlers({\n      dir: this.options.dir,\n      port: this.options.port || 3000,\n      isDev: !!this.options.dev,\n      onDevServerCleanup,\n      hostname: this.options.hostname || 'localhost',\n      minimalMode: this.options.minimalMode,\n      quiet: this.options.quiet\n    });\n    this.init = initResult;\n  }\n  setupWebSocketHandler(customServer, _req) {\n    if (!this.didWebSocketSetup) {\n      var _req_socket;\n      this.didWebSocketSetup = true;\n      customServer = customServer || (_req == null ? void 0 : (_req_socket = _req.socket) == null ? void 0 : _req_socket.server);\n      if (customServer) {\n        customServer.on('upgrade', async (req, socket, head) => {\n          this.upgradeHandler(req, socket, head);\n        });\n      }\n    }\n  }\n  getRequestHandler() {\n    return async (req, res, parsedUrl) => {\n      this.setupWebSocketHandler(this.options.httpServer, req);\n      if (parsedUrl) {\n        req.url = (0, _formaturl.formatUrl)(parsedUrl);\n      }\n      return this.requestHandler(req, res);\n    };\n  }\n  async render() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let [req, res, pathname, query, parsedUrl] = args;\n    this.setupWebSocketHandler(this.options.httpServer, req);\n    if (!pathname.startsWith('/')) {\n      console.error(`Cannot render page with path \"${pathname}\"`);\n      pathname = `/${pathname}`;\n    }\n    pathname = pathname === '/index' ? '/' : pathname;\n    req.url = (0, _formaturl.formatUrl)({\n      ...parsedUrl,\n      pathname,\n      query\n    });\n    await this.requestHandler(req, res);\n    return;\n  }\n  setAssetPrefix(assetPrefix) {\n    this.server.setAssetPrefix(assetPrefix);\n  }\n  getUpgradeHandler() {\n    return this.server.getUpgradeHandler();\n  }\n  logError() {\n    this.server.logError(...arguments);\n  }\n  async renderToHTML() {\n    return this.server.renderToHTML(...arguments);\n  }\n  async renderError() {\n    return this.server.renderError(...arguments);\n  }\n  async renderErrorToHTML() {\n    return this.server.renderErrorToHTML(...arguments);\n  }\n  async render404() {\n    return this.server.render404(...arguments);\n  }\n  async close() {\n    var _this_init, _this_cleanupListeners;\n    await Promise.allSettled([(_this_init = this.init) == null ? void 0 : _this_init.server.close(), (_this_cleanupListeners = this.cleanupListeners) == null ? void 0 : _this_cleanupListeners.runAll()]);\n  }\n}\n// This file is used for when users run `require('next')`\nfunction createServer(options) {\n  if (options && (options.turbo || options.turbopack)) {\n    process.env.TURBOPACK = '1';\n  }\n  // The package is used as a TypeScript plugin.\n  if (options && 'typescript' in options && 'version' in options.typescript) {\n    const pluginMod = require('./next-typescript');\n    return pluginMod.createTSPlugin(options);\n  }\n  if (options == null) {\n    throw Object.defineProperty(new Error('The server has not been instantiated properly. https://nextjs.org/docs/messages/invalid-server-options'), \"__NEXT_ERROR_CODE\", {\n      value: \"E75\",\n      enumerable: false,\n      configurable: true\n    });\n  }\n  if (!('isNextDevCommand' in options) && process.env.NODE_ENV && !['production', 'development', 'test'].includes(process.env.NODE_ENV)) {\n    _log.warn(_constants.NON_STANDARD_NODE_ENV);\n  }\n  if (options.dev && typeof options.dev !== 'boolean') {\n    console.warn(\"Warning: 'dev' is not a boolean which could introduce unexpected behavior. https://nextjs.org/docs/messages/invalid-server-options\");\n  }\n  // When the caller is a custom server (using next()).\n  if (options.customServer !== false) {\n    const dir = (0, _path.resolve)(options.dir || '.');\n    return new NextCustomServer({\n      ...options,\n      dir\n    });\n  }\n  // When the caller is Next.js internals (i.e. render worker, start server, etc)\n  return new NextServer(options);\n}\n// Support commonjs `require('next')`\nmodule.exports = createServer;\nconst _default = createServer;","map":{"version":3,"names":["NextServer","default","_default","ServerImpl","getServerImpl","undefined","Promise","resolve","require","SYMBOL_LOAD_CONFIG","Symbol","constructor","options","hostname","port","getRequestHandler","req","res","parsedUrl","_tracer","getTracer","trace","_constants2","NextServerSpan","requestHandler","getServerRequestHandler","getUpgradeHandler","socket","head","server","getServer","handleUpgrade","apply","setAssetPrefix","assetPrefix","preparedAssetPrefix","logError","arguments","render","renderToHTML","renderError","renderErrorToHTML","render404","prepare","serverFields","Object","assign","dev","close","createServer","ServerImplementation","dir","_path","config","_config","_constants1","PHASE_DEVELOPMENT_SERVER","PHASE_PRODUCTION_SERVER","customConfig","conf","silent","process","env","NODE_ENV","serializedConfig","join","SERVER_FILES_MANIFEST","experimental","isExperimentalCompile","_","serverPromise","then","output","__NEXT_PRIVATE_STANDALONE_CONFIG","_log","warn","defineProperty","Error","reqHandler","reqHandlerPromise","wrap","bind","NextCustomServer","didWebSocketSetup","getInit","init","upgradeHandler","getRequestHandlers","onDevServerCleanup","cleanupListeners","_asynccallbackset","AsyncCallbackSet","add","initResult","isDev","minimalMode","quiet","setupWebSocketHandler","customServer","_req","_req_socket","on","httpServer","url","_formaturl","formatUrl","_len","length","args","Array","_key","pathname","query","startsWith","console","error","_this_init","_this_cleanupListeners","allSettled","runAll","turbo","turbopack","TURBOPACK","typescript","pluginMod","createTSPlugin","includes","_constants","NON_STANDARD_NODE_ENV","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/next/src/server/next.ts"],"sourcesContent":["import type { Options as DevServerOptions } from './dev/next-dev-server'\nimport type {\n  NodeRequestHandler,\n  Options as ServerOptions,\n} from './next-server'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { Duplex } from 'stream'\nimport type { NextUrlWithParsedQuery } from './request-meta'\n\nimport './require-hook'\nimport './node-polyfill-crypto'\n\nimport type { default as NextNodeServer } from './next-server'\nimport * as log from '../build/output/log'\nimport loadConfig from './config'\nimport path, { resolve } from 'path'\nimport { NON_STANDARD_NODE_ENV } from '../lib/constants'\nimport {\n  PHASE_DEVELOPMENT_SERVER,\n  SERVER_FILES_MANIFEST,\n} from '../shared/lib/constants'\nimport { PHASE_PRODUCTION_SERVER } from '../shared/lib/constants'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextServerSpan } from './lib/trace/constants'\nimport { formatUrl } from '../shared/lib/router/utils/format-url'\nimport type { ServerFields } from './lib/router-utils/setup-dev-bundler'\nimport type { ServerInitResult } from './lib/render-server'\nimport { AsyncCallbackSet } from './lib/async-callback-set'\n\nlet ServerImpl: typeof NextNodeServer\n\nconst getServerImpl = async () => {\n  if (ServerImpl === undefined) {\n    ServerImpl = (await Promise.resolve(require('./next-server'))).default\n  }\n  return ServerImpl\n}\n\nexport type NextServerOptions = Omit<\n  ServerOptions | DevServerOptions,\n  // This is assigned in this server abstraction.\n  'conf'\n> &\n  Partial<Pick<ServerOptions | DevServerOptions, 'conf'>>\n\nexport type RequestHandler = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  parsedUrl?: NextUrlWithParsedQuery | undefined\n) => Promise<void>\n\nexport type UpgradeHandler = (\n  req: IncomingMessage,\n  socket: Duplex,\n  head: Buffer\n) => Promise<void>\n\nconst SYMBOL_LOAD_CONFIG = Symbol('next.load_config')\n\ninterface NextWrapperServer {\n  // NOTE: the methods/properties here are the public API for custom servers.\n  // Consider backwards compatibilty when changing something here!\n\n  options: NextServerOptions\n  hostname: string | undefined\n  port: number | undefined\n\n  getRequestHandler(): RequestHandler\n  prepare(serverFields?: ServerFields): Promise<void>\n  setAssetPrefix(assetPrefix: string): void\n  close(): Promise<void>\n\n  // used internally\n  getUpgradeHandler(): UpgradeHandler\n\n  // legacy methods that we left exposed in the past\n\n  logError(...args: Parameters<NextNodeServer['logError']>): void\n\n  render(\n    ...args: Parameters<NextNodeServer['render']>\n  ): ReturnType<NextNodeServer['render']>\n\n  renderToHTML(\n    ...args: Parameters<NextNodeServer['renderToHTML']>\n  ): ReturnType<NextNodeServer['renderToHTML']>\n\n  renderError(\n    ...args: Parameters<NextNodeServer['renderError']>\n  ): ReturnType<NextNodeServer['renderError']>\n\n  renderErrorToHTML(\n    ...args: Parameters<NextNodeServer['renderErrorToHTML']>\n  ): ReturnType<NextNodeServer['renderErrorToHTML']>\n\n  render404(\n    ...args: Parameters<NextNodeServer['render404']>\n  ): ReturnType<NextNodeServer['render404']>\n}\n\n/** The wrapper server used by `next start` */\nexport class NextServer implements NextWrapperServer {\n  private serverPromise?: Promise<NextNodeServer>\n  private server?: NextNodeServer\n  private reqHandler?: NodeRequestHandler\n  private reqHandlerPromise?: Promise<NodeRequestHandler>\n  private preparedAssetPrefix?: string\n\n  public options: NextServerOptions\n\n  constructor(options: NextServerOptions) {\n    this.options = options\n  }\n\n  get hostname() {\n    return this.options.hostname\n  }\n\n  get port() {\n    return this.options.port\n  }\n\n  getRequestHandler(): RequestHandler {\n    return async (\n      req: IncomingMessage,\n      res: ServerResponse,\n      parsedUrl?: UrlWithParsedQuery\n    ) => {\n      return getTracer().trace(NextServerSpan.getRequestHandler, async () => {\n        const requestHandler = await this.getServerRequestHandler()\n        return requestHandler(req, res, parsedUrl)\n      })\n    }\n  }\n\n  getUpgradeHandler(): UpgradeHandler {\n    return async (req: IncomingMessage, socket: any, head: any) => {\n      const server = await this.getServer()\n      // @ts-expect-error we mark this as protected so it\n      // causes an error here\n      return server.handleUpgrade.apply(server, [req, socket, head])\n    }\n  }\n\n  setAssetPrefix(assetPrefix: string) {\n    if (this.server) {\n      this.server.setAssetPrefix(assetPrefix)\n    } else {\n      this.preparedAssetPrefix = assetPrefix\n    }\n  }\n\n  logError(...args: Parameters<NextWrapperServer['logError']>) {\n    if (this.server) {\n      this.server.logError(...args)\n    }\n  }\n\n  async render(...args: Parameters<NextWrapperServer['render']>) {\n    const server = await this.getServer()\n    return server.render(...args)\n  }\n\n  async renderToHTML(...args: Parameters<NextWrapperServer['renderToHTML']>) {\n    const server = await this.getServer()\n    return server.renderToHTML(...args)\n  }\n\n  async renderError(...args: Parameters<NextWrapperServer['renderError']>) {\n    const server = await this.getServer()\n    return server.renderError(...args)\n  }\n\n  async renderErrorToHTML(\n    ...args: Parameters<NextWrapperServer['renderErrorToHTML']>\n  ) {\n    const server = await this.getServer()\n    return server.renderErrorToHTML(...args)\n  }\n\n  async render404(...args: Parameters<NextWrapperServer['render404']>) {\n    const server = await this.getServer()\n    return server.render404(...args)\n  }\n\n  async prepare(serverFields?: ServerFields) {\n    const server = await this.getServer()\n\n    if (serverFields) {\n      Object.assign(server, serverFields)\n    }\n    // We shouldn't prepare the server in production,\n    // because this code won't be executed when deployed\n    if (this.options.dev) {\n      await server.prepare()\n    }\n  }\n\n  async close() {\n    if (this.server) {\n      await this.server.close()\n    }\n  }\n\n  private async createServer(\n    options: ServerOptions | DevServerOptions\n  ): Promise<NextNodeServer> {\n    let ServerImplementation: typeof NextNodeServer\n    if (options.dev) {\n      ServerImplementation = require('./dev/next-dev-server')\n        .default as typeof import('./dev/next-dev-server').default\n    } else {\n      ServerImplementation = await getServerImpl()\n    }\n    const server = new ServerImplementation(options)\n\n    return server\n  }\n\n  private async [SYMBOL_LOAD_CONFIG]() {\n    const dir = resolve(this.options.dir || '.')\n\n    const config = await loadConfig(\n      this.options.dev ? PHASE_DEVELOPMENT_SERVER : PHASE_PRODUCTION_SERVER,\n      dir,\n      {\n        customConfig: this.options.conf,\n        silent: true,\n      }\n    )\n\n    // check serialized build config when available\n    if (process.env.NODE_ENV === 'production') {\n      try {\n        const serializedConfig = require(\n          path.join(dir, '.next', SERVER_FILES_MANIFEST)\n        ).config\n\n        // @ts-expect-error internal field\n        config.experimental.isExperimentalCompile =\n          serializedConfig.experimental.isExperimentalCompile\n      } catch (_) {\n        // if distDir is customized we don't know until we\n        // load the config so fallback to loading the config\n        // from next.config.js\n      }\n    }\n\n    return config\n  }\n\n  private async getServer() {\n    if (!this.serverPromise) {\n      this.serverPromise = this[SYMBOL_LOAD_CONFIG]().then(async (conf) => {\n        if (!this.options.dev) {\n          if (conf.output === 'standalone') {\n            if (!process.env.__NEXT_PRIVATE_STANDALONE_CONFIG) {\n              log.warn(\n                `\"next start\" does not work with \"output: standalone\" configuration. Use \"node .next/standalone/server.js\" instead.`\n              )\n            }\n          } else if (conf.output === 'export') {\n            throw new Error(\n              `\"next start\" does not work with \"output: export\" configuration. Use \"npx serve@latest out\" instead.`\n            )\n          }\n        }\n\n        this.server = await this.createServer({\n          ...this.options,\n          conf,\n        })\n        if (this.preparedAssetPrefix) {\n          this.server.setAssetPrefix(this.preparedAssetPrefix)\n        }\n        return this.server\n      })\n    }\n    return this.serverPromise\n  }\n\n  private async getServerRequestHandler() {\n    if (this.reqHandler) return this.reqHandler\n\n    // Memoize request handler creation\n    if (!this.reqHandlerPromise) {\n      this.reqHandlerPromise = this.getServer().then((server) => {\n        this.reqHandler = getTracer().wrap(\n          NextServerSpan.getServerRequestHandler,\n          server.getRequestHandler().bind(server)\n        )\n        delete this.reqHandlerPromise\n        return this.reqHandler\n      })\n    }\n    return this.reqHandlerPromise\n  }\n}\n\n/** The wrapper server used for `import next from \"next\" (in a custom server)` */\nclass NextCustomServer implements NextWrapperServer {\n  private didWebSocketSetup: boolean = false\n  protected cleanupListeners?: AsyncCallbackSet\n\n  protected init?: ServerInitResult\n\n  public options: NextServerOptions\n\n  constructor(options: NextServerOptions) {\n    this.options = options\n  }\n\n  protected getInit() {\n    if (!this.init) {\n      throw new Error(\n        'prepare() must be called before performing this operation'\n      )\n    }\n    return this.init\n  }\n\n  protected get requestHandler() {\n    return this.getInit().requestHandler\n  }\n  protected get upgradeHandler() {\n    return this.getInit().upgradeHandler\n  }\n  protected get server() {\n    return this.getInit().server\n  }\n\n  get hostname() {\n    return this.options.hostname\n  }\n\n  get port() {\n    return this.options.port\n  }\n\n  async prepare() {\n    const { getRequestHandlers } =\n      require('./lib/start-server') as typeof import('./lib/start-server')\n\n    let onDevServerCleanup: AsyncCallbackSet['add'] | undefined\n    if (this.options.dev) {\n      this.cleanupListeners = new AsyncCallbackSet()\n      onDevServerCleanup = this.cleanupListeners.add.bind(this.cleanupListeners)\n    }\n\n    const initResult = await getRequestHandlers({\n      dir: this.options.dir!,\n      port: this.options.port || 3000,\n      isDev: !!this.options.dev,\n      onDevServerCleanup,\n      hostname: this.options.hostname || 'localhost',\n      minimalMode: this.options.minimalMode,\n      quiet: this.options.quiet,\n    })\n    this.init = initResult\n  }\n\n  private setupWebSocketHandler(\n    customServer?: import('http').Server,\n    _req?: IncomingMessage\n  ) {\n    if (!this.didWebSocketSetup) {\n      this.didWebSocketSetup = true\n      customServer = customServer || (_req?.socket as any)?.server\n\n      if (customServer) {\n        customServer.on('upgrade', async (req, socket, head) => {\n          this.upgradeHandler(req, socket, head)\n        })\n      }\n    }\n  }\n\n  getRequestHandler(): RequestHandler {\n    return async (\n      req: IncomingMessage,\n      res: ServerResponse,\n      parsedUrl?: UrlWithParsedQuery\n    ) => {\n      this.setupWebSocketHandler(this.options.httpServer, req)\n\n      if (parsedUrl) {\n        req.url = formatUrl(parsedUrl)\n      }\n\n      return this.requestHandler(req, res)\n    }\n  }\n\n  async render(...args: Parameters<NextWrapperServer['render']>) {\n    let [req, res, pathname, query, parsedUrl] = args\n    this.setupWebSocketHandler(this.options.httpServer, req as IncomingMessage)\n\n    if (!pathname.startsWith('/')) {\n      console.error(`Cannot render page with path \"${pathname}\"`)\n      pathname = `/${pathname}`\n    }\n    pathname = pathname === '/index' ? '/' : pathname\n\n    req.url = formatUrl({\n      ...parsedUrl,\n      pathname,\n      query,\n    })\n\n    await this.requestHandler(req as IncomingMessage, res as ServerResponse)\n    return\n  }\n\n  setAssetPrefix(assetPrefix: string): void {\n    this.server.setAssetPrefix(assetPrefix)\n  }\n\n  getUpgradeHandler(): UpgradeHandler {\n    return this.server.getUpgradeHandler()\n  }\n\n  logError(...args: Parameters<NextWrapperServer['logError']>) {\n    this.server.logError(...args)\n  }\n\n  async renderToHTML(...args: Parameters<NextWrapperServer['renderToHTML']>) {\n    return this.server.renderToHTML(...args)\n  }\n\n  async renderError(...args: Parameters<NextWrapperServer['renderError']>) {\n    return this.server.renderError(...args)\n  }\n\n  async renderErrorToHTML(\n    ...args: Parameters<NextWrapperServer['renderErrorToHTML']>\n  ) {\n    return this.server.renderErrorToHTML(...args)\n  }\n\n  async render404(...args: Parameters<NextWrapperServer['render404']>) {\n    return this.server.render404(...args)\n  }\n\n  async close() {\n    await Promise.allSettled([\n      this.init?.server.close(),\n      this.cleanupListeners?.runAll(),\n    ])\n  }\n}\n\n// This file is used for when users run `require('next')`\nfunction createServer(\n  options: NextServerOptions & {\n    turbo?: boolean\n    turbopack?: boolean\n  }\n): NextWrapperServer {\n  if (options && (options.turbo || options.turbopack)) {\n    process.env.TURBOPACK = '1'\n  }\n  // The package is used as a TypeScript plugin.\n  if (\n    options &&\n    'typescript' in options &&\n    'version' in (options as any).typescript\n  ) {\n    const pluginMod: typeof import('./next-typescript') = require('./next-typescript')\n    return pluginMod.createTSPlugin(\n      options as any\n    ) as unknown as NextWrapperServer\n  }\n\n  if (options == null) {\n    throw new Error(\n      'The server has not been instantiated properly. https://nextjs.org/docs/messages/invalid-server-options'\n    )\n  }\n\n  if (\n    !('isNextDevCommand' in options) &&\n    process.env.NODE_ENV &&\n    !['production', 'development', 'test'].includes(process.env.NODE_ENV)\n  ) {\n    log.warn(NON_STANDARD_NODE_ENV)\n  }\n\n  if (options.dev && typeof options.dev !== 'boolean') {\n    console.warn(\n      \"Warning: 'dev' is not a boolean which could introduce unexpected behavior. https://nextjs.org/docs/messages/invalid-server-options\"\n    )\n  }\n\n  // When the caller is a custom server (using next()).\n  if (options.customServer !== false) {\n    const dir = resolve(options.dir || '.')\n\n    return new NextCustomServer({\n      ...options,\n      dir,\n    })\n  }\n\n  // When the caller is Next.js internals (i.e. render worker, start server, etc)\n  return new NextServer(options)\n}\n\n// Support commonjs `require('next')`\nmodule.exports = createServer\n// exports = module.exports\n\n// Support `import next from 'next'`\nexport default createServer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}