{"ast":null,"code":"/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst {\n  getLabels,\n  hashObject,\n  isObject,\n  removeLabels,\n  nowTimestamp\n} = require('./util');\nconst {\n  validateLabel\n} = require('./validation');\nconst {\n  Metric\n} = require('./metric');\nconst Exemplar = require('./exemplar');\nclass Histogram extends Metric {\n  constructor(config) {\n    super(config, {\n      buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]\n    });\n    this.type = 'histogram';\n    this.defaultLabels = {};\n    this.defaultExemplarLabelSet = {};\n    this.enableExemplars = false;\n    for (const label of this.labelNames) {\n      if (label === 'le') {\n        throw new Error('le is a reserved label keyword');\n      }\n    }\n    this.upperBounds = this.buckets;\n    this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n      acc[upperBound] = 0;\n      return acc;\n    }, {});\n    if (config.enableExemplars) {\n      this.enableExemplars = true;\n      this.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {\n        acc[upperBound] = null;\n        return acc;\n      }, {});\n      Object.freeze(this.bucketExemplars);\n      this.observe = this.observeWithExemplar;\n    } else {\n      this.observe = this.observeWithoutExemplar;\n    }\n    Object.freeze(this.bucketValues);\n    Object.freeze(this.upperBounds);\n    if (this.labelNames.length === 0) {\n      this.hashMap = {\n        [hashObject({})]: createBaseValues({}, this.bucketValues, this.bucketExemplars)\n      };\n    }\n  }\n\n  /**\n   * Observe a value in histogram\n   * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n   * @param {Number} value - Value to observe in the histogram\n   * @returns {void}\n   */\n  observeWithoutExemplar(labels, value) {\n    observe.call(this, labels === 0 ? 0 : labels || {})(value);\n  }\n  observeWithExemplar() {\n    let {\n      labels = this.defaultLabels,\n      value,\n      exemplarLabels = this.defaultExemplarLabelSet\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    observe.call(this, labels === 0 ? 0 : labels || {})(value);\n    this.updateExemplar(labels, value, exemplarLabels);\n  }\n  updateExemplar(labels, value, exemplarLabels) {\n    if (Object.keys(exemplarLabels).length === 0) return;\n    const hash = hashObject(labels, this.sortedLabelNames);\n    const bound = findBound(this.upperBounds, value);\n    const {\n      bucketExemplars\n    } = this.hashMap[hash];\n    let exemplar = bucketExemplars[bound];\n    if (!isObject(exemplar)) {\n      exemplar = new Exemplar();\n      bucketExemplars[bound] = exemplar;\n    }\n    exemplar.validateExemplarLabelSet(exemplarLabels);\n    exemplar.labelSet = exemplarLabels;\n    exemplar.value = value;\n    exemplar.timestamp = nowTimestamp();\n  }\n  async get() {\n    const data = await this.getForPromString();\n    data.values = data.values.map(splayLabels);\n    return data;\n  }\n  async getForPromString() {\n    if (this.collect) {\n      const v = this.collect();\n      if (v instanceof Promise) await v;\n    }\n    const data = Object.values(this.hashMap);\n    const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);\n    return {\n      name: this.name,\n      help: this.help,\n      type: this.type,\n      values,\n      aggregator: this.aggregator\n    };\n  }\n  reset() {\n    this.hashMap = {};\n  }\n\n  /**\n   * Initialize the metrics for the given combination of labels to zero\n   * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n   * @returns {void}\n   */\n  zero(labels) {\n    const hash = hashObject(labels, this.sortedLabelNames);\n    this.hashMap[hash] = createBaseValues(labels, this.bucketValues, this.bucketExemplars);\n  }\n\n  /**\n   * Start a timer that could be used to logging durations\n   * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n   * @param {object} exemplarLabels - Object with labels for exemplar where key is the label key and value is label value. Can only be one level deep\n   * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n   * @example\n   * var end = histogram.startTimer();\n   * makeExpensiveXHRRequest(function(err, res) {\n   * \tconst duration = end(); //Observe the duration of expensiveXHRRequest and returns duration in seconds\n   * \tconsole.log('Duration', duration);\n   * });\n   */\n  startTimer(labels, exemplarLabels) {\n    return this.enableExemplars ? startTimerWithExemplar.call(this, labels, exemplarLabels)() : startTimer.call(this, labels)();\n  }\n  labels() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const labels = getLabels(this.labelNames, args);\n    validateLabel(this.labelNames, labels);\n    return {\n      observe: observe.call(this, labels),\n      startTimer: startTimer.call(this, labels)\n    };\n  }\n  remove() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const labels = getLabels(this.labelNames, args);\n    validateLabel(this.labelNames, labels);\n    removeLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n  }\n}\nfunction startTimer(startLabels) {\n  return () => {\n    const start = process.hrtime();\n    return endLabels => {\n      const delta = process.hrtime(start);\n      const value = delta[0] + delta[1] / 1e9;\n      this.observe(Object.assign({}, startLabels, endLabels), value);\n      return value;\n    };\n  };\n}\nfunction startTimerWithExemplar(startLabels, startExemplarLabels) {\n  return () => {\n    const start = process.hrtime();\n    return (endLabels, endExemplarLabels) => {\n      const delta = process.hrtime(start);\n      const value = delta[0] + delta[1] / 1e9;\n      this.observe({\n        labels: Object.assign({}, startLabels, endLabels),\n        value,\n        exemplarLabels: Object.assign({}, startExemplarLabels, endExemplarLabels)\n      });\n      return value;\n    };\n  };\n}\nfunction setValuePair(labels, value, metricName, exemplar) {\n  let sharedLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  return {\n    labels,\n    sharedLabels,\n    value,\n    metricName,\n    exemplar\n  };\n}\nfunction findBound(upperBounds, value) {\n  for (let i = 0; i < upperBounds.length; i++) {\n    const bound = upperBounds[i];\n    if (value <= bound) {\n      return bound;\n    }\n  }\n  return -1;\n}\nfunction observe(labels) {\n  return value => {\n    const labelValuePair = convertLabelsAndValues(labels, value);\n    validateLabel(this.labelNames, labelValuePair.labels);\n    if (!Number.isFinite(labelValuePair.value)) {\n      throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);\n    }\n    const hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n    let valueFromMap = this.hashMap[hash];\n    if (!valueFromMap) {\n      valueFromMap = createBaseValues(labelValuePair.labels, this.bucketValues, this.bucketExemplars);\n    }\n    const b = findBound(this.upperBounds, labelValuePair.value);\n    valueFromMap.sum += labelValuePair.value;\n    valueFromMap.count += 1;\n    if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {\n      valueFromMap.bucketValues[b] += 1;\n    }\n    this.hashMap[hash] = valueFromMap;\n  };\n}\nfunction createBaseValues(labels, bucketValues, bucketExemplars) {\n  const result = {\n    labels,\n    bucketValues: {\n      ...bucketValues\n    },\n    sum: 0,\n    count: 0\n  };\n  if (bucketExemplars) {\n    result.bucketExemplars = {\n      ...bucketExemplars\n    };\n  }\n  return result;\n}\nfunction convertLabelsAndValues(labels, value) {\n  return isObject(labels) ? {\n    labels,\n    value\n  } : {\n    value: labels,\n    labels: {}\n  };\n}\nfunction extractBucketValuesForExport(histogram) {\n  const name = `${histogram.name}_bucket`;\n  return bucketData => {\n    let acc = 0;\n    const buckets = histogram.upperBounds.map(upperBound => {\n      acc += bucketData.bucketValues[upperBound];\n      return setValuePair({\n        le: upperBound\n      }, acc, name, bucketData.bucketExemplars ? bucketData.bucketExemplars[upperBound] : null, bucketData.labels);\n    });\n    return {\n      buckets,\n      data: bucketData\n    };\n  };\n}\nfunction addSumAndCountForExport(histogram) {\n  return (acc, d) => {\n    acc.push(...d.buckets);\n    const infLabel = {\n      le: '+Inf'\n    };\n    acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`, d.data.bucketExemplars ? d.data.bucketExemplars['-1'] : null, d.data.labels), setValuePair({}, d.data.sum, `${histogram.name}_sum`, undefined, d.data.labels), setValuePair({}, d.data.count, `${histogram.name}_count`, undefined, d.data.labels));\n    return acc;\n  };\n}\nfunction splayLabels(bucket) {\n  const {\n    sharedLabels,\n    labels,\n    ...newBucket\n  } = bucket;\n  for (const label of Object.keys(sharedLabels)) {\n    labels[label] = sharedLabels[label];\n  }\n  newBucket.labels = labels;\n  return newBucket;\n}\nmodule.exports = Histogram;","map":{"version":3,"names":["util","require","getLabels","hashObject","isObject","removeLabels","nowTimestamp","validateLabel","Metric","Exemplar","Histogram","constructor","config","buckets","type","defaultLabels","defaultExemplarLabelSet","enableExemplars","label","labelNames","Error","upperBounds","bucketValues","reduce","acc","upperBound","bucketExemplars","Object","freeze","observe","observeWithExemplar","observeWithoutExemplar","length","hashMap","createBaseValues","labels","value","call","exemplarLabels","arguments","undefined","updateExemplar","keys","hash","sortedLabelNames","bound","findBound","exemplar","validateExemplarLabelSet","labelSet","timestamp","get","data","getForPromString","values","map","splayLabels","collect","v","Promise","extractBucketValuesForExport","addSumAndCountForExport","name","help","aggregator","reset","zero","startTimer","startTimerWithExemplar","_len","args","Array","_key","remove","_len2","_key2","startLabels","start","process","hrtime","endLabels","delta","assign","startExemplarLabels","endExemplarLabels","setValuePair","metricName","sharedLabels","i","labelValuePair","convertLabelsAndValues","Number","isFinite","TypeError","format","valueFromMap","b","sum","count","prototype","hasOwnProperty","result","histogram","bucketData","le","d","push","infLabel","bucket","newBucket","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/histogram.js"],"sourcesContent":["/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst {\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tremoveLabels,\n\tnowTimestamp,\n} = require('./util');\nconst { validateLabel } = require('./validation');\nconst { Metric } = require('./metric');\nconst Exemplar = require('./exemplar');\n\nclass Histogram extends Metric {\n\tconstructor(config) {\n\t\tsuper(config, {\n\t\t\tbuckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n\t\t});\n\n\t\tthis.type = 'histogram';\n\t\tthis.defaultLabels = {};\n\t\tthis.defaultExemplarLabelSet = {};\n\t\tthis.enableExemplars = false;\n\n\t\tfor (const label of this.labelNames) {\n\t\t\tif (label === 'le') {\n\t\t\t\tthrow new Error('le is a reserved label keyword');\n\t\t\t}\n\t\t}\n\n\t\tthis.upperBounds = this.buckets;\n\t\tthis.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\tacc[upperBound] = 0;\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\tif (config.enableExemplars) {\n\t\t\tthis.enableExemplars = true;\n\t\t\tthis.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\t\tacc[upperBound] = null;\n\t\t\t\treturn acc;\n\t\t\t}, {});\n\t\t\tObject.freeze(this.bucketExemplars);\n\t\t\tthis.observe = this.observeWithExemplar;\n\t\t} else {\n\t\t\tthis.observe = this.observeWithoutExemplar;\n\t\t}\n\n\t\tObject.freeze(this.bucketValues);\n\t\tObject.freeze(this.upperBounds);\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: createBaseValues(\n\t\t\t\t\t{},\n\t\t\t\t\tthis.bucketValues,\n\t\t\t\t\tthis.bucketExemplars,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Observe a value in histogram\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe in the histogram\n\t * @returns {void}\n\t */\n\tobserveWithoutExemplar(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tobserveWithExemplar({\n\t\tlabels = this.defaultLabels,\n\t\tvalue,\n\t\texemplarLabels = this.defaultExemplarLabelSet,\n\t} = {}) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t\tthis.updateExemplar(labels, value, exemplarLabels);\n\t}\n\n\tupdateExemplar(labels, value, exemplarLabels) {\n\t\tif (Object.keys(exemplarLabels).length === 0) return;\n\t\tconst hash = hashObject(labels, this.sortedLabelNames);\n\t\tconst bound = findBound(this.upperBounds, value);\n\t\tconst { bucketExemplars } = this.hashMap[hash];\n\t\tlet exemplar = bucketExemplars[bound];\n\t\tif (!isObject(exemplar)) {\n\t\t\texemplar = new Exemplar();\n\t\t\tbucketExemplars[bound] = exemplar;\n\t\t}\n\t\texemplar.validateExemplarLabelSet(exemplarLabels);\n\t\texemplar.labelSet = exemplarLabels;\n\t\texemplar.value = value;\n\t\texemplar.timestamp = nowTimestamp();\n\t}\n\n\tasync get() {\n\t\tconst data = await this.getForPromString();\n\t\tdata.values = data.values.map(splayLabels);\n\t\treturn data;\n\t}\n\n\tasync getForPromString() {\n\t\tif (this.collect) {\n\t\t\tconst v = this.collect();\n\t\t\tif (v instanceof Promise) await v;\n\t\t}\n\t\tconst data = Object.values(this.hashMap);\n\t\tconst values = data\n\t\t\t.map(extractBucketValuesForExport(this))\n\t\t\t.reduce(addSumAndCountForExport(this), []);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype: this.type,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator,\n\t\t};\n\t}\n\n\treset() {\n\t\tthis.hashMap = {};\n\t}\n\n\t/**\n\t * Initialize the metrics for the given combination of labels to zero\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tzero(labels) {\n\t\tconst hash = hashObject(labels, this.sortedLabelNames);\n\t\tthis.hashMap[hash] = createBaseValues(\n\t\t\tlabels,\n\t\t\tthis.bucketValues,\n\t\t\tthis.bucketExemplars,\n\t\t);\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {object} exemplarLabels - Object with labels for exemplar where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = histogram.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t * \tconst duration = end(); //Observe the duration of expensiveXHRRequest and returns duration in seconds\n\t * \tconsole.log('Duration', duration);\n\t * });\n\t */\n\tstartTimer(labels, exemplarLabels) {\n\t\treturn this.enableExemplars\n\t\t\t? startTimerWithExemplar.call(this, labels, exemplarLabels)()\n\t\t\t: startTimer.call(this, labels)();\n\t}\n\n\tlabels(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels),\n\t\t};\n\t}\n\n\tremove(...args) {\n\t\tconst labels = getLabels(this.labelNames, args);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tremoveLabels.call(this, this.hashMap, labels, this.sortedLabelNames);\n\t}\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe(Object.assign({}, startLabels, endLabels), value);\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction startTimerWithExemplar(startLabels, startExemplarLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn (endLabels, endExemplarLabels) => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tconst value = delta[0] + delta[1] / 1e9;\n\t\t\tthis.observe({\n\t\t\t\tlabels: Object.assign({}, startLabels, endLabels),\n\t\t\t\tvalue,\n\t\t\t\texemplarLabels: Object.assign(\n\t\t\t\t\t{},\n\t\t\t\t\tstartExemplarLabels,\n\t\t\t\t\tendExemplarLabels,\n\t\t\t\t),\n\t\t\t});\n\t\t\treturn value;\n\t\t};\n\t};\n}\n\nfunction setValuePair(labels, value, metricName, exemplar, sharedLabels = {}) {\n\treturn {\n\t\tlabels,\n\t\tsharedLabels,\n\t\tvalue,\n\t\tmetricName,\n\t\texemplar,\n\t};\n}\n\nfunction findBound(upperBounds, value) {\n\tfor (let i = 0; i < upperBounds.length; i++) {\n\t\tconst bound = upperBounds[i];\n\t\tif (value <= bound) {\n\t\t\treturn bound;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labelValuePair.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`,\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels, this.sortedLabelNames);\n\t\tlet valueFromMap = this.hashMap[hash];\n\t\tif (!valueFromMap) {\n\t\t\tvalueFromMap = createBaseValues(\n\t\t\t\tlabelValuePair.labels,\n\t\t\t\tthis.bucketValues,\n\t\t\t\tthis.bucketExemplars,\n\t\t\t);\n\t\t}\n\n\t\tconst b = findBound(this.upperBounds, labelValuePair.value);\n\n\t\tvalueFromMap.sum += labelValuePair.value;\n\t\tvalueFromMap.count += 1;\n\n\t\tif (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {\n\t\t\tvalueFromMap.bucketValues[b] += 1;\n\t\t}\n\n\t\tthis.hashMap[hash] = valueFromMap;\n\t};\n}\n\nfunction createBaseValues(labels, bucketValues, bucketExemplars) {\n\tconst result = {\n\t\tlabels,\n\t\tbucketValues: { ...bucketValues },\n\t\tsum: 0,\n\t\tcount: 0,\n\t};\n\tif (bucketExemplars) {\n\t\tresult.bucketExemplars = { ...bucketExemplars };\n\t}\n\treturn result;\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\treturn isObject(labels)\n\t\t? {\n\t\t\t\tlabels,\n\t\t\t\tvalue,\n\t\t\t}\n\t\t: {\n\t\t\t\tvalue: labels,\n\t\t\t\tlabels: {},\n\t\t\t};\n}\n\nfunction extractBucketValuesForExport(histogram) {\n\tconst name = `${histogram.name}_bucket`;\n\treturn bucketData => {\n\t\tlet acc = 0;\n\t\tconst buckets = histogram.upperBounds.map(upperBound => {\n\t\t\tacc += bucketData.bucketValues[upperBound];\n\t\t\treturn setValuePair(\n\t\t\t\t{ le: upperBound },\n\t\t\t\tacc,\n\t\t\t\tname,\n\t\t\t\tbucketData.bucketExemplars\n\t\t\t\t\t? bucketData.bucketExemplars[upperBound]\n\t\t\t\t\t: null,\n\t\t\t\tbucketData.labels,\n\t\t\t);\n\t\t});\n\t\treturn { buckets, data: bucketData };\n\t};\n}\n\nfunction addSumAndCountForExport(histogram) {\n\treturn (acc, d) => {\n\t\tacc.push(...d.buckets);\n\n\t\tconst infLabel = { le: '+Inf' };\n\t\tacc.push(\n\t\t\tsetValuePair(\n\t\t\t\tinfLabel,\n\t\t\t\td.data.count,\n\t\t\t\t`${histogram.name}_bucket`,\n\t\t\t\td.data.bucketExemplars ? d.data.bucketExemplars['-1'] : null,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t\tsetValuePair(\n\t\t\t\t{},\n\t\t\t\td.data.sum,\n\t\t\t\t`${histogram.name}_sum`,\n\t\t\t\tundefined,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t\tsetValuePair(\n\t\t\t\t{},\n\t\t\t\td.data.count,\n\t\t\t\t`${histogram.name}_count`,\n\t\t\t\tundefined,\n\t\t\t\td.data.labels,\n\t\t\t),\n\t\t);\n\t\treturn acc;\n\t};\n}\n\nfunction splayLabels(bucket) {\n\tconst { sharedLabels, labels, ...newBucket } = bucket;\n\tfor (const label of Object.keys(sharedLabels)) {\n\t\tlabels[label] = sharedLabels[label];\n\t}\n\tnewBucket.labels = labels;\n\treturn newBucket;\n}\n\nmodule.exports = Histogram;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}