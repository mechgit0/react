{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return DevServer;\n  }\n});\nconst _requestmeta = require(\"../request-meta\");\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _jestworker = require(\"next/dist/compiled/jest-worker\");\nconst _path = require(\"path\");\nconst _output = require(\"../../build/output\");\nconst _constants = require(\"../../lib/constants\");\nconst _findpagesdir = require(\"../../lib/find-pages-dir\");\nconst _constants1 = require(\"../../shared/lib/constants\");\nconst _nextserver = /*#__PURE__*/_interop_require_wildcard(require(\"../next-server\"));\nconst _normalizepagepath = require(\"../../shared/lib/page-path/normalize-page-path\");\nconst _pathhasprefix = require(\"../../shared/lib/router/utils/path-has-prefix\");\nconst _removepathprefix = require(\"../../shared/lib/router/utils/remove-path-prefix\");\nconst _storage = require(\"../../telemetry/storage\");\nconst _trace = require(\"../../trace\");\nconst _findpagefile = require(\"../lib/find-page-file\");\nconst _utils = require(\"../lib/utils\");\nconst _coalescedfunction = require(\"../../lib/coalesced-function\");\nconst _loaddefaulterrorcomponents = require(\"../load-default-error-components\");\nconst _utils1 = require(\"../../shared/lib/utils\");\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../../build/output/log\"));\nconst _iserror = /*#__PURE__*/_interop_require_wildcard(require(\"../../lib/is-error\"));\nconst _utils2 = require(\"../../build/utils\");\nconst _formatservererror = require(\"../../lib/format-server-error\");\nconst _devroutematchermanager = require(\"../route-matcher-managers/dev-route-matcher-manager\");\nconst _devpagesroutematcherprovider = require(\"../route-matcher-providers/dev/dev-pages-route-matcher-provider\");\nconst _devpagesapiroutematcherprovider = require(\"../route-matcher-providers/dev/dev-pages-api-route-matcher-provider\");\nconst _devapppageroutematcherprovider = require(\"../route-matcher-providers/dev/dev-app-page-route-matcher-provider\");\nconst _devapprouteroutematcherprovider = require(\"../route-matcher-providers/dev/dev-app-route-route-matcher-provider\");\nconst _nodemanifestloader = require(\"../route-matcher-providers/helpers/manifest-loaders/node-manifest-loader\");\nconst _batchedfilereader = require(\"../route-matcher-providers/dev/helpers/file-reader/batched-file-reader\");\nconst _defaultfilereader = require(\"../route-matcher-providers/dev/helpers/file-reader/default-file-reader\");\nconst _lrucache = require(\"../lib/lru-cache\");\nconst _middlewareroutematcher = require(\"../../shared/lib/router/utils/middleware-route-matcher\");\nconst _detachedpromise = require(\"../../lib/detached-promise\");\nconst _ispostpone = require(\"../lib/router-utils/is-postpone\");\nconst _generateinterceptionroutesrewrites = require(\"../../lib/generate-interception-routes-rewrites\");\nconst _buildcustomroute = require(\"../../lib/build-custom-route\");\nconst _errorsource = require(\"../../shared/lib/error-source\");\nconst _logrequests = require(\"./log-requests\");\nconst _fallback = require(\"../../lib/fallback\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n// Load ReactDevOverlay only when needed\nlet ReactDevOverlayImpl;\nconst ReactDevOverlay = props => {\n  if (ReactDevOverlayImpl === undefined) {\n    ReactDevOverlayImpl = require('../../client/components/react-dev-overlay/pages/pages-dev-overlay').PagesDevOverlay;\n  }\n  return ReactDevOverlayImpl(props);\n};\nclass DevServer extends _nextserver.default {\n  getStaticPathsWorker() {\n    const worker = new _jestworker.Worker(require.resolve('./static-paths-worker'), {\n      maxRetries: 1,\n      // For dev server, it's not necessary to spin up too many workers as long as you are not doing a load test.\n      // This helps reusing the memory a lot.\n      numWorkers: 1,\n      enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n      forkOptions: {\n        env: {\n          ...process.env,\n          // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n          // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n          // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n          // is the main Next.js one\n          NODE_OPTIONS: (0, _utils.getFormattedNodeOptionsWithoutInspect)()\n        }\n      }\n    });\n    worker.getStdout().pipe(process.stdout);\n    worker.getStderr().pipe(process.stderr);\n    return worker;\n  }\n  constructor(options) {\n    var _this_nextConfig_experimental_amp, _this_nextConfig_experimental;\n    try {\n      // Increase the number of stack frames on the server\n      Error.stackTraceLimit = 50;\n    } catch {}\n    super({\n      ...options,\n      dev: true\n    }),\n    /**\n    * The promise that resolves when the server is ready. When this is unset\n    * the server is ready.\n    */\n    this.ready = new _detachedpromise.DetachedPromise();\n    this.bundlerService = options.bundlerService;\n    this.startServerSpan = options.startServerSpan ?? (0, _trace.trace)('start-next-dev-server');\n    this.renderOpts.dev = true;\n    this.renderOpts.ErrorDebug = ReactDevOverlay;\n    this.staticPathsCache = new _lrucache.LRUCache(\n    // 5MB\n    5 * 1024 * 1024, function length(value) {\n      var _JSON_stringify;\n      return ((_JSON_stringify = JSON.stringify(value.staticPaths)) == null ? void 0 : _JSON_stringify.length) ?? 0;\n    });\n    this.renderOpts.ampSkipValidation = ((_this_nextConfig_experimental = this.nextConfig.experimental) == null ? void 0 : (_this_nextConfig_experimental_amp = _this_nextConfig_experimental.amp) == null ? void 0 : _this_nextConfig_experimental_amp.skipValidation) ?? false;\n    this.renderOpts.ampValidator = (html, pathname) => {\n      const validatorPath = this.nextConfig.experimental && this.nextConfig.experimental.amp && this.nextConfig.experimental.amp.validator || require.resolve('next/dist/compiled/amphtml-validator/validator_wasm.js');\n      const AmpHtmlValidator = require('next/dist/compiled/amphtml-validator');\n      return AmpHtmlValidator.getInstance(validatorPath).then(validator => {\n        const result = validator.validateString(html);\n        (0, _output.ampValidation)(pathname, result.errors.filter(e => e.severity === 'ERROR').filter(e => this._filterAmpDevelopmentScript(html, e)), result.errors.filter(e => e.severity !== 'ERROR'));\n      });\n    };\n    const {\n      pagesDir,\n      appDir\n    } = (0, _findpagesdir.findPagesDir)(this.dir);\n    this.pagesDir = pagesDir;\n    this.appDir = appDir;\n    if (this.nextConfig.experimental.serverComponentsHmrCache) {\n      this.serverComponentsHmrCache = new _lrucache.LRUCache(this.nextConfig.cacheMaxMemorySize, function length(value) {\n        return JSON.stringify(value).length;\n      });\n    }\n  }\n  getServerComponentsHmrCache() {\n    return this.serverComponentsHmrCache;\n  }\n  getRouteMatchers() {\n    const {\n      pagesDir,\n      appDir\n    } = (0, _findpagesdir.findPagesDir)(this.dir);\n    const ensurer = {\n      ensure: async (match, pathname) => {\n        await this.ensurePage({\n          definition: match.definition,\n          page: match.definition.page,\n          clientOnly: false,\n          url: pathname\n        });\n      }\n    };\n    const matchers = new _devroutematchermanager.DevRouteMatcherManager(super.getRouteMatchers(), ensurer, this.dir);\n    const extensions = this.nextConfig.pageExtensions;\n    const extensionsExpression = new RegExp(`\\\\.(?:${extensions.join('|')})$`);\n    // If the pages directory is available, then configure those matchers.\n    if (pagesDir) {\n      const fileReader = new _batchedfilereader.BatchedFileReader(new _defaultfilereader.DefaultFileReader({\n        // Only allow files that have the correct extensions.\n        pathnameFilter: pathname => extensionsExpression.test(pathname)\n      }));\n      matchers.push(new _devpagesroutematcherprovider.DevPagesRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n      matchers.push(new _devpagesapiroutematcherprovider.DevPagesAPIRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n    }\n    if (appDir) {\n      // We create a new file reader for the app directory because we don't want\n      // to include any folders or files starting with an underscore. This will\n      // prevent the reader from wasting time reading files that we know we\n      // don't care about.\n      const fileReader = new _batchedfilereader.BatchedFileReader(new _defaultfilereader.DefaultFileReader({\n        // Ignore any directory prefixed with an underscore.\n        ignorePartFilter: part => part.startsWith('_')\n      }));\n      matchers.push(new _devapppageroutematcherprovider.DevAppPageRouteMatcherProvider(appDir, extensions, fileReader));\n      matchers.push(new _devapprouteroutematcherprovider.DevAppRouteRouteMatcherProvider(appDir, extensions, fileReader));\n    }\n    return matchers;\n  }\n  getBuildId() {\n    return 'development';\n  }\n  async prepareImpl() {\n    var _this_ready;\n    (0, _trace.setGlobal)('distDir', this.distDir);\n    (0, _trace.setGlobal)('phase', _constants1.PHASE_DEVELOPMENT_SERVER);\n    const telemetry = new _storage.Telemetry({\n      distDir: this.distDir\n    });\n    await super.prepareImpl();\n    await this.matchers.reload();\n    (_this_ready = this.ready) == null ? void 0 : _this_ready.resolve();\n    this.ready = undefined;\n    // In dev, this needs to be called after prepare because the build entries won't be known in the constructor\n    this.interceptionRoutePatterns = this.getinterceptionRoutePatterns();\n    // This is required by the tracing subsystem.\n    (0, _trace.setGlobal)('appDir', this.appDir);\n    (0, _trace.setGlobal)('pagesDir', this.pagesDir);\n    (0, _trace.setGlobal)('telemetry', telemetry);\n    process.on('unhandledRejection', reason => {\n      if ((0, _ispostpone.isPostpone)(reason)) {\n        // React postpones that are unhandled might end up logged here but they're\n        // not really errors. They're just part of rendering.\n        return;\n      }\n      this.logErrorWithOriginalStack(reason, 'unhandledRejection');\n    });\n    process.on('uncaughtException', err => {\n      this.logErrorWithOriginalStack(err, 'uncaughtException');\n    });\n  }\n  async hasPage(pathname) {\n    let normalizedPath;\n    try {\n      normalizedPath = (0, _normalizepagepath.normalizePagePath)(pathname);\n    } catch (err) {\n      console.error(err);\n      // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n      return false;\n    }\n    if ((0, _utils2.isMiddlewareFile)(normalizedPath)) {\n      return (0, _findpagefile.findPageFile)(this.dir, normalizedPath, this.nextConfig.pageExtensions, false).then(Boolean);\n    }\n    let appFile = null;\n    let pagesFile = null;\n    if (this.appDir) {\n      appFile = await (0, _findpagefile.findPageFile)(this.appDir, normalizedPath + '/page', this.nextConfig.pageExtensions, true);\n    }\n    if (this.pagesDir) {\n      pagesFile = await (0, _findpagefile.findPageFile)(this.pagesDir, normalizedPath, this.nextConfig.pageExtensions, false);\n    }\n    if (appFile && pagesFile) {\n      return false;\n    }\n    return Boolean(appFile || pagesFile);\n  }\n  async runMiddleware(params) {\n    try {\n      const result = await super.runMiddleware({\n        ...params,\n        onWarning: warn => {\n          this.logErrorWithOriginalStack(warn, 'warning');\n        }\n      });\n      if ('finished' in result) {\n        return result;\n      }\n      result.waitUntil.catch(error => {\n        this.logErrorWithOriginalStack(error, 'unhandledRejection');\n      });\n      return result;\n    } catch (error) {\n      if (error instanceof _utils1.DecodeError) {\n        throw error;\n      }\n      /**\n      * We only log the error when it is not a MiddlewareNotFound error as\n      * in that case we should be already displaying a compilation error\n      * which is what makes the module not found.\n      */\n      if (!(error instanceof _utils1.MiddlewareNotFoundError)) {\n        this.logErrorWithOriginalStack(error);\n      }\n      const err = (0, _iserror.getProperError)(error);\n      (0, _errorsource.decorateServerError)(err, _constants1.COMPILER_NAMES.edgeServer);\n      const {\n        request,\n        response,\n        parsedUrl\n      } = params;\n      /**\n      * When there is a failure for an internal Next.js request from\n      * middleware we bypass the error without finishing the request\n      * so we can serve the required chunks to render the error.\n      */\n      if (request.url.includes('/_next/static') || request.url.includes('/__nextjs_original-stack-frame') || request.url.includes('/__nextjs_source-map') || request.url.includes('/__nextjs_error_feedback')) {\n        return {\n          finished: false\n        };\n      }\n      response.statusCode = 500;\n      await this.renderError(err, request, response, parsedUrl.pathname);\n      return {\n        finished: true\n      };\n    }\n  }\n  async runEdgeFunction(params) {\n    try {\n      return super.runEdgeFunction({\n        ...params,\n        onError: err => this.logErrorWithOriginalStack(err, 'app-dir'),\n        onWarning: warn => {\n          this.logErrorWithOriginalStack(warn, 'warning');\n        }\n      });\n    } catch (error) {\n      if (error instanceof _utils1.DecodeError) {\n        throw error;\n      }\n      this.logErrorWithOriginalStack(error, 'warning');\n      const err = (0, _iserror.getProperError)(error);\n      const {\n        req,\n        res,\n        page\n      } = params;\n      res.statusCode = 500;\n      await this.renderError(err, req, res, page);\n      return null;\n    }\n  }\n  getRequestHandler() {\n    const handler = super.getRequestHandler();\n    return (req, res, parsedUrl) => {\n      const request = this.normalizeReq(req);\n      const response = this.normalizeRes(res);\n      const loggingConfig = this.nextConfig.logging;\n      if (loggingConfig !== false) {\n        const start = Date.now();\n        const isMiddlewareRequest = (0, _requestmeta.getRequestMeta)(req, 'middlewareInvoke');\n        if (!isMiddlewareRequest) {\n          response.originalResponse.once('close', () => {\n            // NOTE: The route match is only attached to the request's meta data\n            // after the request handler is created, so we need to check it in the\n            // close handler and not before.\n            const routeMatch = (0, _requestmeta.getRequestMeta)(req).match;\n            if (!routeMatch) {\n              return;\n            }\n            (0, _logrequests.logRequests)({\n              request,\n              response,\n              loggingConfig,\n              requestDurationInMs: Date.now() - start\n            });\n          });\n        }\n      }\n      return handler(request, response, parsedUrl);\n    };\n  }\n  async handleRequest(req, res, parsedUrl) {\n    const span = (0, _trace.trace)('handle-request', undefined, {\n      url: req.url\n    });\n    const result = await span.traceAsyncFn(async () => {\n      var _this_ready;\n      await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n      return await super.handleRequest(req, res, parsedUrl);\n    });\n    const memoryUsage = process.memoryUsage();\n    span.traceChild('memory-usage', {\n      url: req.url,\n      'memory.rss': String(memoryUsage.rss),\n      'memory.heapUsed': String(memoryUsage.heapUsed),\n      'memory.heapTotal': String(memoryUsage.heapTotal)\n    }).stop();\n    return result;\n  }\n  async run(req, res, parsedUrl) {\n    var _this_ready;\n    await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n    const {\n      basePath\n    } = this.nextConfig;\n    let originalPathname = null;\n    // TODO: see if we can remove this in the future\n    if (basePath && (0, _pathhasprefix.pathHasPrefix)(parsedUrl.pathname || '/', basePath)) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname;\n      parsedUrl.pathname = (0, _removepathprefix.removePathPrefix)(parsedUrl.pathname || '/', basePath);\n    }\n    const {\n      pathname\n    } = parsedUrl;\n    if (pathname.startsWith('/_next')) {\n      if (_fs.default.existsSync((0, _path.join)(this.publicDir, '_next'))) {\n        throw Object.defineProperty(new Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT), \"__NEXT_ERROR_CODE\", {\n          value: \"E394\",\n          enumerable: false,\n          configurable: true\n        });\n      }\n    }\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname;\n    }\n    try {\n      return await super.run(req, res, parsedUrl);\n    } catch (error) {\n      const err = (0, _iserror.getProperError)(error);\n      (0, _formatservererror.formatServerError)(err);\n      this.logErrorWithOriginalStack(err);\n      if (!res.sent) {\n        res.statusCode = 500;\n        try {\n          return await this.renderError(err, req, res, pathname, {\n            __NEXT_PAGE: (0, _iserror.default)(err) && err.page || pathname || ''\n          });\n        } catch (internalErr) {\n          console.error(internalErr);\n          res.body('Internal Server Error').send();\n        }\n      }\n    }\n  }\n  logErrorWithOriginalStack(err, type) {\n    this.bundlerService.logErrorWithOriginalStack(err, type);\n  }\n  getPagesManifest() {\n    return _nodemanifestloader.NodeManifestLoader.require((0, _path.join)(this.serverDistDir, _constants1.PAGES_MANIFEST)) ?? undefined;\n  }\n  getAppPathsManifest() {\n    if (!this.enabledDirectories.app) return undefined;\n    return _nodemanifestloader.NodeManifestLoader.require((0, _path.join)(this.serverDistDir, _constants1.APP_PATHS_MANIFEST)) ?? undefined;\n  }\n  getinterceptionRoutePatterns() {\n    const rewrites = (0, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(Object.keys(this.appPathRoutes ?? {}), this.nextConfig.basePath).map(route => new RegExp((0, _buildcustomroute.buildCustomRoute)('rewrite', route).regex));\n    if (this.nextConfig.output === 'export' && rewrites.length > 0) {\n      _log.error('Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features');\n      process.exit(1);\n    }\n    return rewrites ?? [];\n  }\n  async getMiddleware() {\n    var _this_middleware;\n    // We need to populate the match\n    // field as it isn't serializable\n    if (((_this_middleware = this.middleware) == null ? void 0 : _this_middleware.match) === null) {\n      this.middleware.match = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(this.middleware.matchers || []);\n    }\n    return this.middleware;\n  }\n  getNextFontManifest() {\n    return undefined;\n  }\n  async hasMiddleware() {\n    return this.hasPage(this.actualMiddlewareFile);\n  }\n  async ensureMiddleware(url) {\n    return this.ensurePage({\n      page: this.actualMiddlewareFile,\n      clientOnly: false,\n      definition: undefined,\n      url\n    });\n  }\n  async loadInstrumentationModule() {\n    let instrumentationModule;\n    if (this.actualInstrumentationHookFile && (await this.ensurePage({\n      page: this.actualInstrumentationHookFile,\n      clientOnly: false,\n      definition: undefined\n    }).then(() => true).catch(() => false))) {\n      try {\n        instrumentationModule = await require((0, _path.join)(this.distDir, 'server', _constants.INSTRUMENTATION_HOOK_FILENAME));\n      } catch (err) {\n        err.message = `An error occurred while loading instrumentation hook: ${err.message}`;\n        throw err;\n      }\n    }\n    return instrumentationModule;\n  }\n  async runInstrumentationHookIfAvailable() {\n    await this.startServerSpan.traceChild('run-instrumentation-hook').traceAsyncFn(() => {\n      var _this_instrumentation_register, _this_instrumentation;\n      return (_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation);\n    });\n  }\n  async ensureEdgeFunction(_ref) {\n    let {\n      page,\n      appPaths,\n      url\n    } = _ref;\n    return this.ensurePage({\n      page,\n      appPaths,\n      clientOnly: false,\n      definition: undefined,\n      url\n    });\n  }\n  generateRoutes(_dev) {\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    // routes.unshift({\n    //   match: getPathMatch('/_next/development/:path*'),\n    //   type: 'route',\n    //   name: '_next/development catchall',\n    //   fn: async (req, res, params) => {\n    //     const p = pathJoin(this.distDir, ...(params.path || []))\n    //     await this.serveStatic(req, res, p)\n    //     return {\n    //       finished: true,\n    //     }\n    //   },\n    // })\n  }\n  _filterAmpDevelopmentScript(html, event) {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true;\n    }\n    const snippetChunks = html.split('\\n');\n    let snippet;\n    if (!(snippet = html.split('\\n')[event.line - 1]) || !(snippet = snippet.substring(event.col))) {\n      return true;\n    }\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n');\n    snippet = snippet.substring(0, snippet.indexOf('</script>'));\n    return !snippet.includes('data-amp-development-mode-only');\n  }\n  async getStaticPaths(_ref2) {\n    let {\n      pathname,\n      requestHeaders,\n      page,\n      isAppPath\n    } = _ref2;\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n    const __getStaticPaths = async () => {\n      const {\n        configFileName,\n        publicRuntimeConfig,\n        serverRuntimeConfig,\n        httpAgentOptions\n      } = this.nextConfig;\n      const {\n        locales,\n        defaultLocale\n      } = this.nextConfig.i18n || {};\n      const staticPathsWorker = this.getStaticPathsWorker();\n      try {\n        var _this_nextConfig_experimental_sri;\n        const pathsResult = await staticPathsWorker.loadStaticPaths({\n          dir: this.dir,\n          distDir: this.distDir,\n          pathname,\n          config: {\n            pprConfig: this.nextConfig.experimental.ppr,\n            configFileName,\n            publicRuntimeConfig,\n            serverRuntimeConfig,\n            dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO)\n          },\n          httpAgentOptions,\n          locales,\n          defaultLocale,\n          page,\n          isAppPath,\n          requestHeaders,\n          cacheHandler: this.nextConfig.cacheHandler,\n          cacheHandlers: this.nextConfig.experimental.cacheHandlers,\n          cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n          fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n          isrFlushToDisk: this.nextConfig.experimental.isrFlushToDisk,\n          maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n          nextConfigOutput: this.nextConfig.output,\n          buildId: this.buildId,\n          authInterrupts: Boolean(this.nextConfig.experimental.authInterrupts),\n          sriEnabled: Boolean((_this_nextConfig_experimental_sri = this.nextConfig.experimental.sri) == null ? void 0 : _this_nextConfig_experimental_sri.algorithm)\n        });\n        return pathsResult;\n      } finally {\n        // we don't re-use workers so destroy the used one\n        staticPathsWorker.end();\n      }\n    };\n    const result = this.staticPathsCache.get(pathname);\n    const nextInvoke = (0, _coalescedfunction.withCoalescedInvoke)(__getStaticPaths)(`staticPaths-${pathname}`, []).then(res => {\n      const {\n        prerenderedRoutes: staticPaths,\n        fallbackMode: fallback\n      } = res.value;\n      if (!isAppPath && this.nextConfig.output === 'export') {\n        if (fallback === _fallback.FallbackMode.BLOCKING_STATIC_RENDER) {\n          throw Object.defineProperty(new Error('getStaticPaths with \"fallback: blocking\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n            value: \"E11\",\n            enumerable: false,\n            configurable: true\n          });\n        } else if (fallback === _fallback.FallbackMode.PRERENDER) {\n          throw Object.defineProperty(new Error('getStaticPaths with \"fallback: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n            value: \"E210\",\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n      const value = {\n        staticPaths: staticPaths == null ? void 0 : staticPaths.map(route => route.pathname),\n        fallbackMode: fallback\n      };\n      this.staticPathsCache.set(pathname, value);\n      return value;\n    }).catch(err => {\n      this.staticPathsCache.remove(pathname);\n      if (!result) throw err;\n      _log.error(`Failed to generate static paths for ${pathname}:`);\n      console.error(err);\n    });\n    if (result) {\n      return result;\n    }\n    return nextInvoke;\n  }\n  async ensurePage(opts) {\n    await this.bundlerService.ensurePage(opts);\n  }\n  async findPageComponents(_ref3) {\n    let {\n      locale,\n      page,\n      query,\n      params,\n      isAppPath,\n      appPaths = null,\n      shouldEnsure,\n      url\n    } = _ref3;\n    var _this_ready;\n    await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n    const compilationErr = await this.getCompilationError(page);\n    if (compilationErr) {\n      // Wrap build errors so that they don't get logged again\n      throw new _nextserver.WrappedBuildError(compilationErr);\n    }\n    if (shouldEnsure || this.serverOptions.customServer) {\n      await this.ensurePage({\n        page,\n        appPaths,\n        clientOnly: false,\n        definition: undefined,\n        url\n      });\n    }\n    this.nextFontManifest = super.getNextFontManifest();\n    return await super.findPageComponents({\n      page,\n      query,\n      params,\n      locale,\n      isAppPath,\n      shouldEnsure,\n      url\n    });\n  }\n  async getFallbackErrorComponents(url) {\n    await this.bundlerService.getFallbackErrorComponents(url);\n    return await (0, _loaddefaulterrorcomponents.loadDefaultErrorComponents)(this.distDir);\n  }\n  async getCompilationError(page) {\n    return await this.bundlerService.getCompilationError(page);\n  }\n  async instrumentationOnRequestError() {\n    await super.instrumentationOnRequestError(...arguments);\n    const err = arguments.length <= 0 ? undefined : arguments[0];\n    this.logErrorWithOriginalStack(err, 'app-dir');\n  }\n}","map":{"version":3,"names":["DevServer","ReactDevOverlayImpl","ReactDevOverlay","props","undefined","require","PagesDevOverlay","_nextserver","default","getStaticPathsWorker","worker","_jestworker","Worker","resolve","maxRetries","numWorkers","enableWorkerThreads","nextConfig","experimental","workerThreads","forkOptions","env","process","NODE_OPTIONS","_utils","getFormattedNodeOptionsWithoutInspect","getStdout","pipe","stdout","getStderr","stderr","constructor","options","_this_nextConfig_experimental_amp","_this_nextConfig_experimental","Error","stackTraceLimit","dev","ready","_detachedpromise","DetachedPromise","bundlerService","startServerSpan","_trace","trace","renderOpts","ErrorDebug","staticPathsCache","_lrucache","LRUCache","length","value","_JSON_stringify","JSON","stringify","staticPaths","ampSkipValidation","amp","skipValidation","ampValidator","html","pathname","validatorPath","validator","AmpHtmlValidator","getInstance","then","result","validateString","_output","ampValidation","errors","filter","e","severity","_filterAmpDevelopmentScript","pagesDir","appDir","_findpagesdir","findPagesDir","dir","serverComponentsHmrCache","cacheMaxMemorySize","getServerComponentsHmrCache","getRouteMatchers","ensurer","ensure","match","ensurePage","definition","page","clientOnly","url","matchers","_devroutematchermanager","DevRouteMatcherManager","extensions","pageExtensions","extensionsExpression","RegExp","join","fileReader","_batchedfilereader","BatchedFileReader","_defaultfilereader","DefaultFileReader","pathnameFilter","test","push","_devpagesroutematcherprovider","DevPagesRouteMatcherProvider","localeNormalizer","_devpagesapiroutematcherprovider","DevPagesAPIRouteMatcherProvider","ignorePartFilter","part","startsWith","_devapppageroutematcherprovider","DevAppPageRouteMatcherProvider","_devapprouteroutematcherprovider","DevAppRouteRouteMatcherProvider","getBuildId","prepareImpl","_this_ready","setGlobal","distDir","_constants1","PHASE_DEVELOPMENT_SERVER","telemetry","_storage","Telemetry","reload","interceptionRoutePatterns","getinterceptionRoutePatterns","on","reason","_ispostpone","isPostpone","logErrorWithOriginalStack","err","hasPage","normalizedPath","_normalizepagepath","normalizePagePath","console","error","_utils2","isMiddlewareFile","_findpagefile","findPageFile","Boolean","appFile","pagesFile","runMiddleware","params","onWarning","warn","waitUntil","catch","_utils1","DecodeError","MiddlewareNotFoundError","_iserror","getProperError","_errorsource","decorateServerError","COMPILER_NAMES","edgeServer","request","response","parsedUrl","includes","finished","statusCode","renderError","runEdgeFunction","onError","req","res","getRequestHandler","handler","normalizeReq","normalizeRes","loggingConfig","logging","start","Date","now","isMiddlewareRequest","_requestmeta","getRequestMeta","originalResponse","once","routeMatch","_logrequests","logRequests","requestDurationInMs","handleRequest","span","traceAsyncFn","promise","memoryUsage","traceChild","String","rss","heapUsed","heapTotal","stop","run","basePath","originalPathname","_pathhasprefix","pathHasPrefix","_removepathprefix","removePathPrefix","_fs","existsSync","_path","publicDir","Object","defineProperty","_constants","PUBLIC_DIR_MIDDLEWARE_CONFLICT","_formatservererror","formatServerError","sent","__NEXT_PAGE","internalErr","body","send","type","getPagesManifest","_nodemanifestloader","NodeManifestLoader","serverDistDir","PAGES_MANIFEST","getAppPathsManifest","enabledDirectories","app","APP_PATHS_MANIFEST","rewrites","_generateinterceptionroutesrewrites","generateInterceptionRoutesRewrites","keys","appPathRoutes","map","route","_buildcustomroute","buildCustomRoute","regex","output","_log","exit","getMiddleware","_this_middleware","middleware","_middlewareroutematcher","getMiddlewareRouteMatcher","getNextFontManifest","hasMiddleware","actualMiddlewareFile","ensureMiddleware","loadInstrumentationModule","instrumentationModule","actualInstrumentationHookFile","INSTRUMENTATION_HOOK_FILENAME","message","runInstrumentationHookIfAvailable","_this_instrumentation_register","_this_instrumentation","instrumentation","register","call","ensureEdgeFunction","_ref","appPaths","generateRoutes","_dev","event","code","snippetChunks","split","snippet","line","substring","col","slice","indexOf","getStaticPaths","_ref2","requestHeaders","isAppPath","__getStaticPaths","configFileName","publicRuntimeConfig","serverRuntimeConfig","httpAgentOptions","locales","defaultLocale","i18n","staticPathsWorker","_this_nextConfig_experimental_sri","pathsResult","loadStaticPaths","config","pprConfig","ppr","dynamicIO","cacheHandler","cacheHandlers","cacheLifeProfiles","cacheLife","fetchCacheKeyPrefix","isrFlushToDisk","maxMemoryCacheSize","nextConfigOutput","buildId","authInterrupts","sriEnabled","sri","algorithm","end","get","nextInvoke","_coalescedfunction","withCoalescedInvoke","prerenderedRoutes","fallbackMode","fallback","_fallback","FallbackMode","BLOCKING_STATIC_RENDER","PRERENDER","set","remove","opts","findPageComponents","_ref3","locale","query","shouldEnsure","compilationErr","getCompilationError","WrappedBuildError","serverOptions","customServer","nextFontManifest","getFallbackErrorComponents","_loaddefaulterrorcomponents","loadDefaultErrorComponents","instrumentationOnRequestError","arguments"],"sources":["/home/ashish/my-react-app/node_modules/next/src/server/dev/next-dev-server.ts"],"sourcesContent":["import type { FindComponentsResult, NodeRequestHandler } from '../next-server'\nimport type { LoadComponentsReturnType } from '../load-components'\nimport type { Options as ServerOptions } from '../next-server'\nimport type { Params } from '../request/params'\nimport type { ParsedUrl } from '../../shared/lib/router/utils/parse-url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { MiddlewareRoutingItem } from '../base-server'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { RouteMatcherManager } from '../route-matcher-managers/route-matcher-manager'\nimport {\n  getRequestMeta,\n  type NextParsedUrlQuery,\n  type NextUrlWithParsedQuery,\n} from '../request-meta'\nimport type { DevBundlerService } from '../lib/dev-bundler-service'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { UnwrapPromise } from '../../lib/coalesced-function'\nimport type { NodeNextResponse, NodeNextRequest } from '../base-http/node'\nimport type { RouteEnsurer } from '../route-matcher-managers/dev-route-matcher-manager'\nimport type { PagesManifest } from '../../build/webpack/plugins/pages-manifest-plugin'\n\nimport fs from 'fs'\nimport { Worker } from 'next/dist/compiled/jest-worker'\nimport { join as pathJoin } from 'path'\nimport { ampValidation } from '../../build/output'\nimport {\n  INSTRUMENTATION_HOOK_FILENAME,\n  PUBLIC_DIR_MIDDLEWARE_CONFLICT,\n} from '../../lib/constants'\nimport { findPagesDir } from '../../lib/find-pages-dir'\nimport {\n  PHASE_DEVELOPMENT_SERVER,\n  PAGES_MANIFEST,\n  APP_PATHS_MANIFEST,\n  COMPILER_NAMES,\n} from '../../shared/lib/constants'\nimport Server, { WrappedBuildError } from '../next-server'\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { Telemetry } from '../../telemetry/storage'\nimport { type Span, setGlobal, trace } from '../../trace'\nimport { findPageFile } from '../lib/find-page-file'\nimport { getFormattedNodeOptionsWithoutInspect } from '../lib/utils'\nimport { withCoalescedInvoke } from '../../lib/coalesced-function'\nimport { loadDefaultErrorComponents } from '../load-default-error-components'\nimport { DecodeError, MiddlewareNotFoundError } from '../../shared/lib/utils'\nimport * as Log from '../../build/output/log'\nimport isError, { getProperError } from '../../lib/is-error'\nimport { isMiddlewareFile } from '../../build/utils'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { DevRouteMatcherManager } from '../route-matcher-managers/dev-route-matcher-manager'\nimport { DevPagesRouteMatcherProvider } from '../route-matcher-providers/dev/dev-pages-route-matcher-provider'\nimport { DevPagesAPIRouteMatcherProvider } from '../route-matcher-providers/dev/dev-pages-api-route-matcher-provider'\nimport { DevAppPageRouteMatcherProvider } from '../route-matcher-providers/dev/dev-app-page-route-matcher-provider'\nimport { DevAppRouteRouteMatcherProvider } from '../route-matcher-providers/dev/dev-app-route-route-matcher-provider'\nimport { NodeManifestLoader } from '../route-matcher-providers/helpers/manifest-loaders/node-manifest-loader'\nimport { BatchedFileReader } from '../route-matcher-providers/dev/helpers/file-reader/batched-file-reader'\nimport { DefaultFileReader } from '../route-matcher-providers/dev/helpers/file-reader/default-file-reader'\nimport { LRUCache } from '../lib/lru-cache'\nimport { getMiddlewareRouteMatcher } from '../../shared/lib/router/utils/middleware-route-matcher'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { isPostpone } from '../lib/router-utils/is-postpone'\nimport { generateInterceptionRoutesRewrites } from '../../lib/generate-interception-routes-rewrites'\nimport { buildCustomRoute } from '../../lib/build-custom-route'\nimport { decorateServerError } from '../../shared/lib/error-source'\nimport type { ServerOnInstrumentationRequestError } from '../app-render/types'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport { logRequests } from './log-requests'\nimport { FallbackMode } from '../../lib/fallback'\nimport type { PagesDevOverlayType } from '../../client/components/react-dev-overlay/pages/pages-dev-overlay'\n\n// Load ReactDevOverlay only when needed\nlet ReactDevOverlayImpl: PagesDevOverlayType\nconst ReactDevOverlay: PagesDevOverlayType = (props) => {\n  if (ReactDevOverlayImpl === undefined) {\n    ReactDevOverlayImpl =\n      require('../../client/components/react-dev-overlay/pages/pages-dev-overlay')\n        .PagesDevOverlay as PagesDevOverlayType\n  }\n  return ReactDevOverlayImpl(props)\n}\n\nexport interface Options extends ServerOptions {\n  /**\n   * Tells of Next.js is running from the `next dev` command\n   */\n  isNextDevCommand?: boolean\n\n  /**\n   * Interface to the development bundler.\n   */\n  bundlerService: DevBundlerService\n\n  /**\n   * Trace span for server startup.\n   */\n  startServerSpan: Span\n}\n\nexport default class DevServer extends Server {\n  /**\n   * The promise that resolves when the server is ready. When this is unset\n   * the server is ready.\n   */\n  private ready? = new DetachedPromise<void>()\n  protected sortedRoutes?: string[]\n  private pagesDir?: string\n  private appDir?: string\n  private actualMiddlewareFile?: string\n  private actualInstrumentationHookFile?: string\n  private middleware?: MiddlewareRoutingItem\n  private originalFetch?: typeof fetch\n  private readonly bundlerService: DevBundlerService\n  private staticPathsCache: LRUCache<\n    UnwrapPromise<ReturnType<DevServer['getStaticPaths']>>\n  >\n  private startServerSpan: Span\n  private readonly serverComponentsHmrCache:\n    | ServerComponentsHmrCache\n    | undefined\n\n  protected staticPathsWorker?: { [key: string]: any } & {\n    loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n  }\n\n  private getStaticPathsWorker(): { [key: string]: any } & {\n    loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n  } {\n    const worker = new Worker(require.resolve('./static-paths-worker'), {\n      maxRetries: 1,\n      // For dev server, it's not necessary to spin up too many workers as long as you are not doing a load test.\n      // This helps reusing the memory a lot.\n      numWorkers: 1,\n      enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n      forkOptions: {\n        env: {\n          ...process.env,\n          // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n          // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n          // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n          // is the main Next.js one\n          NODE_OPTIONS: getFormattedNodeOptionsWithoutInspect(),\n        },\n      },\n    }) as Worker & {\n      loadStaticPaths: typeof import('./static-paths-worker').loadStaticPaths\n    }\n\n    worker.getStdout().pipe(process.stdout)\n    worker.getStderr().pipe(process.stderr)\n\n    return worker\n  }\n\n  constructor(options: Options) {\n    try {\n      // Increase the number of stack frames on the server\n      Error.stackTraceLimit = 50\n    } catch {}\n    super({ ...options, dev: true })\n    this.bundlerService = options.bundlerService\n    this.startServerSpan =\n      options.startServerSpan ?? trace('start-next-dev-server')\n    this.renderOpts.dev = true\n    this.renderOpts.ErrorDebug = ReactDevOverlay\n    this.staticPathsCache = new LRUCache(\n      // 5MB\n      5 * 1024 * 1024,\n      function length(value) {\n        return JSON.stringify(value.staticPaths)?.length ?? 0\n      }\n    )\n    this.renderOpts.ampSkipValidation =\n      this.nextConfig.experimental?.amp?.skipValidation ?? false\n    this.renderOpts.ampValidator = (html: string, pathname: string) => {\n      const validatorPath =\n        (this.nextConfig.experimental &&\n          this.nextConfig.experimental.amp &&\n          this.nextConfig.experimental.amp.validator) ||\n        require.resolve(\n          'next/dist/compiled/amphtml-validator/validator_wasm.js'\n        )\n\n      const AmpHtmlValidator =\n        require('next/dist/compiled/amphtml-validator') as typeof import('next/dist/compiled/amphtml-validator')\n      return AmpHtmlValidator.getInstance(validatorPath).then((validator) => {\n        const result = validator.validateString(html)\n        ampValidation(\n          pathname,\n          result.errors\n            .filter((e) => e.severity === 'ERROR')\n            .filter((e) => this._filterAmpDevelopmentScript(html, e)),\n          result.errors.filter((e) => e.severity !== 'ERROR')\n        )\n      })\n    }\n\n    const { pagesDir, appDir } = findPagesDir(this.dir)\n    this.pagesDir = pagesDir\n    this.appDir = appDir\n\n    if (this.nextConfig.experimental.serverComponentsHmrCache) {\n      this.serverComponentsHmrCache = new LRUCache(\n        this.nextConfig.cacheMaxMemorySize,\n        function length(value) {\n          return JSON.stringify(value).length\n        }\n      )\n    }\n  }\n\n  protected override getServerComponentsHmrCache() {\n    return this.serverComponentsHmrCache\n  }\n\n  protected getRouteMatchers(): RouteMatcherManager {\n    const { pagesDir, appDir } = findPagesDir(this.dir)\n\n    const ensurer: RouteEnsurer = {\n      ensure: async (match, pathname) => {\n        await this.ensurePage({\n          definition: match.definition,\n          page: match.definition.page,\n          clientOnly: false,\n          url: pathname,\n        })\n      },\n    }\n\n    const matchers = new DevRouteMatcherManager(\n      super.getRouteMatchers(),\n      ensurer,\n      this.dir\n    )\n    const extensions = this.nextConfig.pageExtensions\n    const extensionsExpression = new RegExp(`\\\\.(?:${extensions.join('|')})$`)\n\n    // If the pages directory is available, then configure those matchers.\n    if (pagesDir) {\n      const fileReader = new BatchedFileReader(\n        new DefaultFileReader({\n          // Only allow files that have the correct extensions.\n          pathnameFilter: (pathname) => extensionsExpression.test(pathname),\n        })\n      )\n\n      matchers.push(\n        new DevPagesRouteMatcherProvider(\n          pagesDir,\n          extensions,\n          fileReader,\n          this.localeNormalizer\n        )\n      )\n      matchers.push(\n        new DevPagesAPIRouteMatcherProvider(\n          pagesDir,\n          extensions,\n          fileReader,\n          this.localeNormalizer\n        )\n      )\n    }\n\n    if (appDir) {\n      // We create a new file reader for the app directory because we don't want\n      // to include any folders or files starting with an underscore. This will\n      // prevent the reader from wasting time reading files that we know we\n      // don't care about.\n      const fileReader = new BatchedFileReader(\n        new DefaultFileReader({\n          // Ignore any directory prefixed with an underscore.\n          ignorePartFilter: (part) => part.startsWith('_'),\n        })\n      )\n\n      matchers.push(\n        new DevAppPageRouteMatcherProvider(appDir, extensions, fileReader)\n      )\n      matchers.push(\n        new DevAppRouteRouteMatcherProvider(appDir, extensions, fileReader)\n      )\n    }\n\n    return matchers\n  }\n\n  protected getBuildId(): string {\n    return 'development'\n  }\n\n  protected async prepareImpl(): Promise<void> {\n    setGlobal('distDir', this.distDir)\n    setGlobal('phase', PHASE_DEVELOPMENT_SERVER)\n\n    const telemetry = new Telemetry({ distDir: this.distDir })\n\n    await super.prepareImpl()\n    await this.matchers.reload()\n\n    this.ready?.resolve()\n    this.ready = undefined\n\n    // In dev, this needs to be called after prepare because the build entries won't be known in the constructor\n    this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()\n\n    // This is required by the tracing subsystem.\n    setGlobal('appDir', this.appDir)\n    setGlobal('pagesDir', this.pagesDir)\n    setGlobal('telemetry', telemetry)\n\n    process.on('unhandledRejection', (reason) => {\n      if (isPostpone(reason)) {\n        // React postpones that are unhandled might end up logged here but they're\n        // not really errors. They're just part of rendering.\n        return\n      }\n      this.logErrorWithOriginalStack(reason, 'unhandledRejection')\n    })\n    process.on('uncaughtException', (err) => {\n      this.logErrorWithOriginalStack(err, 'uncaughtException')\n    })\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let normalizedPath: string\n    try {\n      normalizedPath = normalizePagePath(pathname)\n    } catch (err) {\n      console.error(err)\n      // if normalizing the page fails it means it isn't valid\n      // so it doesn't exist so don't throw and return false\n      // to ensure we return 404 instead of 500\n      return false\n    }\n\n    if (isMiddlewareFile(normalizedPath)) {\n      return findPageFile(\n        this.dir,\n        normalizedPath,\n        this.nextConfig.pageExtensions,\n        false\n      ).then(Boolean)\n    }\n\n    let appFile: string | null = null\n    let pagesFile: string | null = null\n\n    if (this.appDir) {\n      appFile = await findPageFile(\n        this.appDir,\n        normalizedPath + '/page',\n        this.nextConfig.pageExtensions,\n        true\n      )\n    }\n\n    if (this.pagesDir) {\n      pagesFile = await findPageFile(\n        this.pagesDir,\n        normalizedPath,\n        this.nextConfig.pageExtensions,\n        false\n      )\n    }\n    if (appFile && pagesFile) {\n      return false\n    }\n\n    return Boolean(appFile || pagesFile)\n  }\n\n  async runMiddleware(params: {\n    request: NodeNextRequest\n    response: NodeNextResponse\n    parsedUrl: ParsedUrl\n    parsed: UrlWithParsedQuery\n    middlewareList: MiddlewareRoutingItem[]\n  }) {\n    try {\n      const result = await super.runMiddleware({\n        ...params,\n        onWarning: (warn) => {\n          this.logErrorWithOriginalStack(warn, 'warning')\n        },\n      })\n\n      if ('finished' in result) {\n        return result\n      }\n\n      result.waitUntil.catch((error) => {\n        this.logErrorWithOriginalStack(error, 'unhandledRejection')\n      })\n      return result\n    } catch (error) {\n      if (error instanceof DecodeError) {\n        throw error\n      }\n\n      /**\n       * We only log the error when it is not a MiddlewareNotFound error as\n       * in that case we should be already displaying a compilation error\n       * which is what makes the module not found.\n       */\n      if (!(error instanceof MiddlewareNotFoundError)) {\n        this.logErrorWithOriginalStack(error)\n      }\n\n      const err = getProperError(error)\n      decorateServerError(err, COMPILER_NAMES.edgeServer)\n      const { request, response, parsedUrl } = params\n\n      /**\n       * When there is a failure for an internal Next.js request from\n       * middleware we bypass the error without finishing the request\n       * so we can serve the required chunks to render the error.\n       */\n      if (\n        request.url.includes('/_next/static') ||\n        request.url.includes('/__nextjs_original-stack-frame') ||\n        request.url.includes('/__nextjs_source-map') ||\n        request.url.includes('/__nextjs_error_feedback')\n      ) {\n        return { finished: false }\n      }\n\n      response.statusCode = 500\n      await this.renderError(err, request, response, parsedUrl.pathname)\n      return { finished: true }\n    }\n  }\n\n  async runEdgeFunction(params: {\n    req: NodeNextRequest\n    res: NodeNextResponse\n    query: ParsedUrlQuery\n    params: Params | undefined\n    page: string\n    appPaths: string[] | null\n    isAppPath: boolean\n  }) {\n    try {\n      return super.runEdgeFunction({\n        ...params,\n        onError: (err) => this.logErrorWithOriginalStack(err, 'app-dir'),\n        onWarning: (warn) => {\n          this.logErrorWithOriginalStack(warn, 'warning')\n        },\n      })\n    } catch (error) {\n      if (error instanceof DecodeError) {\n        throw error\n      }\n      this.logErrorWithOriginalStack(error, 'warning')\n      const err = getProperError(error)\n      const { req, res, page } = params\n\n      res.statusCode = 500\n      await this.renderError(err, req, res, page)\n      return null\n    }\n  }\n\n  public getRequestHandler(): NodeRequestHandler {\n    const handler = super.getRequestHandler()\n\n    return (req, res, parsedUrl) => {\n      const request = this.normalizeReq(req)\n      const response = this.normalizeRes(res)\n      const loggingConfig = this.nextConfig.logging\n\n      if (loggingConfig !== false) {\n        const start = Date.now()\n        const isMiddlewareRequest = getRequestMeta(req, 'middlewareInvoke')\n\n        if (!isMiddlewareRequest) {\n          response.originalResponse.once('close', () => {\n            // NOTE: The route match is only attached to the request's meta data\n            // after the request handler is created, so we need to check it in the\n            // close handler and not before.\n            const routeMatch = getRequestMeta(req).match\n\n            if (!routeMatch) {\n              return\n            }\n\n            logRequests({\n              request,\n              response,\n              loggingConfig,\n              requestDurationInMs: Date.now() - start,\n            })\n          })\n        }\n      }\n\n      return handler(request, response, parsedUrl)\n    }\n  }\n\n  public async handleRequest(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    const span = trace('handle-request', undefined, { url: req.url })\n    const result = await span.traceAsyncFn(async () => {\n      await this.ready?.promise\n      return await super.handleRequest(req, res, parsedUrl)\n    })\n    const memoryUsage = process.memoryUsage()\n    span\n      .traceChild('memory-usage', {\n        url: req.url,\n        'memory.rss': String(memoryUsage.rss),\n        'memory.heapUsed': String(memoryUsage.heapUsed),\n        'memory.heapTotal': String(memoryUsage.heapTotal),\n      })\n      .stop()\n    return result\n  }\n\n  async run(\n    req: NodeNextRequest,\n    res: NodeNextResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    await this.ready?.promise\n\n    const { basePath } = this.nextConfig\n    let originalPathname: string | null = null\n\n    // TODO: see if we can remove this in the future\n    if (basePath && pathHasPrefix(parsedUrl.pathname || '/', basePath)) {\n      // strip basePath before handling dev bundles\n      // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n      originalPathname = parsedUrl.pathname\n      parsedUrl.pathname = removePathPrefix(parsedUrl.pathname || '/', basePath)\n    }\n\n    const { pathname } = parsedUrl\n\n    if (pathname!.startsWith('/_next')) {\n      if (fs.existsSync(pathJoin(this.publicDir, '_next'))) {\n        throw new Error(PUBLIC_DIR_MIDDLEWARE_CONFLICT)\n      }\n    }\n\n    if (originalPathname) {\n      // restore the path before continuing so that custom-routes can accurately determine\n      // if they should match against the basePath or not\n      parsedUrl.pathname = originalPathname\n    }\n    try {\n      return await super.run(req, res, parsedUrl)\n    } catch (error) {\n      const err = getProperError(error)\n      formatServerError(err)\n      this.logErrorWithOriginalStack(err)\n      if (!res.sent) {\n        res.statusCode = 500\n        try {\n          return await this.renderError(err, req, res, pathname!, {\n            __NEXT_PAGE: (isError(err) && err.page) || pathname || '',\n          })\n        } catch (internalErr) {\n          console.error(internalErr)\n          res.body('Internal Server Error').send()\n        }\n      }\n    }\n  }\n\n  protected logErrorWithOriginalStack(\n    err?: unknown,\n    type?: 'unhandledRejection' | 'uncaughtException' | 'warning' | 'app-dir'\n  ): void {\n    this.bundlerService.logErrorWithOriginalStack(err, type)\n  }\n\n  protected getPagesManifest(): PagesManifest | undefined {\n    return (\n      NodeManifestLoader.require(\n        pathJoin(this.serverDistDir, PAGES_MANIFEST)\n      ) ?? undefined\n    )\n  }\n\n  protected getAppPathsManifest(): PagesManifest | undefined {\n    if (!this.enabledDirectories.app) return undefined\n\n    return (\n      NodeManifestLoader.require(\n        pathJoin(this.serverDistDir, APP_PATHS_MANIFEST)\n      ) ?? undefined\n    )\n  }\n\n  protected getinterceptionRoutePatterns(): RegExp[] {\n    const rewrites = generateInterceptionRoutesRewrites(\n      Object.keys(this.appPathRoutes ?? {}),\n      this.nextConfig.basePath\n    ).map((route) => new RegExp(buildCustomRoute('rewrite', route).regex))\n\n    if (this.nextConfig.output === 'export' && rewrites.length > 0) {\n      Log.error(\n        'Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features'\n      )\n\n      process.exit(1)\n    }\n\n    return rewrites ?? []\n  }\n\n  protected async getMiddleware() {\n    // We need to populate the match\n    // field as it isn't serializable\n    if (this.middleware?.match === null) {\n      this.middleware.match = getMiddlewareRouteMatcher(\n        this.middleware.matchers || []\n      )\n    }\n    return this.middleware\n  }\n\n  protected getNextFontManifest() {\n    return undefined\n  }\n\n  protected async hasMiddleware(): Promise<boolean> {\n    return this.hasPage(this.actualMiddlewareFile!)\n  }\n\n  protected async ensureMiddleware(url: string) {\n    return this.ensurePage({\n      page: this.actualMiddlewareFile!,\n      clientOnly: false,\n      definition: undefined,\n      url,\n    })\n  }\n\n  protected async loadInstrumentationModule(): Promise<any> {\n    let instrumentationModule: any\n    if (\n      this.actualInstrumentationHookFile &&\n      (await this.ensurePage({\n        page: this.actualInstrumentationHookFile!,\n        clientOnly: false,\n        definition: undefined,\n      })\n        .then(() => true)\n        .catch(() => false))\n    ) {\n      try {\n        instrumentationModule = await require(\n          pathJoin(this.distDir, 'server', INSTRUMENTATION_HOOK_FILENAME)\n        )\n      } catch (err: any) {\n        err.message = `An error occurred while loading instrumentation hook: ${err.message}`\n        throw err\n      }\n    }\n    return instrumentationModule\n  }\n\n  protected async runInstrumentationHookIfAvailable() {\n    await this.startServerSpan\n      .traceChild('run-instrumentation-hook')\n      .traceAsyncFn(() => this.instrumentation?.register?.())\n  }\n\n  protected async ensureEdgeFunction({\n    page,\n    appPaths,\n    url,\n  }: {\n    page: string\n    appPaths: string[] | null\n    url: string\n  }) {\n    return this.ensurePage({\n      page,\n      appPaths,\n      clientOnly: false,\n      definition: undefined,\n      url,\n    })\n  }\n\n  generateRoutes(_dev?: boolean) {\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    // routes.unshift({\n    //   match: getPathMatch('/_next/development/:path*'),\n    //   type: 'route',\n    //   name: '_next/development catchall',\n    //   fn: async (req, res, params) => {\n    //     const p = pathJoin(this.distDir, ...(params.path || []))\n    //     await this.serveStatic(req, res, p)\n    //     return {\n    //       finished: true,\n    //     }\n    //   },\n    // })\n  }\n\n  _filterAmpDevelopmentScript(\n    html: string,\n    event: { line: number; col: number; code: string }\n  ): boolean {\n    if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n      return true\n    }\n\n    const snippetChunks = html.split('\\n')\n\n    let snippet\n    if (\n      !(snippet = html.split('\\n')[event.line - 1]) ||\n      !(snippet = snippet.substring(event.col))\n    ) {\n      return true\n    }\n\n    snippet = snippet + snippetChunks.slice(event.line).join('\\n')\n    snippet = snippet.substring(0, snippet.indexOf('</script>'))\n\n    return !snippet.includes('data-amp-development-mode-only')\n  }\n\n  protected async getStaticPaths({\n    pathname,\n    requestHeaders,\n    page,\n    isAppPath,\n  }: {\n    pathname: string\n    requestHeaders: IncrementalCache['requestHeaders']\n    page: string\n    isAppPath: boolean\n  }): Promise<{\n    staticPaths?: string[]\n    fallbackMode?: FallbackMode\n  }> {\n    // we lazy load the staticPaths to prevent the user\n    // from waiting on them for the page to load in dev mode\n\n    const __getStaticPaths = async () => {\n      const {\n        configFileName,\n        publicRuntimeConfig,\n        serverRuntimeConfig,\n        httpAgentOptions,\n      } = this.nextConfig\n      const { locales, defaultLocale } = this.nextConfig.i18n || {}\n      const staticPathsWorker = this.getStaticPathsWorker()\n\n      try {\n        const pathsResult = await staticPathsWorker.loadStaticPaths({\n          dir: this.dir,\n          distDir: this.distDir,\n          pathname,\n          config: {\n            pprConfig: this.nextConfig.experimental.ppr,\n            configFileName,\n            publicRuntimeConfig,\n            serverRuntimeConfig,\n            dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO),\n          },\n          httpAgentOptions,\n          locales,\n          defaultLocale,\n          page,\n          isAppPath,\n          requestHeaders,\n          cacheHandler: this.nextConfig.cacheHandler,\n          cacheHandlers: this.nextConfig.experimental.cacheHandlers,\n          cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n          fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n          isrFlushToDisk: this.nextConfig.experimental.isrFlushToDisk,\n          maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n          nextConfigOutput: this.nextConfig.output,\n          buildId: this.buildId,\n          authInterrupts: Boolean(this.nextConfig.experimental.authInterrupts),\n          sriEnabled: Boolean(this.nextConfig.experimental.sri?.algorithm),\n        })\n        return pathsResult\n      } finally {\n        // we don't re-use workers so destroy the used one\n        staticPathsWorker.end()\n      }\n    }\n    const result = this.staticPathsCache.get(pathname)\n\n    const nextInvoke = withCoalescedInvoke(__getStaticPaths)(\n      `staticPaths-${pathname}`,\n      []\n    )\n      .then((res) => {\n        const { prerenderedRoutes: staticPaths, fallbackMode: fallback } =\n          res.value\n        if (!isAppPath && this.nextConfig.output === 'export') {\n          if (fallback === FallbackMode.BLOCKING_STATIC_RENDER) {\n            throw new Error(\n              'getStaticPaths with \"fallback: blocking\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'\n            )\n          } else if (fallback === FallbackMode.PRERENDER) {\n            throw new Error(\n              'getStaticPaths with \"fallback: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'\n            )\n          }\n        }\n\n        const value: {\n          staticPaths: string[] | undefined\n          fallbackMode: FallbackMode | undefined\n        } = {\n          staticPaths: staticPaths?.map((route) => route.pathname),\n          fallbackMode: fallback,\n        }\n        this.staticPathsCache.set(pathname, value)\n        return value\n      })\n      .catch((err) => {\n        this.staticPathsCache.remove(pathname)\n        if (!result) throw err\n        Log.error(`Failed to generate static paths for ${pathname}:`)\n        console.error(err)\n      })\n\n    if (result) {\n      return result\n    }\n    return nextInvoke as NonNullable<typeof result>\n  }\n\n  protected async ensurePage(opts: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    definition: RouteDefinition | undefined\n    url?: string\n  }): Promise<void> {\n    await this.bundlerService.ensurePage(opts)\n  }\n\n  protected async findPageComponents({\n    locale,\n    page,\n    query,\n    params,\n    isAppPath,\n    appPaths = null,\n    shouldEnsure,\n    url,\n  }: {\n    locale: string | undefined\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    sriEnabled?: boolean\n    appPaths?: ReadonlyArray<string> | null\n    shouldEnsure: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null> {\n    await this.ready?.promise\n\n    const compilationErr = await this.getCompilationError(page)\n    if (compilationErr) {\n      // Wrap build errors so that they don't get logged again\n      throw new WrappedBuildError(compilationErr)\n    }\n    if (shouldEnsure || this.serverOptions.customServer) {\n      await this.ensurePage({\n        page,\n        appPaths,\n        clientOnly: false,\n        definition: undefined,\n        url,\n      })\n    }\n\n    this.nextFontManifest = super.getNextFontManifest()\n\n    return await super.findPageComponents({\n      page,\n      query,\n      params,\n      locale,\n      isAppPath,\n      shouldEnsure,\n      url,\n    })\n  }\n\n  protected async getFallbackErrorComponents(\n    url?: string\n  ): Promise<LoadComponentsReturnType | null> {\n    await this.bundlerService.getFallbackErrorComponents(url)\n    return await loadDefaultErrorComponents(this.distDir)\n  }\n\n  async getCompilationError(page: string): Promise<any> {\n    return await this.bundlerService.getCompilationError(page)\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    await super.instrumentationOnRequestError(...args)\n\n    const err = args[0]\n    this.logErrorWithOriginalStack(err, 'app-dir')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}