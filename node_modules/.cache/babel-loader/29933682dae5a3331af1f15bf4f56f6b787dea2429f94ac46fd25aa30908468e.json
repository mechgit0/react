{"ast":null,"code":"'use strict';\n\nexports.getValueAsString = function getValueString(value) {\n  if (Number.isNaN(value)) {\n    return 'Nan';\n  } else if (!Number.isFinite(value)) {\n    if (value < 0) {\n      return '-Inf';\n    } else {\n      return '+Inf';\n    }\n  } else {\n    return `${value}`;\n  }\n};\nexports.removeLabels = function removeLabels(hashMap, labels, sortedLabelNames) {\n  const hash = hashObject(labels, sortedLabelNames);\n  delete hashMap[hash];\n};\nexports.setValue = function setValue(hashMap, value, labels) {\n  const hash = hashObject(labels);\n  hashMap[hash] = {\n    value: typeof value === 'number' ? value : 0,\n    labels: labels || {}\n  };\n  return hashMap;\n};\nexports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels) {\n  let hash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  const value = typeof deltaValue === 'number' ? deltaValue : 0;\n  if (hashMap[hash]) {\n    hashMap[hash].value += value;\n  } else {\n    hashMap[hash] = {\n      value,\n      labels\n    };\n  }\n  return hashMap;\n};\nexports.getLabels = function (labelNames, args) {\n  if (typeof args[0] === 'object') {\n    return args[0];\n  }\n  if (labelNames.length !== args.length) {\n    throw new Error(`Invalid number of arguments (${args.length}): \"${args.join(', ')}\" for label names (${labelNames.length}): \"${labelNames.join(', ')}\".`);\n  }\n  const acc = {};\n  for (let i = 0; i < labelNames.length; i++) {\n    acc[labelNames[i]] = args[i];\n  }\n  return acc;\n};\nfunction fastHashObject(keys, labels) {\n  if (keys.length === 0) {\n    return '';\n  }\n  let hash = '';\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = labels[key];\n    if (value === undefined) continue;\n    hash += `${key}:${value},`;\n  }\n  return hash;\n}\nfunction hashObject(labels, labelNames) {\n  // We don't actually need a hash here. We just need a string that\n  // is unique for each possible labels object and consistent across\n  // calls with equivalent labels objects.\n\n  if (labelNames) {\n    return fastHashObject(labelNames, labels);\n  }\n  const keys = Object.keys(labels);\n  if (keys.length > 1) {\n    keys.sort(); // need consistency across calls\n  }\n  return fastHashObject(keys, labels);\n}\nexports.hashObject = hashObject;\nexports.isObject = function isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n};\nexports.nowTimestamp = function nowTimestamp() {\n  return Date.now() / 1000;\n};\nclass Grouper extends Map {\n  /**\n   * Adds the `value` to the `key`'s array of values.\n   * @param {*} key Key to set.\n   * @param {*} value Value to add to `key`'s array.\n   * @returns {undefined} undefined.\n   */\n  add(key, value) {\n    if (this.has(key)) {\n      this.get(key).push(value);\n    } else {\n      this.set(key, [value]);\n    }\n  }\n}\nexports.Grouper = Grouper;","map":{"version":3,"names":["exports","getValueAsString","getValueString","value","Number","isNaN","isFinite","removeLabels","hashMap","labels","sortedLabelNames","hash","hashObject","setValue","setValueDelta","deltaValue","arguments","length","undefined","getLabels","labelNames","args","Error","join","acc","i","fastHashObject","keys","key","Object","sort","isObject","obj","nowTimestamp","Date","now","Grouper","Map","add","has","get","push","set"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/util.js"],"sourcesContent":["'use strict';\n\nexports.getValueAsString = function getValueString(value) {\n\tif (Number.isNaN(value)) {\n\t\treturn 'Nan';\n\t} else if (!Number.isFinite(value)) {\n\t\tif (value < 0) {\n\t\t\treturn '-Inf';\n\t\t} else {\n\t\t\treturn '+Inf';\n\t\t}\n\t} else {\n\t\treturn `${value}`;\n\t}\n};\n\nexports.removeLabels = function removeLabels(\n\thashMap,\n\tlabels,\n\tsortedLabelNames,\n) {\n\tconst hash = hashObject(labels, sortedLabelNames);\n\tdelete hashMap[hash];\n};\n\nexports.setValue = function setValue(hashMap, value, labels) {\n\tconst hash = hashObject(labels);\n\thashMap[hash] = {\n\t\tvalue: typeof value === 'number' ? value : 0,\n\t\tlabels: labels || {},\n\t};\n\treturn hashMap;\n};\n\nexports.setValueDelta = function setValueDelta(\n\thashMap,\n\tdeltaValue,\n\tlabels,\n\thash = '',\n) {\n\tconst value = typeof deltaValue === 'number' ? deltaValue : 0;\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t} else {\n\t\thashMap[hash] = { value, labels };\n\t}\n\treturn hashMap;\n};\n\nexports.getLabels = function (labelNames, args) {\n\tif (typeof args[0] === 'object') {\n\t\treturn args[0];\n\t}\n\n\tif (labelNames.length !== args.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of arguments (${args.length}): \"${args.join(\n\t\t\t\t', ',\n\t\t\t)}\" for label names (${labelNames.length}): \"${labelNames.join(', ')}\".`,\n\t\t);\n\t}\n\n\tconst acc = {};\n\tfor (let i = 0; i < labelNames.length; i++) {\n\t\tacc[labelNames[i]] = args[i];\n\t}\n\treturn acc;\n};\n\nfunction fastHashObject(keys, labels) {\n\tif (keys.length === 0) {\n\t\treturn '';\n\t}\n\n\tlet hash = '';\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst value = labels[key];\n\t\tif (value === undefined) continue;\n\n\t\thash += `${key}:${value},`;\n\t}\n\n\treturn hash;\n}\n\nfunction hashObject(labels, labelNames) {\n\t// We don't actually need a hash here. We just need a string that\n\t// is unique for each possible labels object and consistent across\n\t// calls with equivalent labels objects.\n\n\tif (labelNames) {\n\t\treturn fastHashObject(labelNames, labels);\n\t}\n\n\tconst keys = Object.keys(labels);\n\tif (keys.length > 1) {\n\t\tkeys.sort(); // need consistency across calls\n\t}\n\n\treturn fastHashObject(keys, labels);\n}\nexports.hashObject = hashObject;\n\nexports.isObject = function isObject(obj) {\n\treturn obj !== null && typeof obj === 'object';\n};\n\nexports.nowTimestamp = function nowTimestamp() {\n\treturn Date.now() / 1000;\n};\n\nclass Grouper extends Map {\n\t/**\n\t * Adds the `value` to the `key`'s array of values.\n\t * @param {*} key Key to set.\n\t * @param {*} value Value to add to `key`'s array.\n\t * @returns {undefined} undefined.\n\t */\n\tadd(key, value) {\n\t\tif (this.has(key)) {\n\t\t\tthis.get(key).push(value);\n\t\t} else {\n\t\t\tthis.set(key, [value]);\n\t\t}\n\t}\n}\n\nexports.Grouper = Grouper;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}