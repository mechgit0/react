{"ast":null,"code":"'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\nconst Registry = require('./registry');\nconst {\n  Grouper\n} = require('./util');\nconst {\n  aggregators\n} = require('./metricAggregators');\n// We need to lazy-load the 'cluster' module as some application servers -\n// namely Passenger - crash when it is imported.\nlet cluster = () => {\n  const data = require('cluster');\n  cluster = () => data;\n  return data;\n};\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n  constructor() {\n    let regContentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Registry.PROMETHEUS_CONTENT_TYPE;\n    super(regContentType);\n    addListeners();\n  }\n\n  /**\n   * Gets aggregated metrics for all workers. The optional callback and\n   * returned Promise resolve with the same value; either may be used.\n   * @return {Promise<string>} Promise that resolves with the aggregated\n   *   metrics.\n   */\n  clusterMetrics() {\n    const requestId = requestCtr++;\n    return new Promise((resolve, reject) => {\n      let settled = false;\n      function done(err, result) {\n        if (settled) return;\n        settled = true;\n        if (err) reject(err);else resolve(result);\n      }\n      const request = {\n        responses: [],\n        pending: 0,\n        done,\n        errorTimeout: setTimeout(() => {\n          const err = new Error('Operation timed out.');\n          request.done(err);\n        }, 5000)\n      };\n      requests.set(requestId, request);\n      const message = {\n        type: GET_METRICS_REQ,\n        requestId\n      };\n      for (const id in cluster().workers) {\n        // If the worker exits abruptly, it may still be in the workers\n        // list but not able to communicate.\n        if (cluster().workers[id].isConnected()) {\n          cluster().workers[id].send(message);\n          request.pending++;\n        }\n      }\n      if (request.pending === 0) {\n        // No workers were up\n        clearTimeout(request.errorTimeout);\n        process.nextTick(() => done(null, ''));\n      }\n    });\n  }\n  get contentType() {\n    return super.contentType;\n  }\n\n  /**\n   * Creates a new Registry instance from an array of metrics that were\n   * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n   * the method specified by their `aggregator` property, or by summation if\n   * `aggregator` is undefined.\n   * @param {Array} metricsArr Array of metrics, each of which created by\n   *   `registry.getMetricsAsJSON()`.\n   * @param {string} registryType content type of the new registry. Defaults\n   * to PROMETHEUS_CONTENT_TYPE.\n   * @return {Registry} aggregated registry.\n   */\n  static aggregate(metricsArr) {\n    let registryType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Registry.PROMETHEUS_CONTENT_TYPE;\n    const aggregatedRegistry = new Registry();\n    const metricsByName = new Grouper();\n    aggregatedRegistry.setContentType(registryType);\n\n    // Gather by name\n    metricsArr.forEach(metrics => {\n      metrics.forEach(metric => {\n        metricsByName.add(metric.name, metric);\n      });\n    });\n\n    // Aggregate gathered metrics.\n    metricsByName.forEach(metrics => {\n      const aggregatorName = metrics[0].aggregator;\n      const aggregatorFn = aggregators[aggregatorName];\n      if (typeof aggregatorFn !== 'function') {\n        throw new Error(`'${aggregatorName}' is not a defined aggregator.`);\n      }\n      const aggregatedMetric = aggregatorFn(metrics);\n      // NB: The 'omit' aggregator returns undefined.\n      if (aggregatedMetric) {\n        const aggregatedMetricWrapper = Object.assign({\n          get: () => aggregatedMetric\n        }, aggregatedMetric);\n        aggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n      }\n    });\n    return aggregatedRegistry;\n  }\n\n  /**\n   * Sets the registry or registries to be aggregated. Call from workers to\n   * use a registry/registries other than the default global registry.\n   * @param {Array<Registry>|Registry} regs Registry or registries to be\n   *   aggregated.\n   * @return {void}\n   */\n  static setRegistries(regs) {\n    if (!Array.isArray(regs)) regs = [regs];\n    regs.forEach(reg => {\n      if (!(reg instanceof Registry)) {\n        throw new TypeError(`Expected Registry, got ${typeof reg}`);\n      }\n    });\n    registries = regs;\n  }\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n  if (listenersAdded) return;\n  listenersAdded = true;\n  if (cluster().isMaster) {\n    // Listen for worker responses to requests for local metrics\n    cluster().on('message', (worker, message) => {\n      if (message.type === GET_METRICS_RES) {\n        const request = requests.get(message.requestId);\n        if (message.error) {\n          request.done(new Error(message.error));\n          return;\n        }\n        message.metrics.forEach(registry => request.responses.push(registry));\n        request.pending--;\n        if (request.pending === 0) {\n          // finalize\n          requests.delete(message.requestId);\n          clearTimeout(request.errorTimeout);\n          const registry = AggregatorRegistry.aggregate(request.responses);\n          const promString = registry.metrics();\n          request.done(null, promString);\n        }\n      }\n    });\n  }\n  if (cluster().isWorker) {\n    // Respond to master's requests for worker's local metrics.\n    process.on('message', message => {\n      if (message.type === GET_METRICS_REQ) {\n        Promise.all(registries.map(r => r.getMetricsAsJSON())).then(metrics => {\n          process.send({\n            type: GET_METRICS_RES,\n            requestId: message.requestId,\n            metrics\n          });\n        }).catch(error => {\n          process.send({\n            type: GET_METRICS_RES,\n            requestId: message.requestId,\n            error: error.message\n          });\n        });\n      }\n    });\n  }\n}\nmodule.exports = AggregatorRegistry;","map":{"version":3,"names":["Registry","require","Grouper","aggregators","cluster","data","GET_METRICS_REQ","GET_METRICS_RES","registries","globalRegistry","requestCtr","listenersAdded","requests","Map","AggregatorRegistry","constructor","regContentType","arguments","length","undefined","PROMETHEUS_CONTENT_TYPE","addListeners","clusterMetrics","requestId","Promise","resolve","reject","settled","done","err","result","request","responses","pending","errorTimeout","setTimeout","Error","set","message","type","id","workers","isConnected","send","clearTimeout","process","nextTick","contentType","aggregate","metricsArr","registryType","aggregatedRegistry","metricsByName","setContentType","forEach","metrics","metric","add","name","aggregatorName","aggregator","aggregatorFn","aggregatedMetric","aggregatedMetricWrapper","Object","assign","get","registerMetric","setRegistries","regs","Array","isArray","reg","TypeError","isMaster","on","worker","error","registry","push","delete","promString","isWorker","all","map","r","getMetricsAsJSON","then","catch","module","exports"],"sources":["/home/ashish/my-react-app/node_modules/prom-client/lib/cluster.js"],"sourcesContent":["'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\n\nconst Registry = require('./registry');\nconst { Grouper } = require('./util');\nconst { aggregators } = require('./metricAggregators');\n// We need to lazy-load the 'cluster' module as some application servers -\n// namely Passenger - crash when it is imported.\nlet cluster = () => {\n\tconst data = require('cluster');\n\tcluster = () => data;\n\treturn data;\n};\n\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\n\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n\tconstructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {\n\t\tsuper(regContentType);\n\t\taddListeners();\n\t}\n\n\t/**\n\t * Gets aggregated metrics for all workers. The optional callback and\n\t * returned Promise resolve with the same value; either may be used.\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t *   metrics.\n\t */\n\tclusterMetrics() {\n\t\tconst requestId = requestCtr++;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet settled = false;\n\t\t\tfunction done(err, result) {\n\t\t\t\tif (settled) return;\n\t\t\t\tsettled = true;\n\t\t\t\tif (err) reject(err);\n\t\t\t\telse resolve(result);\n\t\t\t}\n\n\t\t\tconst request = {\n\t\t\t\tresponses: [],\n\t\t\t\tpending: 0,\n\t\t\t\tdone,\n\t\t\t\terrorTimeout: setTimeout(() => {\n\t\t\t\t\tconst err = new Error('Operation timed out.');\n\t\t\t\t\trequest.done(err);\n\t\t\t\t}, 5000),\n\t\t\t};\n\t\t\trequests.set(requestId, request);\n\n\t\t\tconst message = {\n\t\t\t\ttype: GET_METRICS_REQ,\n\t\t\t\trequestId,\n\t\t\t};\n\n\t\t\tfor (const id in cluster().workers) {\n\t\t\t\t// If the worker exits abruptly, it may still be in the workers\n\t\t\t\t// list but not able to communicate.\n\t\t\t\tif (cluster().workers[id].isConnected()) {\n\t\t\t\t\tcluster().workers[id].send(message);\n\t\t\t\t\trequest.pending++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request.pending === 0) {\n\t\t\t\t// No workers were up\n\t\t\t\tclearTimeout(request.errorTimeout);\n\t\t\t\tprocess.nextTick(() => done(null, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\tget contentType() {\n\t\treturn super.contentType;\n\t}\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @param {string} registryType content type of the new registry. Defaults\n\t * to PROMETHEUS_CONTENT_TYPE.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate(\n\t\tmetricsArr,\n\t\tregistryType = Registry.PROMETHEUS_CONTENT_TYPE,\n\t) {\n\t\tconst aggregatedRegistry = new Registry();\n\t\tconst metricsByName = new Grouper();\n\n\t\taggregatedRegistry.setContentType(registryType);\n\n\t\t// Gather by name\n\t\tmetricsArr.forEach(metrics => {\n\t\t\tmetrics.forEach(metric => {\n\t\t\t\tmetricsByName.add(metric.name, metric);\n\t\t\t});\n\t\t});\n\n\t\t// Aggregate gathered metrics.\n\t\tmetricsByName.forEach(metrics => {\n\t\t\tconst aggregatorName = metrics[0].aggregator;\n\t\t\tconst aggregatorFn = aggregators[aggregatorName];\n\t\t\tif (typeof aggregatorFn !== 'function') {\n\t\t\t\tthrow new Error(`'${aggregatorName}' is not a defined aggregator.`);\n\t\t\t}\n\t\t\tconst aggregatedMetric = aggregatorFn(metrics);\n\t\t\t// NB: The 'omit' aggregator returns undefined.\n\t\t\tif (aggregatedMetric) {\n\t\t\t\tconst aggregatedMetricWrapper = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tget: () => aggregatedMetric,\n\t\t\t\t\t},\n\t\t\t\t\taggregatedMetric,\n\t\t\t\t);\n\t\t\t\taggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n\t\t\t}\n\t\t});\n\n\t\treturn aggregatedRegistry;\n\t}\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(regs) {\n\t\tif (!Array.isArray(regs)) regs = [regs];\n\t\tregs.forEach(reg => {\n\t\t\tif (!(reg instanceof Registry)) {\n\t\t\t\tthrow new TypeError(`Expected Registry, got ${typeof reg}`);\n\t\t\t}\n\t\t});\n\t\tregistries = regs;\n\t}\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n\tif (listenersAdded) return;\n\tlistenersAdded = true;\n\n\tif (cluster().isMaster) {\n\t\t// Listen for worker responses to requests for local metrics\n\t\tcluster().on('message', (worker, message) => {\n\t\t\tif (message.type === GET_METRICS_RES) {\n\t\t\t\tconst request = requests.get(message.requestId);\n\n\t\t\t\tif (message.error) {\n\t\t\t\t\trequest.done(new Error(message.error));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage.metrics.forEach(registry => request.responses.push(registry));\n\t\t\t\trequest.pending--;\n\n\t\t\t\tif (request.pending === 0) {\n\t\t\t\t\t// finalize\n\t\t\t\t\trequests.delete(message.requestId);\n\t\t\t\t\tclearTimeout(request.errorTimeout);\n\n\t\t\t\t\tconst registry = AggregatorRegistry.aggregate(request.responses);\n\t\t\t\t\tconst promString = registry.metrics();\n\t\t\t\t\trequest.done(null, promString);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif (cluster().isWorker) {\n\t\t// Respond to master's requests for worker's local metrics.\n\t\tprocess.on('message', message => {\n\t\t\tif (message.type === GET_METRICS_REQ) {\n\t\t\t\tPromise.all(registries.map(r => r.getMetricsAsJSON()))\n\t\t\t\t\t.then(metrics => {\n\t\t\t\t\t\tprocess.send({\n\t\t\t\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\t\t\t\trequestId: message.requestId,\n\t\t\t\t\t\t\tmetrics,\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tprocess.send({\n\t\t\t\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\t\t\t\trequestId: message.requestId,\n\t\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = AggregatorRegistry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}